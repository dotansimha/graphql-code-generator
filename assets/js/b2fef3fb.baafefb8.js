"use strict";(self.webpackChunk_graphql_codegen_website=self.webpackChunk_graphql_codegen_website||[]).push([[4744],{35318:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return g}});var a=t(27378);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),u=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=u(e.components);return a.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=u(t),g=o,d=m["".concat(l,".").concat(g)]||m[g]||p[g]||r;return t?a.createElement(d,i(i({ref:n},c),{},{components:t})):a.createElement(d,i({ref:n},c))}));function g(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,i=new Array(r);i[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var u=2;u<r;u++)i[u]=t[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},86302:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return u},toc:function(){return c},default:function(){return m}});var a=t(25773),o=t(30808),r=(t(27378),t(35318)),i=["components"],s={id:"naming-convention",title:"Naming Convention"},l=void 0,u={unversionedId:"getting-started/naming-convention",id:"getting-started/naming-convention",isDocsHomePage:!1,title:"Naming Convention",description:"Codegen support many forms on outputs, and you can control the general naming-convention of the types/variables/code generated, using the namingConvention config flag.",source:"@site/docs/getting-started/naming-convention.md",sourceDirName:"getting-started",slug:"/getting-started/naming-convention",permalink:"/docs/getting-started/naming-convention",editUrl:"https://github.com/dotansimha/graphql-code-generator/edit/master/website/docs/getting-started/naming-convention.md",tags:[],version:"current",frontMatter:{id:"naming-convention",title:"Naming Convention"},sidebar:"sidebar",previous:{title:"`require` field",permalink:"/docs/getting-started/require-field"},next:{title:"Lifecycle Hooks",permalink:"/docs/getting-started/lifecycle-hooks"}},c=[{value:"<code>namingConvention</code>",id:"namingconvention",children:[{value:"Usage Examples",id:"usage-examples",children:[{value:"Override All Names",id:"override-all-names",children:[],level:5},{value:"Upper-case enum values",id:"upper-case-enum-values",children:[],level:5},{value:"Keep names as is",id:"keep-names-as-is",children:[],level:5},{value:"Remove Underscores",id:"remove-underscores",children:[],level:5}],level:4},{value:"Using external modules",id:"using-external-modules",children:[],level:4},{value:"Providing your own naming function",id:"providing-your-own-naming-function",children:[],level:4}],level:3}],p={toc:c};function m(e){var n=e.components,t=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Codegen support many forms on outputs, and you can control the general naming-convention of the types/variables/code generated, using the ",(0,r.kt)("inlineCode",{parentName:"p"},"namingConvention")," config flag."),(0,r.kt)("h3",{id:"namingconvention"},(0,r.kt)("inlineCode",{parentName:"h3"},"namingConvention")),(0,r.kt)("p",null,"type: ",(0,r.kt)("inlineCode",{parentName:"p"},"NamingConvention"),"\ndefault: ",(0,r.kt)("inlineCode",{parentName:"p"},"change-case-all#pascalCase")),(0,r.kt)("p",null,"Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid ",(0,r.kt)("inlineCode",{parentName:"p"},"module#method"),".\nAllowed values for specific output are: ",(0,r.kt)("inlineCode",{parentName:"p"},"typeNames"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"enumValues"),'.\nYou can also use "keep" to keep all GraphQL names as-is.\nAdditionally you can set ',(0,r.kt)("inlineCode",{parentName:"p"},"transformUnderscore")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if you want to override the default behavior,\nwhich is to preserves underscores."),(0,r.kt)("h4",{id:"usage-examples"},"Usage Examples"),(0,r.kt)("h5",{id:"override-all-names"},"Override All Names"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yml"},"config:\n  namingConvention: change-case-all#lowerCase\n")),(0,r.kt)("h5",{id:"upper-case-enum-values"},"Upper-case enum values"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yml"},"config:\n  namingConvention:\n    typeNames: change-case-all#pascalCase\n    enumValues: change-case-all#upperCase\n")),(0,r.kt)("h5",{id:"keep-names-as-is"},"Keep names as is"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yml"},"config:\n  namingConvention: keep\n")),(0,r.kt)("h5",{id:"remove-underscores"},"Remove Underscores"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yml"},"config:\n  namingConvention:\n    typeNames: change-case-all#pascalCase\n    transformUnderscore: true\n")),(0,r.kt)("h4",{id:"using-external-modules"},"Using external modules"),(0,r.kt)("p",null,"All the examples you saw so far were using  ",(0,r.kt)("inlineCode",{parentName:"p"},"change-case-all")," package. That package is a dependency of graphql-codegen so you can use it directly.\nHowever you can use any other package as long as you have it installed as dependency.\nYou need to use the same syntax as you saw  previously but with the package of your choice. The syntax is as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"package-name#export-you-want-to-use\n")),(0,r.kt)("p",null,"For example, if you want to use ",(0,r.kt)("inlineCode",{parentName:"p"},"camelCase")," from lodash, given that you have it already installed you will do it like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yml"},"config:\n  namingConvention: lodash#camelCase\n")),(0,r.kt)("h4",{id:"providing-your-own-naming-function"},"Providing your own naming function"),(0,r.kt)("p",null,"As you may have guessed already, there is nothing fancy about naming functions.\nThey are just functions that take a string as input, and produce an string as output.\nIf you stick to that signature, you can provide your own naming function.\nYou need to provide a CJS module with a default export of a function that takes an string and returns an string.\nOn the following example there is a workaround for a limitation that ",(0,r.kt)("inlineCode",{parentName:"p"},"change-case-all")," functions has."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// my-naming-fn.js\n// Fix for https://github.com/dotansimha/graphql-code-generator/issues/6040\nconst { constantCase } = require('change-case-all')\n/**\n * This function wraps constant case, that turns any string into CONSTANT_CASE\n * However, this function has a bug that, if you pass _ to it it will return an empty\n * string. This small module fixes that\n *\n * @param {string*} str\n * @return {string}\n */\nfunction FixedConstantCase(str) {\n  const result = constantCase(str)\n  // If result is an empty string, just return the original string\n  return result || str\n}\nmodule.exports = FixedConstantCase\n")),(0,r.kt)("p",null,"Then, on the config you just provide the path to your custom naming module:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yml"},"config:\n  namingConvention: ./my-naming-fn\n")),(0,r.kt)("p",null,"This also applies when you want specific custom naming convention per output.\nSpecify your custom naming function on the output or outputs you want to apply it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yml"},"config:\n  namingConvention:\n    typeNames: ./my-naming-fn\n")))}m.isMDXComponent=!0}}]);