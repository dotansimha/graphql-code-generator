{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "Types.Config": {
      "description": "Represents the root YAML schema for the config file.",
      "additionalProperties": false,
      "type": "object",
      "properties": {
        "schema": {
          "$ref": "#/definitions/Types.InstanceOrArray",
          "description": "A pointer(s) to your GraphQL schema. This schema will be the base schema for all your outputs.\nYou can use one of the following:\n\n- URL pointing to a GraphQL endpoint\n- Path to a local `.json` file\n- Path to a local `.graphql` file\n- Glob expression pointing to multiple `.graphql` files\n- Path to a local code file (for example: `.js`) that exports `GraphQLSchema` object\n- Inline string containing GraphQL SDL schema definition\n\nYou can specify either a single schema, or multiple, and GraphQL Code Generator will merge the schemas into a single schema.\n\nFor more details: https://graphql-code-generator.com/docs/getting-started/schema-field"
        },
        "require": {
          "$ref": "#/definitions/Types.RequireExtension",
          "description": "A path to a file which defines custom Node.JS require() handlers for custom file extensions.\nThis is essential if the code generator has to go through files which require other files in an unsupported format (by default).\n\nFor more details: https://graphql-code-generator.com/docs/getting-started/require-field\nSee more information about require.extensions: https://gist.github.com/jamestalmage/df922691475cff66c7e6.\n\nNote: values that specified in your .yml file will get loaded after loading the config .yml file."
        },
        "customFetch": {
          "description": "Name for a library that implements `fetch`.\nUse this to tell codegen to use that to fetch schemas in a custom way.",
          "type": "string"
        },
        "documents": {
          "$ref": "#/definitions/Types.InstanceOrArray_1",
          "description": "A pointer(s) to your GraphQL documents: query, mutation, subscription and fragment. These documents will be loaded into for all your output files.\nYou can use one of the following:\n\n- Path to a local `.graphql` file\n- Path to a code file (for example: `.js` or `.tsx`) containing GraphQL operation strings.\n- Glob expression pointing to multiple `.graphql` files\n- Glob expression pointing to multiple code files\n- Inline string containing GraphQL SDL operation definition\n\nYou can specify either a single file, or multiple.\n\nFor more details: https://graphql-code-generator.com/docs/getting-started/documents-field"
        },
        "config": {
          "$ref": "#/definitions/Types.PluginConfig",
          "type": "object",
          "additionalProperties": true,
          "description": "Configuration object containing key => value that will be passes to the plugins.\nSpecifying configuration in this level of your configuration file will pass it to all plugins, in all outputs.\n\nThe options may vary depends on what plugins you are using.\n\nFor more details: https://graphql-code-generator.com/docs/getting-started/config-field"
        },
        "generates": {
          "description": "A map where the key represents an output path for the generated code and the value represents a set of options which are relevant for that specific file.\n\nFor more details: https://graphql-code-generator.com/docs/getting-started/codegen-config",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Types.ConfiguredOutput"
          }
        },
        "overwrite": {
          "description": "A flag to overwrite files if they already exist when generating code (`true` by default).\n\nFor more details: https://graphql-code-generator.com/docs/getting-started/codegen-config",
          "type": "boolean"
        },
        "watch": {
          "description": "A flag to trigger codegen when there are changes in the specified GraphQL schemas.\n\nYou can either specify a boolean to turn it on/off or specify an array of glob patterns to add custom files to the watch.\n\nFor more details: https://graphql-code-generator.com/docs/getting-started/development-workflow#watch-mode",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            {
              "type": ["string", "boolean"]
            }
          ]
        },
        "watchConfig": {
          "description": "Allows overriding the behavior of watch to use stat polling over native file watching support.\n\nConfig fields have the same defaults and sematics as the identically named ones for chokidar.\n\nFor more details: https://graphql-code-generator.com/docs/getting-started/development-workflow#watch-mode",
          "type": "object",
          "properties": {
            "usePolling": {
              "type": "boolean"
            },
            "interval": {
              "type": "number"
            }
          }
        },
        "silent": {
          "description": "A flag to suppress printing errors when they occur.",
          "type": "boolean"
        },
        "errorsOnly": {
          "description": "A flag to print only errors.",
          "type": "boolean"
        },
        "pluginLoader": {
          "$ref": "#/definitions/Types.PackageLoaderFn",
          "description": "If you are using the programmatic API in a browser environment, you can override this configuration to load your plugins in a way different than require."
        },
        "pluginContext": {
          "description": "Additional context passed to plugins",
          "type": "object",
          "additionalProperties": {}
        },
        "pluckConfig": {
          "description": "Allows you to override the configuration for `@graphql-tools/graphql-tag-pluck`, the tool that extracts your GraphQL operations from your code files.\n\nFor more details: https://graphql-code-generator.com/docs/getting-started/documents-field#graphql-tag-pluck",
          "type": "object",
          "properties": {
            "modules": {
              "$ref": "#/definitions/Array",
              "description": "An array of package name and identifier that will be used to track down your gql usages and imports. Use this if your code files imports gql from another library or you have a custom gql tag. identifier is the named export, so don't provide it if the tag function is imported as default."
            },
            "magicComment": {
              "description": "Configures the magic GraphQL comments to look for. The default is `GraphQL`.",
              "type": "string"
            },
            "globalIdentifier": {
              "description": "Overrides the name of the default GraphQL name identifier.",
              "type": "string"
            }
          }
        },
        "hooks": {
          "$ref": "#/definitions/Types.LifecycleHooksDefinition",
          "description": "Specifies scripts to run when events are happening in the codegen core.\nHooks defined on that level will effect all output files.\n\nFor more details: https://graphql-code-generator.com/docs/getting-started/lifecycle-hooks"
        }
      }
    },
    "ReactQueryRawPluginConfig": {
      "description": "This plugin generates `React-Query` Hooks with TypeScript typings.\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` - and thus shares a similar configuration.",
      "type": "object",
      "properties": {
        "fetcher": {
          "description": "Customize the fetcher you wish to use in the generated file. React-Query is agnostic to the data-fetcing layer, so you should provide it, or use a custom one.\n\nThe following options are available to use:\n- 'fetch' - requires you to specify endpoint and headers on each call, and uses `fetch` to do the actual http call.\n- `{ endpoint: string, fetchParams: RequestInit }`: hardcode your endpoint and fetch options into the generated output, using the environment `fetch` method. You can also use `process.env.MY_VAR` as endpoint or header value.\n- `file#identifier` - You can use custom fetcher method that should implement the exported `ReactQueryFetcher` interface. Example: `./my-fetcher#myCustomFetcher`.\n- `graphql-request`: Will generate each hook with `client` argument, where you should pass your own `GraphQLClient` (created from `graphql-request`).",
          "anyOf": [
            {
              "type": "object",
              "properties": {
                "endpoint": {
                  "type": "string"
                },
                "fetchParams": {
                  "$ref": "#/definitions/Record"
                }
              }
            },
            {
              "type": "string"
            }
          ]
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariablePrefix": {
          "description": "Changes the GraphQL operations variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariableSuffix": {
          "description": "Changes the GraphQL operations variables suffix.\nDefault value: \"Document\"",
          "type": "string"
        },
        "fragmentVariablePrefix": {
          "description": "Changes the GraphQL fragments variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "fragmentVariableSuffix": {
          "description": "Changes the GraphQL fragments variables suffix.\nDefault value: \"FragmentDoc\"",
          "type": "string"
        },
        "optimizeDocumentNode": {
          "description": "If you are using `documentNode: documentMode | documentNodeImportFragments`, you can set this to `true` to apply document optimizations for your GraphQL document.\nThis will remove all \"loc\" and \"description\" fields from the compiled document, and will remove all empty arrays (such as `directives`, `arguments` and `variableDefinitions`).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "pureMagicComment": {
          "description": "This config adds PURE magic comment to the static variables to enforce treeshaking for your bundler.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserves underscores.\nDefault value: \"pascal-case#pascalCase\""
        },
        "typesPrefix": {
          "description": "Prefixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "typesSuffix": {
          "description": "Suffixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "skipTypename": {
          "description": "Does not add __typename to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        }
      }
    },
    "ApolloClientHelpersConfig": {
      "type": "object",
      "properties": {
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "requireKeyFields": {
          "type": "boolean",
          "description": "Remove optional sign from all `keyFields` fields.\nDefault value: \"false\""
        },
        "requirePoliciesForAllTypes": {
          "type": "boolean",
          "description": "Remove optional sign from all generated keys of the root TypePolicy.\nDefault value: \"false\""
        }
      }
    },
    "AddPluginConfig": {
      "type": "object",
      "properties": {
        "placement": {
          "description": "Allow you to choose where to add the content.\nDefault value: \"prepend\"",
          "enum": ["append", "content", "prepend"],
          "type": "string"
        },
        "content": {
          "description": "The actual content you wish to add, either a string or array of strings.\nYou can also specify a path to a local file and the content if it will be loaded by codegen.",
          "anyOf": [
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            {
              "type": "string"
            }
          ]
        }
      }
    },
    "TimePluginConfig": {
      "type": "object",
      "properties": {
        "format": {
          "description": "Customize the Moment format of the output time.\nDefault value: \"YYYY-MM-DDTHH:mm:ssZ\"",
          "type": "string"
        },
        "message": {
          "description": "Customize the comment message\nDefault value: \"'Generated on'\"",
          "type": "string"
        }
      }
    },
    "TypeScriptPluginConfig": {
      "description": "This plugin generates the base TypeScript types, based on your GraphQL schema.\n\nThe types generated by this plugin are simple, and refers to the exact structure of your schema, and it's used as the base types for other plugins (such as `typescript-operations` / `typescript-resolvers`)",
      "type": "object",
      "properties": {
        "avoidOptionals": {
          "description": "This will cause the generator to avoid using TypeScript optionals (`?`) on types,\nso the following definition: `type A { myField: String }` will output `myField: Maybe<string>`\ninstead of `myField?: Maybe<string>`.\nDefault value: \"false\"",
          "anyOf": [
            {
              "$ref": "#/definitions/AvoidOptionalsConfig"
            },
            {
              "type": "boolean"
            }
          ]
        },
        "constEnums": {
          "description": "Will prefix every generated `enum` with `const`, you can read more about const enums here: https://www.typescriptlang.org/docs/handbook/enums.html.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "enumsAsTypes": {
          "description": "Generates enum as TypeScript `type` instead of `enum`. Useful it you wish to generate `.d.ts` declaration file instead of `.ts`\nDefault value: \"false\"",
          "type": "boolean"
        },
        "numericEnums": {
          "description": "Controls whether to preserve typescript enum values as numbers\nDefault value: \"false\"",
          "type": "boolean"
        },
        "futureProofEnums": {
          "description": "This option controls whether or not a catch-all entry is added to enum type definitions for values that may be added in the future. You also have to set `enumsAsTypes` to true if you wish to use this option.\nThis is useful if you are using `relay`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "enumsAsConst": {
          "description": "Generates enum as TypeScript `const assertions` instead of `enum`. This can even be used to enable enum-like patterns in plain JavaScript code if you choose not to use TypeScript’s enum construct.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "onlyOperationTypes": {
          "description": "This will cause the generator to emit types for operations only (basically only enums and scalars).\nInteracts well with `preResolveTypes: true`\nDefault value: \"false\"",
          "type": "boolean"
        },
        "immutableTypes": {
          "description": "Generates immutable types by adding `readonly` to properties and uses `ReadonlyArray`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "maybeValue": {
          "description": "Allow to override the type value of `Maybe`.\nDefault value: \"T | null\"",
          "type": "string"
        },
        "noExport": {
          "description": "Set to `true` in order to generate output without `export` modifier.\nThis is useful if you are generating `.d.ts` file and want it to be globally available.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useImplementingTypes": {
          "description": "When a GraphQL interface is used for a field, this flag will use the implementing types, instead of the interface itself.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "addUnderscoreToArgsType": {
          "description": "Adds `_` to generated `Args` types in order to avoid duplicate identifiers.",
          "type": "boolean"
        },
        "enumValues": {
          "$ref": "#/definitions/EnumValuesMap",
          "description": "Overrides the default value of enum values declared in your GraphQL schema.\nYou can also map the entire enum to an external type by providing a string that of `module#type`."
        },
        "declarationKind": {
          "description": "Overrides the default output for various GraphQL elements.",
          "anyOf": [
            {
              "$ref": "#/definitions/DeclarationKindConfig"
            },
            {
              "enum": ["abstract class", "class", "interface", "type"],
              "type": "string"
            }
          ]
        },
        "enumPrefix": {
          "description": "Allow you to disable prefixing for generated enums, works in combination with `typesPrefix`.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "fieldWrapperValue": {
          "description": "Allow you to add wrapper for field type, use T as the generic value. Make sure to set `wrapFieldDefinitions` to `true` in order to make this flag work.\nDefault value: \"T\"",
          "type": "string"
        },
        "wrapFieldDefinitions": {
          "description": "Set the to `true` in order to wrap field definitions with `FieldWrapper`.\nThis is useful to allow return types such as Promises and functions.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserves underscores.\nDefault value: \"pascal-case#pascalCase\""
        },
        "typesPrefix": {
          "description": "Prefixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "typesSuffix": {
          "description": "Suffixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "skipTypename": {
          "description": "Does not add __typename to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        }
      }
    },
    "TypeScriptDocumentsPluginConfig": {
      "description": "This plugin generates TypeScript types based on your GraphQLSchema *and* your GraphQL operations and fragments.\nIt generates types for your GraphQL documents: Query, Mutation, Subscription and Fragment.\n\nNote: In most configurations, this plugin requires you to use `typescript as well, because it depends on its base types.",
      "type": "object",
      "properties": {
        "avoidOptionals": {
          "description": "This will cause the generator to avoid using TypeScript optionals (`?`) on types,\nso the following definition: `type A { myField: String }` will output `myField: Maybe<string>`\ninstead of `myField?: Maybe<string>`.\nDefault value: \"false\"",
          "anyOf": [
            {
              "$ref": "#/definitions/AvoidOptionalsConfig"
            },
            {
              "type": "boolean"
            }
          ]
        },
        "immutableTypes": {
          "description": "Generates immutable types by adding `readonly` to properties and uses `ReadonlyArray`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "flattenGeneratedTypes": {
          "description": "Flatten fragment spread and inline fragments into a simple selection set before generating.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "noExport": {
          "description": "Set the to `true` in order to generate output without `export` modifier.\nThis is useful if you are generating `.d.ts` file and want it to be globally available.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "globalNamespace": {
          "type": "boolean"
        },
        "addOperationExport": {
          "type": "boolean",
          "description": "Add const export of the operation name to output file. Pay attention that the file should be `d.ts`.\nYou can combine it with `near-operation-file preset` and therefore the types will be generated along with graphql file. Then you need to set extension in `presetConfig` to be `.gql.d.ts` and by that you can import `gql` file in `ts` files.\nIt will allow you to get everything with one import: ```import { GetClient, GetClientQuery, GetClientQueryVariables, } from \"./GetClient.gql\";```.\nDefault value: \"false\""
        },
        "preResolveTypes": {
          "description": "Avoid using `Pick` and resolve the actual primitive type of all selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "skipTypeNameForRoot": {
          "description": "Avoid adding `__typename` for root types. This is ignored when a selection explictly specifies `__typename`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "exportFragmentSpreadSubTypes": {
          "description": "If set to true, it will export the sub-types created in order to make it easier to access fields declared under fragment spread.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "addUnderscoreToArgsType": {
          "description": "Adds `_` to generated `Args` types in order to avoid duplicate identifiers.",
          "type": "boolean"
        },
        "enumValues": {
          "$ref": "#/definitions/EnumValuesMap",
          "description": "Overrides the default value of enum values declared in your GraphQL schema.\nYou can also map the entire enum to an external type by providing a string that of `module#type`."
        },
        "declarationKind": {
          "description": "Overrides the default output for various GraphQL elements.",
          "anyOf": [
            {
              "$ref": "#/definitions/DeclarationKindConfig"
            },
            {
              "enum": ["abstract class", "class", "interface", "type"],
              "type": "string"
            }
          ]
        },
        "enumPrefix": {
          "description": "Allow you to disable prefixing for generated enums, works in combination with `typesPrefix`.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "fieldWrapperValue": {
          "description": "Allow you to add wrapper for field type, use T as the generic value. Make sure to set `wrapFieldDefinitions` to `true` in order to make this flag work.\nDefault value: \"T\"",
          "type": "string"
        },
        "wrapFieldDefinitions": {
          "description": "Set the to `true` in order to wrap field definitions with `FieldWrapper`.\nThis is useful to allow return types such as Promises and functions.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "onlyOperationTypes": {
          "description": "This will cause the generator to emit types for operations only (basically only enums and scalars)\nDefault value: \"false\"",
          "type": "boolean"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserves underscores.\nDefault value: \"pascal-case#pascalCase\""
        },
        "typesPrefix": {
          "description": "Prefixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "typesSuffix": {
          "description": "Suffixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "skipTypename": {
          "description": "Does not add __typename to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        }
      }
    },
    "CSharpResolversPluginRawConfig": {
      "description": "This plugin generates C# `class` identifier for your schema types.",
      "type": "object",
      "properties": {
        "enumValues": {
          "$ref": "#/definitions/EnumValuesMap",
          "description": "Overrides the default value of enum values declared in your GraphQL schema."
        },
        "namespaceName": {
          "description": "Allow you to customize the namespace name.\nDefault value: \"GraphQLCodeGen\"",
          "type": "string"
        },
        "className": {
          "description": "Allow you to customize the parent class name.\nDefault value: \"Types\"",
          "type": "string"
        },
        "listType": {
          "description": "Allow you to customize the list type\nDefault value: \"IEnumberable\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserves underscores.\nDefault value: \"pascal-case#pascalCase\""
        },
        "typesPrefix": {
          "description": "Prefixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "typesSuffix": {
          "description": "Suffixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "skipTypename": {
          "description": "Does not add __typename to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        }
      }
    },
    "CSharpOperationsRawPluginConfig": {
      "description": "This plugin generates C# `class` based on your GraphQL operations.",
      "type": "object",
      "properties": {
        "namespaceName": {
          "description": "Allow you to customize the namespace name.\nDefault value: \"GraphQLCodeGen\"",
          "type": "string"
        },
        "namedClient": {
          "description": "Defined the global value of `namedClient`.",
          "type": "string"
        },
        "querySuffix": {
          "description": "Allows to define a custom suffix for query operations.\nDefault value: \"GQL\"",
          "type": "string"
        },
        "mutationSuffix": {
          "description": "Allows to define a custom suffix for mutation operations.\nDefault value: \"GQL\"",
          "type": "string"
        },
        "subscriptionSuffix": {
          "description": "Allows to define a custom suffix for Subscription operations.\nDefault value: \"GQL\"",
          "type": "string"
        },
        "noGraphQLTag": {
          "description": "Deprecated. Changes the documentMode to `documentNode`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "gqlImport": {
          "description": "Customize from which module will `gql` be imported from.\nThis is useful if you want to use modules other than `graphql-tag`, e.g. `graphql.macro`.\nDefault value: \"graphql-tag#gql\"",
          "type": "string"
        },
        "documentNodeImport": {
          "description": "Customize from which module will `DocumentNode` be imported from.\nThis is useful if you want to use modules other than `graphql`, e.g. `@graphql-typed-document-node`.\nDefault value: \"graphql#DocumentNode\"",
          "type": "string"
        },
        "noExport": {
          "description": "Set this configuration to `true` if you wish to tell codegen to generate code with no `export` identifier.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariablePrefix": {
          "description": "Changes the GraphQL operations variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariableSuffix": {
          "description": "Changes the GraphQL operations variables suffix.\nDefault value: \"Document\"",
          "type": "string"
        },
        "fragmentVariablePrefix": {
          "description": "Changes the GraphQL fragments variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "fragmentVariableSuffix": {
          "description": "Changes the GraphQL fragments variables suffix.\nDefault value: \"FragmentDoc\"",
          "type": "string"
        },
        "documentMode": {
          "$ref": "#/definitions/DocumentMode",
          "description": "Declares how DocumentNode are created:\n- `graphQLTag`: `graphql-tag` or other modules (check `gqlImport`) will be used to generate document nodes. If this is used, document nodes are generated on client side i.e. the module used to generate this will be shipped to the client\n- `documentNode`: document nodes will be generated as objects when we generate the templates.\n- `documentNodeImportFragments`: Similar to documentNode except it imports external fragments instead of embedding them.\n- `external`: document nodes are imported from an external file. To be used with `importDocumentNodeExternallyFrom`\nDefault value: \"graphQLTag\""
        },
        "optimizeDocumentNode": {
          "description": "If you are using `documentNode: documentMode | documentNodeImportFragments`, you can set this to `true` to apply document optimizations for your GraphQL document.\nThis will remove all \"loc\" and \"description\" fields from the compiled document, and will remove all empty arrays (such as `directives`, `arguments` and `variableDefinitions`).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "importOperationTypesFrom": {
          "description": "This config is used internally by presets, but you can use it manually to tell codegen to prefix all base types that it's using.\nThis is useful if you wish to generate base types from `typescript-operations` plugin into a different file, and import it from there.\nDefault value: \"\"",
          "type": "string"
        },
        "importDocumentNodeExternallyFrom": {
          "description": "This config should be used if `documentMode` is `external`. This has 2 usage:\n- any string: This would be the path to import document nodes from. This can be used if we want to manually create the document nodes e.g. Use `graphql-tag` in a separate file and export the generated document\n- 'near-operation-file': This is a special mode that is intended to be used with `near-operation-file` preset to import document nodes from those files. If these files are `.graphql` files, we make use of webpack loader.\nDefault value: \"\"",
          "type": "string"
        },
        "pureMagicComment": {
          "description": "This config adds PURE magic comment to the static variables to enforce treeshaking for your bundler.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserves underscores.\nDefault value: \"pascal-case#pascalCase\""
        },
        "typesPrefix": {
          "description": "Prefixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "typesSuffix": {
          "description": "Suffixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "skipTypename": {
          "description": "Does not add __typename to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        }
      }
    },
    "SchemaASTConfig": {
      "description": "This plugin prints the merged schema as string. If multiple schemas are provided, they will be merged and printed as one schema.",
      "type": "object",
      "properties": {
        "includeDirectives": {
          "description": "Include directives to Schema output.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "commentDescriptions": {
          "description": "Set to true in order to print description as comments (using # instead of \"\"\")\nDefault value: \"false\"",
          "type": "boolean"
        },
        "sort": {
          "description": "Set to true in order get the schema lexicographically sorted before printed.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "federation": {
          "type": "boolean"
        }
      }
    },
    "TypeGraphQLPluginConfig": {
      "type": "object",
      "properties": {
        "decoratorName": {
          "$ref": "#/definitions/Partial_1",
          "description": "allow overriding of TypeGraphQL decorator types\nDefault value: \"`{ type: 'ObjectType', interface: 'InterfaceType', arguments: 'ArgsType', field: 'Field', input: 'InputType' }`\""
        },
        "decorateTypes": {
          "description": "Speciies the objects that will have TypeGraphQL decorators prepended to them, by name. Non-matching types will still be output, but without decorators. If not set, all types will be decorated.",
          "type": "string[]"
        },
        "avoidOptionals": {
          "description": "This will cause the generator to avoid using TypeScript optionals (`?`) on types,\nso the following definition: `type A { myField: String }` will output `myField: Maybe<string>`\ninstead of `myField?: Maybe<string>`.\nDefault value: \"false\"",
          "anyOf": [
            {
              "$ref": "#/definitions/AvoidOptionalsConfig"
            },
            {
              "type": "boolean"
            }
          ]
        },
        "constEnums": {
          "description": "Will prefix every generated `enum` with `const`, you can read more about const enums here: https://www.typescriptlang.org/docs/handbook/enums.html.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "enumsAsTypes": {
          "description": "Generates enum as TypeScript `type` instead of `enum`. Useful it you wish to generate `.d.ts` declaration file instead of `.ts`\nDefault value: \"false\"",
          "type": "boolean"
        },
        "numericEnums": {
          "description": "Controls whether to preserve typescript enum values as numbers\nDefault value: \"false\"",
          "type": "boolean"
        },
        "futureProofEnums": {
          "description": "This option controls whether or not a catch-all entry is added to enum type definitions for values that may be added in the future. You also have to set `enumsAsTypes` to true if you wish to use this option.\nThis is useful if you are using `relay`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "enumsAsConst": {
          "description": "Generates enum as TypeScript `const assertions` instead of `enum`. This can even be used to enable enum-like patterns in plain JavaScript code if you choose not to use TypeScript’s enum construct.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "onlyOperationTypes": {
          "description": "This will cause the generator to emit types for operations only (basically only enums and scalars).\nInteracts well with `preResolveTypes: true`\nDefault value: \"false\"",
          "type": "boolean"
        },
        "immutableTypes": {
          "description": "Generates immutable types by adding `readonly` to properties and uses `ReadonlyArray`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "maybeValue": {
          "description": "Allow to override the type value of `Maybe`.\nDefault value: \"T | null\"",
          "type": "string"
        },
        "noExport": {
          "description": "Set to `true` in order to generate output without `export` modifier.\nThis is useful if you are generating `.d.ts` file and want it to be globally available.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useImplementingTypes": {
          "description": "When a GraphQL interface is used for a field, this flag will use the implementing types, instead of the interface itself.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "addUnderscoreToArgsType": {
          "description": "Adds `_` to generated `Args` types in order to avoid duplicate identifiers.",
          "type": "boolean"
        },
        "enumValues": {
          "$ref": "#/definitions/EnumValuesMap",
          "description": "Overrides the default value of enum values declared in your GraphQL schema.\nYou can also map the entire enum to an external type by providing a string that of `module#type`."
        },
        "declarationKind": {
          "description": "Overrides the default output for various GraphQL elements.",
          "anyOf": [
            {
              "$ref": "#/definitions/DeclarationKindConfig"
            },
            {
              "enum": ["abstract class", "class", "interface", "type"],
              "type": "string"
            }
          ]
        },
        "enumPrefix": {
          "description": "Allow you to disable prefixing for generated enums, works in combination with `typesPrefix`.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "fieldWrapperValue": {
          "description": "Allow you to add wrapper for field type, use T as the generic value. Make sure to set `wrapFieldDefinitions` to `true` in order to make this flag work.\nDefault value: \"T\"",
          "type": "string"
        },
        "wrapFieldDefinitions": {
          "description": "Set the to `true` in order to wrap field definitions with `FieldWrapper`.\nThis is useful to allow return types such as Promises and functions.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserves underscores.\nDefault value: \"pascal-case#pascalCase\""
        },
        "typesPrefix": {
          "description": "Prefixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "typesSuffix": {
          "description": "Suffixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "skipTypename": {
          "description": "Does not add __typename to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        }
      }
    },
    "TypeScriptFilesModulesPluginConfig": {
      "description": "This plugin generates TypeScript typings for `.graphql` files containing GraphQL documents, which later on can be consumed using [`graphql-tag/loader`](https://github.com/apollographql/graphql-tag#webpack-preprocessing-with-graphql-tagloader) or use `string` types if you will use the operations as raw strings, and get type-check and type-safety for your imports. This means that any time you import objects from `.graphql` files, your IDE will provide auto-complete.\n\nThis plugin also handles `.graphql` files containing multiple GraphQL documents, and name the imports according to the operation name.\n\n> ⚠ Fragments are not generated with named imports, only as default imports, due to `graphql-tag/loader` behavior.",
      "type": "object",
      "properties": {
        "modulePathPrefix": {
          "description": "Allows specifying a module definition path prefix to provide distinction\nbetween generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "relativeToCwd": {
          "description": "By default, only the filename is being used to generate TS module declarations. Setting this to `true` will generate it with a full path based on the CWD.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "prefix": {
          "description": "By default, a wildcard is being added as prefix, you can change that to a custom prefix\nDefault value: \"*\\/\"",
          "type": "string"
        },
        "type": {
          "description": "By default, the named exports will have a type `DocumentNode`. Change this to \"string\" if you only use raw strings.\nDefault value: \"DocumentNode\"",
          "enum": ["DocumentNode", "string"],
          "type": "string"
        }
      }
    },
    "NamedOperationsObjectPluginConfig": {
      "type": "object",
      "properties": {
        "identifierName": {
          "description": "Allow you to customize the name of the exported identifier\nDefault value: \"namedOperations\"",
          "type": "string"
        }
      }
    },
    "RawGraphQLRequestPluginConfig": {
      "description": "This plugin generates [`graphql-request`](https://www.npmjs.com/package/graphql-request) ready-to-use SDK, which is fully-typed.",
      "type": "object",
      "properties": {
        "rawRequest": {
          "description": "By default the `request` method return the `data` or `errors` key from the response. If you need to access the `extensions` key you can use the `rawRequest` method.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "noGraphQLTag": {
          "description": "Deprecated. Changes the documentMode to `documentNode`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "gqlImport": {
          "description": "Customize from which module will `gql` be imported from.\nThis is useful if you want to use modules other than `graphql-tag`, e.g. `graphql.macro`.\nDefault value: \"graphql-tag#gql\"",
          "type": "string"
        },
        "documentNodeImport": {
          "description": "Customize from which module will `DocumentNode` be imported from.\nThis is useful if you want to use modules other than `graphql`, e.g. `@graphql-typed-document-node`.\nDefault value: \"graphql#DocumentNode\"",
          "type": "string"
        },
        "noExport": {
          "description": "Set this configuration to `true` if you wish to tell codegen to generate code with no `export` identifier.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariablePrefix": {
          "description": "Changes the GraphQL operations variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariableSuffix": {
          "description": "Changes the GraphQL operations variables suffix.\nDefault value: \"Document\"",
          "type": "string"
        },
        "fragmentVariablePrefix": {
          "description": "Changes the GraphQL fragments variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "fragmentVariableSuffix": {
          "description": "Changes the GraphQL fragments variables suffix.\nDefault value: \"FragmentDoc\"",
          "type": "string"
        },
        "documentMode": {
          "$ref": "#/definitions/DocumentMode",
          "description": "Declares how DocumentNode are created:\n- `graphQLTag`: `graphql-tag` or other modules (check `gqlImport`) will be used to generate document nodes. If this is used, document nodes are generated on client side i.e. the module used to generate this will be shipped to the client\n- `documentNode`: document nodes will be generated as objects when we generate the templates.\n- `documentNodeImportFragments`: Similar to documentNode except it imports external fragments instead of embedding them.\n- `external`: document nodes are imported from an external file. To be used with `importDocumentNodeExternallyFrom`\nDefault value: \"graphQLTag\""
        },
        "optimizeDocumentNode": {
          "description": "If you are using `documentNode: documentMode | documentNodeImportFragments`, you can set this to `true` to apply document optimizations for your GraphQL document.\nThis will remove all \"loc\" and \"description\" fields from the compiled document, and will remove all empty arrays (such as `directives`, `arguments` and `variableDefinitions`).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "importOperationTypesFrom": {
          "description": "This config is used internally by presets, but you can use it manually to tell codegen to prefix all base types that it's using.\nThis is useful if you wish to generate base types from `typescript-operations` plugin into a different file, and import it from there.\nDefault value: \"\"",
          "type": "string"
        },
        "importDocumentNodeExternallyFrom": {
          "description": "This config should be used if `documentMode` is `external`. This has 2 usage:\n- any string: This would be the path to import document nodes from. This can be used if we want to manually create the document nodes e.g. Use `graphql-tag` in a separate file and export the generated document\n- 'near-operation-file': This is a special mode that is intended to be used with `near-operation-file` preset to import document nodes from those files. If these files are `.graphql` files, we make use of webpack loader.\nDefault value: \"\"",
          "type": "string"
        },
        "pureMagicComment": {
          "description": "This config adds PURE magic comment to the static variables to enforce treeshaking for your bundler.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserves underscores.\nDefault value: \"pascal-case#pascalCase\""
        },
        "typesPrefix": {
          "description": "Prefixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "typesSuffix": {
          "description": "Suffixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "skipTypename": {
          "description": "Does not add __typename to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        }
      }
    },
    "CompatibilityPluginRawConfig": {
      "description": "If you are migrating from <1.0, we created a new plugin called `typescript-compatibility` that generates backward compatibility for the `typescript-operations` and `typescript-react-apollo` plugins.\n\nIt generates types that are pointing to the new form of types. It supports _most_ of the use-cases.",
      "type": "object",
      "properties": {
        "noNamespaces": {
          "description": "Does not generate TypeScript `namespace`s and uses the operation name as prefix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "strict": {
          "description": "Make sure to generate code that compatible with TypeScript strict mode.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "preResolveTypes": {
          "description": "Avoid using `Pick` in `typescript-operations` and make sure to optimize this package as well.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserves underscores.\nDefault value: \"pascal-case#pascalCase\""
        },
        "typesPrefix": {
          "description": "Prefixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "typesSuffix": {
          "description": "Suffixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "skipTypename": {
          "description": "Does not add __typename to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        }
      }
    },
    "TypeScriptMongoPluginConfig": {
      "type": "object",
      "properties": {
        "dbTypeSuffix": {
          "description": "Customize the suffix for the generated GraphQL `type`s.\nDefault value: \"DbObject\"",
          "type": "string"
        },
        "dbInterfaceSuffix": {
          "description": "Customize the suffix for the generated GraphQL `interface`s.\nDefault value: \"DbObject\"",
          "type": "string"
        },
        "objectIdType": {
          "description": "Customize the type of `_id` fields. You can either specify a type name, or specify `module#type`.\nDefault value: \"mongodb#ObjectId\"",
          "type": "string"
        },
        "idFieldName": {
          "description": "Customize the name of the id field generated after using `@id` directive over a GraphQL field.\nDefault value: \"_id\"",
          "type": "string"
        },
        "enumsAsString": {
          "description": "Replaces generated `enum` values with `string`.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "avoidOptionals": {
          "description": "This will cause the generator to avoid using TypeScript optionals (`?`),\nso the following definition: `type A { myField: String }` will output `myField: Maybe<string>`\ninstead of `myField?: Maybe<string>`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserves underscores.\nDefault value: \"pascal-case#pascalCase\""
        },
        "typesPrefix": {
          "description": "Prefixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "typesSuffix": {
          "description": "Suffixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "skipTypename": {
          "description": "Does not add __typename to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        }
      }
    },
    "TypeScriptResolversPluginConfig": {
      "description": "This plugin generates TypeScript signature for `resolve` functions of your GraphQL API.\nYou can use this plugin a to generate simple resolvers signature based on your GraphQL types, or you can change it's behavior be providing custom model types (mappers).\n\nYou can find a blog post explaining the usage of this plugin here: https://the-guild.dev/blog/better-type-safety-for-resolvers-with-graphql-codegen",
      "type": "object",
      "properties": {
        "useIndexSignature": {
          "description": "Adds an index signature to any generates resolver.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "noSchemaStitching": {
          "description": "Disables Schema Stitching support.\n\nNote: The default behavior will be reversed in the next major release. Support for Schema Stitching will be disabled by default.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "wrapFieldDefinitions": {
          "description": "Set to `true` in order to wrap field definitions with `FieldWrapper`.\nThis is useful to allow return types such as Promises and functions. Needed for\ncompatibility with `federation: true` when\nDefault value: \"true\"",
          "type": "boolean"
        },
        "customResolveInfo": {
          "description": "You can provide your custom GraphQLResolveInfo instead of the default one from graphql-js\nDefault value: \"graphql#GraphQLResolveInfo\"",
          "type": "string"
        },
        "customResolverFn": {
          "description": "You can provide your custom ResolveFn instead the default. It has to be a type that uses the generics <TResult, TParent, TContext, TArgs>\nDefault value: \"(parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => Promise<TResult> | TResult\"",
          "type": "string"
        },
        "allowParentTypeOverride": {
          "description": "Allow you to override the `ParentType` generic in each resolver, by avoid enforcing the base type of the generated generic type.\n\nThis will generate `ParentType = Type` instead of `ParentType extends Type = Type` in each resolver.",
          "type": "boolean"
        },
        "optionalInfoArgument": {
          "description": "Sets `info` argument of resolver function to be optional field. Useful for testing.",
          "type": "boolean"
        },
        "addUnderscoreToArgsType": {
          "description": "Adds `_` to generated `Args` types in order to avoid duplicate identifiers.",
          "type": "boolean"
        },
        "contextType": {
          "description": "Use this configuration to set a custom type for your `context`, and it will\neffect all the resolvers, without the need to override it using generics each time.\nIf you wish to use an external type and import it from another file, you can use `add` plugin\nand add the required `import` statement, or you can use a `module#type` syntax.",
          "type": "string"
        },
        "fieldContextTypes": {
          "$ref": "#/definitions/Array_1",
          "description": "Use this to set a custom type for a specific field `context`.\nIt will only affect the targeted resolvers.\nYou can either use `Field.Path#ContextTypeName` or `Field.Path#ExternalFileName#ContextTypeName`"
        },
        "rootValueType": {
          "description": "Use this configuration to set a custom type for the `rootValue`, and it will\neffect resolvers of all root types (Query, Mutation and Subscription), without the need to override it using generics each time.\nIf you wish to use an external type and import it from another file, you can use `add` plugin\nand add the required `import` statement, or you can use both `module#type` or `module#namespace#type` syntax.",
          "type": "string"
        },
        "mapperTypeSuffix": {
          "description": "Adds a suffix to the imported names to prevent name clashes.",
          "type": "string"
        },
        "mappers": {
          "description": "Replaces a GraphQL type usage with a custom type, allowing you to return custom object from\nyour resolvers.\nYou can use both `module#type` and `module#namespace#type` syntax.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "defaultMapper": {
          "description": "Allow you to set the default mapper when it's not being override by `mappers` or generics.\nYou can specify a type name, or specify a string in `module#type` or `module#namespace#type` format.\nThe default value of mappers it the TypeScript type generated by `typescript` package.",
          "type": "string"
        },
        "avoidOptionals": {
          "description": "This will cause the generator to avoid using optionals (`?`),\nso all field resolvers must be implemented in order to avoid compilation errors.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "showUnusedMappers": {
          "description": "Warns about unused mappers.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "enumValues": {
          "$ref": "#/definitions/EnumValuesMap",
          "description": "Overrides the default value of enum values declared in your GraphQL schema, supported\nin this plugin because of the need for integration with `typescript` package.\nSee documentation under `typescript` plugin for more information and examples."
        },
        "resolverTypeWrapperSignature": {
          "description": "Allow you to override `resolverTypeWrapper` definition.\nDefault value: \"Promise<T> | T\"",
          "type": "string"
        },
        "federation": {
          "description": "Supports Apollo Federation\nDefault value: \"false\"",
          "type": "boolean"
        },
        "enumPrefix": {
          "description": "Allow you to disable prefixing for generated enums, works in combination with `typesPrefix`.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "optionalResolveType": {
          "description": "Sets the `__resolveType` field as optional field.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "immutableTypes": {
          "description": "Generates immutable types by adding `readonly` to properties and uses `ReadonlyArray`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "namespacedImportName": {
          "description": "Prefixes all GraphQL related generated types with that value, as namespaces import.\nYou can use this featuere to allow seperation of plugins to different files.\nDefault value: \"''\"",
          "type": "string"
        },
        "resolverTypeSuffix": {
          "description": "Suffix we add to each generated type resolver.\nDefault value: \"Resolvers\"",
          "type": "string"
        },
        "allResolversTypeName": {
          "description": "The type name to use when exporting all resolvers signature as unified type.\nDefault value: \"Resolvers\"",
          "type": "string"
        },
        "internalResolversPrefix": {
          "type": "string",
          "description": "Defines the prefix value used for `__resolveType` and and `__isTypeOf` resolvers.\nIf you are using `mercurius-js`, please set this field to empty string for better compatiblity.\nDefault value: \"'__'\""
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserves underscores.\nDefault value: \"pascal-case#pascalCase\""
        },
        "typesPrefix": {
          "description": "Prefixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "typesSuffix": {
          "description": "Suffixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "skipTypename": {
          "description": "Does not add __typename to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        }
      }
    },
    "ApolloAngularRawPluginConfig": {
      "description": "This plugin generates Apollo services (`Query`, `Mutation` and `Subscription`) with TypeScript typings.\n\nIt will generate a strongly typed Angular service for every defined query, mutation or subscription. The generated Angular services are ready to inject and use within your Angular component.\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` - and thus shares a similar configuration.\n\nTo shed some more light regards this template, it's recommended to go through the this article: http://apollographql.com/docs/angular/basics/services.html , and to read the Code Generation with Apollo Angular: https://the-guild.dev/blog/apollo-angular-12",
      "type": "object",
      "properties": {
        "apolloAngularVersion": {
          "description": "Version of `apollo-angular` package\nDefault value: \"2\"",
          "type": "number"
        },
        "ngModule": {
          "description": "Allows to define `ngModule` as part of the plugin's config so it's globally available.",
          "type": "string"
        },
        "namedClient": {
          "description": "Defined the global value of `namedClient`.",
          "type": "string"
        },
        "serviceName": {
          "description": "Defined the global value of `serviceName`.",
          "type": "string"
        },
        "serviceProvidedInRoot": {
          "description": "Defined the global value of `serviceProvidedInRoot`.",
          "type": "boolean"
        },
        "serviceProvidedIn": {
          "description": "Define the Injector of the SDK class.",
          "type": "string"
        },
        "sdkClass": {
          "description": "Set to `true` in order to generate a SDK service class that uses all generated services.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "querySuffix": {
          "description": "Allows to define a custom suffix for query operations.\nDefault value: \"GQL\"",
          "type": "string"
        },
        "mutationSuffix": {
          "description": "Allows to define a custom suffix for mutation operations.\nDefault value: \"GQL\"",
          "type": "string"
        },
        "subscriptionSuffix": {
          "description": "Allows to define a custom suffix for Subscription operations.\nDefault value: \"GQL\"",
          "type": "string"
        },
        "apolloAngularPackage": {
          "description": "Allows to define a custom Apollo-Angular package to import types from.\nDefault value: \"'apollo-angular'\"",
          "type": "string"
        },
        "noGraphQLTag": {
          "description": "Deprecated. Changes the documentMode to `documentNode`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "gqlImport": {
          "description": "Customize from which module will `gql` be imported from.\nThis is useful if you want to use modules other than `graphql-tag`, e.g. `graphql.macro`.\nDefault value: \"graphql-tag#gql\"",
          "type": "string"
        },
        "documentNodeImport": {
          "description": "Customize from which module will `DocumentNode` be imported from.\nThis is useful if you want to use modules other than `graphql`, e.g. `@graphql-typed-document-node`.\nDefault value: \"graphql#DocumentNode\"",
          "type": "string"
        },
        "noExport": {
          "description": "Set this configuration to `true` if you wish to tell codegen to generate code with no `export` identifier.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariablePrefix": {
          "description": "Changes the GraphQL operations variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariableSuffix": {
          "description": "Changes the GraphQL operations variables suffix.\nDefault value: \"Document\"",
          "type": "string"
        },
        "fragmentVariablePrefix": {
          "description": "Changes the GraphQL fragments variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "fragmentVariableSuffix": {
          "description": "Changes the GraphQL fragments variables suffix.\nDefault value: \"FragmentDoc\"",
          "type": "string"
        },
        "documentMode": {
          "$ref": "#/definitions/DocumentMode",
          "description": "Declares how DocumentNode are created:\n- `graphQLTag`: `graphql-tag` or other modules (check `gqlImport`) will be used to generate document nodes. If this is used, document nodes are generated on client side i.e. the module used to generate this will be shipped to the client\n- `documentNode`: document nodes will be generated as objects when we generate the templates.\n- `documentNodeImportFragments`: Similar to documentNode except it imports external fragments instead of embedding them.\n- `external`: document nodes are imported from an external file. To be used with `importDocumentNodeExternallyFrom`\nDefault value: \"graphQLTag\""
        },
        "optimizeDocumentNode": {
          "description": "If you are using `documentNode: documentMode | documentNodeImportFragments`, you can set this to `true` to apply document optimizations for your GraphQL document.\nThis will remove all \"loc\" and \"description\" fields from the compiled document, and will remove all empty arrays (such as `directives`, `arguments` and `variableDefinitions`).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "importOperationTypesFrom": {
          "description": "This config is used internally by presets, but you can use it manually to tell codegen to prefix all base types that it's using.\nThis is useful if you wish to generate base types from `typescript-operations` plugin into a different file, and import it from there.\nDefault value: \"\"",
          "type": "string"
        },
        "importDocumentNodeExternallyFrom": {
          "description": "This config should be used if `documentMode` is `external`. This has 2 usage:\n- any string: This would be the path to import document nodes from. This can be used if we want to manually create the document nodes e.g. Use `graphql-tag` in a separate file and export the generated document\n- 'near-operation-file': This is a special mode that is intended to be used with `near-operation-file` preset to import document nodes from those files. If these files are `.graphql` files, we make use of webpack loader.\nDefault value: \"\"",
          "type": "string"
        },
        "pureMagicComment": {
          "description": "This config adds PURE magic comment to the static variables to enforce treeshaking for your bundler.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserves underscores.\nDefault value: \"pascal-case#pascalCase\""
        },
        "typesPrefix": {
          "description": "Prefixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "typesSuffix": {
          "description": "Suffixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "skipTypename": {
          "description": "Does not add __typename to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        }
      }
    },
    "UrqlRawPluginConfig": {
      "description": "This plugin generates `urql` (https://github.com/FormidableLabs/urql) components and HOC with TypeScript typings.",
      "type": "object",
      "properties": {
        "withComponent": {
          "description": "Customized the output by enabling/disabling the generated Component.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "withHooks": {
          "description": "Customized the output by enabling/disabling the generated React Hooks.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "urqlImportFrom": {
          "description": "You can specify module that exports components `Query`, `Mutation`, `Subscription` and HOCs\nThis is useful for further abstraction of some common tasks (eg. error handling).\nFilepath relative to generated file can be also specified.\nDefault value: \"urql\"",
          "type": "string"
        },
        "noGraphQLTag": {
          "description": "Deprecated. Changes the documentMode to `documentNode`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "gqlImport": {
          "description": "Customize from which module will `gql` be imported from.\nThis is useful if you want to use modules other than `graphql-tag`, e.g. `graphql.macro`.\nDefault value: \"graphql-tag#gql\"",
          "type": "string"
        },
        "documentNodeImport": {
          "description": "Customize from which module will `DocumentNode` be imported from.\nThis is useful if you want to use modules other than `graphql`, e.g. `@graphql-typed-document-node`.\nDefault value: \"graphql#DocumentNode\"",
          "type": "string"
        },
        "noExport": {
          "description": "Set this configuration to `true` if you wish to tell codegen to generate code with no `export` identifier.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariablePrefix": {
          "description": "Changes the GraphQL operations variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariableSuffix": {
          "description": "Changes the GraphQL operations variables suffix.\nDefault value: \"Document\"",
          "type": "string"
        },
        "fragmentVariablePrefix": {
          "description": "Changes the GraphQL fragments variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "fragmentVariableSuffix": {
          "description": "Changes the GraphQL fragments variables suffix.\nDefault value: \"FragmentDoc\"",
          "type": "string"
        },
        "documentMode": {
          "$ref": "#/definitions/DocumentMode",
          "description": "Declares how DocumentNode are created:\n- `graphQLTag`: `graphql-tag` or other modules (check `gqlImport`) will be used to generate document nodes. If this is used, document nodes are generated on client side i.e. the module used to generate this will be shipped to the client\n- `documentNode`: document nodes will be generated as objects when we generate the templates.\n- `documentNodeImportFragments`: Similar to documentNode except it imports external fragments instead of embedding them.\n- `external`: document nodes are imported from an external file. To be used with `importDocumentNodeExternallyFrom`\nDefault value: \"graphQLTag\""
        },
        "optimizeDocumentNode": {
          "description": "If you are using `documentNode: documentMode | documentNodeImportFragments`, you can set this to `true` to apply document optimizations for your GraphQL document.\nThis will remove all \"loc\" and \"description\" fields from the compiled document, and will remove all empty arrays (such as `directives`, `arguments` and `variableDefinitions`).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "importOperationTypesFrom": {
          "description": "This config is used internally by presets, but you can use it manually to tell codegen to prefix all base types that it's using.\nThis is useful if you wish to generate base types from `typescript-operations` plugin into a different file, and import it from there.\nDefault value: \"\"",
          "type": "string"
        },
        "importDocumentNodeExternallyFrom": {
          "description": "This config should be used if `documentMode` is `external`. This has 2 usage:\n- any string: This would be the path to import document nodes from. This can be used if we want to manually create the document nodes e.g. Use `graphql-tag` in a separate file and export the generated document\n- 'near-operation-file': This is a special mode that is intended to be used with `near-operation-file` preset to import document nodes from those files. If these files are `.graphql` files, we make use of webpack loader.\nDefault value: \"\"",
          "type": "string"
        },
        "pureMagicComment": {
          "description": "This config adds PURE magic comment to the static variables to enforce treeshaking for your bundler.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserves underscores.\nDefault value: \"pascal-case#pascalCase\""
        },
        "typesPrefix": {
          "description": "Prefixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "typesSuffix": {
          "description": "Suffixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "skipTypename": {
          "description": "Does not add __typename to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        }
      }
    },
    "ReactApolloRawPluginConfig": {
      "description": "This plugin generates React Apollo components and HOC with TypeScript typings.\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` - and thus shares a similar configuration.",
      "type": "object",
      "properties": {
        "withComponent": {
          "description": "Customize the output by enabling/disabling the generated Component (deprecated since Apollo-Client v3). For more details: https://www.apollographql.com/docs/react/api/react/components/\nDefault value: \"false\"",
          "type": "boolean"
        },
        "withHOC": {
          "description": "Customize the output by enabling/disabling the HOC (deprecated since Apollo-Client v3). For more details: https://www.apollographql.com/docs/react/api/react/hoc/\nDefault value: \"false\"",
          "type": "boolean"
        },
        "withHooks": {
          "description": "Customized the output by enabling/disabling the generated React Hooks. For more details: https://www.apollographql.com/docs/react/api/react/hooks/\nDefault value: \"true\"",
          "type": "boolean"
        },
        "withMutationFn": {
          "description": "Customized the output by enabling/disabling the generated mutation function signature.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "withRefetchFn": {
          "description": "Enable generating a function to be used with refetchQueries\nDefault value: \"false\"",
          "type": "boolean"
        },
        "apolloReactCommonImportFrom": {
          "description": "Customize the package where apollo-react common lib is loaded from.\nDefault value: \"\"\"",
          "type": "string"
        },
        "apolloReactComponentsImportFrom": {
          "description": "Customize the package where apollo-react component lib is loaded from.\nDefault value: \"\"\"",
          "type": "string"
        },
        "apolloReactHocImportFrom": {
          "description": "Customize the package where apollo-react HOC lib is loaded from.\nDefault value: \"\"\"",
          "type": "string"
        },
        "apolloReactHooksImportFrom": {
          "description": "Customize the package where apollo-react hooks lib is loaded from.\nDefault value: \"\"\"",
          "type": "string"
        },
        "componentSuffix": {
          "description": "You can specify a suffix that gets attached to the name of the generated component.\nDefault value: \"Component\"",
          "type": "string"
        },
        "reactApolloVersion": {
          "description": "Sets the version of react-apollo.\nIf you are using the old (deprecated) package of `react-apollo`, please set this configuration to `2`.\nIf you are using Apollo-Client v3, please set this to `3`.\nDefault value: \"3\"",
          "enum": [2, 3],
          "type": "number"
        },
        "withResultType": {
          "description": "Customized the output by enabling/disabling the generated result type.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "withMutationOptionsType": {
          "description": "Customized the output by enabling/disabling the generated mutation option type.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "addDocBlocks": {
          "description": "Allows you to enable/disable the generation of docblocks in generated code.\nSome IDE's (like VSCode) add extra inline information with docblocks, you can disable this feature if your preferred IDE does not.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "noGraphQLTag": {
          "description": "Deprecated. Changes the documentMode to `documentNode`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "gqlImport": {
          "description": "Customize from which module will `gql` be imported from.\nThis is useful if you want to use modules other than `graphql-tag`, e.g. `graphql.macro`.\nDefault value: \"graphql-tag#gql\"",
          "type": "string"
        },
        "documentNodeImport": {
          "description": "Customize from which module will `DocumentNode` be imported from.\nThis is useful if you want to use modules other than `graphql`, e.g. `@graphql-typed-document-node`.\nDefault value: \"graphql#DocumentNode\"",
          "type": "string"
        },
        "noExport": {
          "description": "Set this configuration to `true` if you wish to tell codegen to generate code with no `export` identifier.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariablePrefix": {
          "description": "Changes the GraphQL operations variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariableSuffix": {
          "description": "Changes the GraphQL operations variables suffix.\nDefault value: \"Document\"",
          "type": "string"
        },
        "fragmentVariablePrefix": {
          "description": "Changes the GraphQL fragments variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "fragmentVariableSuffix": {
          "description": "Changes the GraphQL fragments variables suffix.\nDefault value: \"FragmentDoc\"",
          "type": "string"
        },
        "documentMode": {
          "$ref": "#/definitions/DocumentMode",
          "description": "Declares how DocumentNode are created:\n- `graphQLTag`: `graphql-tag` or other modules (check `gqlImport`) will be used to generate document nodes. If this is used, document nodes are generated on client side i.e. the module used to generate this will be shipped to the client\n- `documentNode`: document nodes will be generated as objects when we generate the templates.\n- `documentNodeImportFragments`: Similar to documentNode except it imports external fragments instead of embedding them.\n- `external`: document nodes are imported from an external file. To be used with `importDocumentNodeExternallyFrom`\nDefault value: \"graphQLTag\""
        },
        "optimizeDocumentNode": {
          "description": "If you are using `documentNode: documentMode | documentNodeImportFragments`, you can set this to `true` to apply document optimizations for your GraphQL document.\nThis will remove all \"loc\" and \"description\" fields from the compiled document, and will remove all empty arrays (such as `directives`, `arguments` and `variableDefinitions`).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "importOperationTypesFrom": {
          "description": "This config is used internally by presets, but you can use it manually to tell codegen to prefix all base types that it's using.\nThis is useful if you wish to generate base types from `typescript-operations` plugin into a different file, and import it from there.\nDefault value: \"\"",
          "type": "string"
        },
        "importDocumentNodeExternallyFrom": {
          "description": "This config should be used if `documentMode` is `external`. This has 2 usage:\n- any string: This would be the path to import document nodes from. This can be used if we want to manually create the document nodes e.g. Use `graphql-tag` in a separate file and export the generated document\n- 'near-operation-file': This is a special mode that is intended to be used with `near-operation-file` preset to import document nodes from those files. If these files are `.graphql` files, we make use of webpack loader.\nDefault value: \"\"",
          "type": "string"
        },
        "pureMagicComment": {
          "description": "This config adds PURE magic comment to the static variables to enforce treeshaking for your bundler.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserves underscores.\nDefault value: \"pascal-case#pascalCase\""
        },
        "typesPrefix": {
          "description": "Prefixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "typesSuffix": {
          "description": "Suffixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "skipTypename": {
          "description": "Does not add __typename to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        }
      }
    },
    "VueApolloRawPluginConfig": {
      "description": "This plugin generates",
      "type": "object",
      "properties": {
        "withCompositionFunctions": {
          "description": "Customized the output by enabling/disabling the generated Vue composition functions.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "vueApolloComposableImportFrom": {
          "type": "string",
          "description": "\nDefault value: \"\""
        },
        "vueCompositionApiImportFrom": {
          "type": "string",
          "description": "\nDefault value: \"\""
        },
        "addDocBlocks": {
          "description": "Allows you to enable/disable the generation of docblocks in generated code.\nSome IDE's (like VSCode) add extra inline information with docblocks, you can disable this feature if your preferred IDE does not.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "noGraphQLTag": {
          "description": "Deprecated. Changes the documentMode to `documentNode`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "gqlImport": {
          "description": "Customize from which module will `gql` be imported from.\nThis is useful if you want to use modules other than `graphql-tag`, e.g. `graphql.macro`.\nDefault value: \"graphql-tag#gql\"",
          "type": "string"
        },
        "documentNodeImport": {
          "description": "Customize from which module will `DocumentNode` be imported from.\nThis is useful if you want to use modules other than `graphql`, e.g. `@graphql-typed-document-node`.\nDefault value: \"graphql#DocumentNode\"",
          "type": "string"
        },
        "noExport": {
          "description": "Set this configuration to `true` if you wish to tell codegen to generate code with no `export` identifier.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariablePrefix": {
          "description": "Changes the GraphQL operations variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariableSuffix": {
          "description": "Changes the GraphQL operations variables suffix.\nDefault value: \"Document\"",
          "type": "string"
        },
        "fragmentVariablePrefix": {
          "description": "Changes the GraphQL fragments variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "fragmentVariableSuffix": {
          "description": "Changes the GraphQL fragments variables suffix.\nDefault value: \"FragmentDoc\"",
          "type": "string"
        },
        "documentMode": {
          "$ref": "#/definitions/DocumentMode",
          "description": "Declares how DocumentNode are created:\n- `graphQLTag`: `graphql-tag` or other modules (check `gqlImport`) will be used to generate document nodes. If this is used, document nodes are generated on client side i.e. the module used to generate this will be shipped to the client\n- `documentNode`: document nodes will be generated as objects when we generate the templates.\n- `documentNodeImportFragments`: Similar to documentNode except it imports external fragments instead of embedding them.\n- `external`: document nodes are imported from an external file. To be used with `importDocumentNodeExternallyFrom`\nDefault value: \"graphQLTag\""
        },
        "optimizeDocumentNode": {
          "description": "If you are using `documentNode: documentMode | documentNodeImportFragments`, you can set this to `true` to apply document optimizations for your GraphQL document.\nThis will remove all \"loc\" and \"description\" fields from the compiled document, and will remove all empty arrays (such as `directives`, `arguments` and `variableDefinitions`).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "importOperationTypesFrom": {
          "description": "This config is used internally by presets, but you can use it manually to tell codegen to prefix all base types that it's using.\nThis is useful if you wish to generate base types from `typescript-operations` plugin into a different file, and import it from there.\nDefault value: \"\"",
          "type": "string"
        },
        "importDocumentNodeExternallyFrom": {
          "description": "This config should be used if `documentMode` is `external`. This has 2 usage:\n- any string: This would be the path to import document nodes from. This can be used if we want to manually create the document nodes e.g. Use `graphql-tag` in a separate file and export the generated document\n- 'near-operation-file': This is a special mode that is intended to be used with `near-operation-file` preset to import document nodes from those files. If these files are `.graphql` files, we make use of webpack loader.\nDefault value: \"\"",
          "type": "string"
        },
        "pureMagicComment": {
          "description": "This config adds PURE magic comment to the static variables to enforce treeshaking for your bundler.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserves underscores.\nDefault value: \"pascal-case#pascalCase\""
        },
        "typesPrefix": {
          "description": "Prefixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "typesSuffix": {
          "description": "Suffixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "skipTypename": {
          "description": "Does not add __typename to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        }
      }
    },
    "StencilApolloRawPluginConfig": {
      "description": "This plugin generates Stencil Apollo functional components typings\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` - and thus shares a similar configuration.",
      "type": "object",
      "properties": {
        "componentType": {
          "$ref": "#/definitions/StencilComponentType",
          "description": "Customize the output of the plugin - you can choose to generate a Component class or a function component.\nDefault value: \"functional\""
        },
        "noGraphQLTag": {
          "description": "Deprecated. Changes the documentMode to `documentNode`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "gqlImport": {
          "description": "Customize from which module will `gql` be imported from.\nThis is useful if you want to use modules other than `graphql-tag`, e.g. `graphql.macro`.\nDefault value: \"graphql-tag#gql\"",
          "type": "string"
        },
        "documentNodeImport": {
          "description": "Customize from which module will `DocumentNode` be imported from.\nThis is useful if you want to use modules other than `graphql`, e.g. `@graphql-typed-document-node`.\nDefault value: \"graphql#DocumentNode\"",
          "type": "string"
        },
        "noExport": {
          "description": "Set this configuration to `true` if you wish to tell codegen to generate code with no `export` identifier.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariablePrefix": {
          "description": "Changes the GraphQL operations variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariableSuffix": {
          "description": "Changes the GraphQL operations variables suffix.\nDefault value: \"Document\"",
          "type": "string"
        },
        "fragmentVariablePrefix": {
          "description": "Changes the GraphQL fragments variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "fragmentVariableSuffix": {
          "description": "Changes the GraphQL fragments variables suffix.\nDefault value: \"FragmentDoc\"",
          "type": "string"
        },
        "documentMode": {
          "$ref": "#/definitions/DocumentMode",
          "description": "Declares how DocumentNode are created:\n- `graphQLTag`: `graphql-tag` or other modules (check `gqlImport`) will be used to generate document nodes. If this is used, document nodes are generated on client side i.e. the module used to generate this will be shipped to the client\n- `documentNode`: document nodes will be generated as objects when we generate the templates.\n- `documentNodeImportFragments`: Similar to documentNode except it imports external fragments instead of embedding them.\n- `external`: document nodes are imported from an external file. To be used with `importDocumentNodeExternallyFrom`\nDefault value: \"graphQLTag\""
        },
        "optimizeDocumentNode": {
          "description": "If you are using `documentNode: documentMode | documentNodeImportFragments`, you can set this to `true` to apply document optimizations for your GraphQL document.\nThis will remove all \"loc\" and \"description\" fields from the compiled document, and will remove all empty arrays (such as `directives`, `arguments` and `variableDefinitions`).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "importOperationTypesFrom": {
          "description": "This config is used internally by presets, but you can use it manually to tell codegen to prefix all base types that it's using.\nThis is useful if you wish to generate base types from `typescript-operations` plugin into a different file, and import it from there.\nDefault value: \"\"",
          "type": "string"
        },
        "importDocumentNodeExternallyFrom": {
          "description": "This config should be used if `documentMode` is `external`. This has 2 usage:\n- any string: This would be the path to import document nodes from. This can be used if we want to manually create the document nodes e.g. Use `graphql-tag` in a separate file and export the generated document\n- 'near-operation-file': This is a special mode that is intended to be used with `near-operation-file` preset to import document nodes from those files. If these files are `.graphql` files, we make use of webpack loader.\nDefault value: \"\"",
          "type": "string"
        },
        "pureMagicComment": {
          "description": "This config adds PURE magic comment to the static variables to enforce treeshaking for your bundler.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserves underscores.\nDefault value: \"pascal-case#pascalCase\""
        },
        "typesPrefix": {
          "description": "Prefixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "typesSuffix": {
          "description": "Suffixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "skipTypename": {
          "description": "Does not add __typename to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        }
      }
    },
    "TypeScriptDocumentNodesRawPluginConfig": {
      "description": "This plugin generates TypeScript source (`.ts`) file from GraphQL files (`.graphql`).",
      "type": "object",
      "properties": {
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserves underscores.\nDefault value: \"pascal-case#pascalCase\""
        },
        "namePrefix": {
          "description": "Adds prefix to the name\nDefault value: \"\"",
          "type": "string"
        },
        "nameSuffix": {
          "description": "Adds suffix to the name\nDefault value: \"\"",
          "type": "string"
        },
        "fragmentPrefix": {
          "description": "Adds prefix to the fragment variable\nDefault value: \"\"",
          "type": "string"
        },
        "fragmentSuffix": {
          "description": "Adds suffix to the fragment variable\nDefault value: \"\"",
          "type": "string"
        },
        "noGraphQLTag": {
          "description": "Deprecated. Changes the documentMode to `documentNode`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "gqlImport": {
          "description": "Customize from which module will `gql` be imported from.\nThis is useful if you want to use modules other than `graphql-tag`, e.g. `graphql.macro`.\nDefault value: \"graphql-tag#gql\"",
          "type": "string"
        },
        "documentNodeImport": {
          "description": "Customize from which module will `DocumentNode` be imported from.\nThis is useful if you want to use modules other than `graphql`, e.g. `@graphql-typed-document-node`.\nDefault value: \"graphql#DocumentNode\"",
          "type": "string"
        },
        "noExport": {
          "description": "Set this configuration to `true` if you wish to tell codegen to generate code with no `export` identifier.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariablePrefix": {
          "description": "Changes the GraphQL operations variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariableSuffix": {
          "description": "Changes the GraphQL operations variables suffix.\nDefault value: \"Document\"",
          "type": "string"
        },
        "fragmentVariablePrefix": {
          "description": "Changes the GraphQL fragments variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "fragmentVariableSuffix": {
          "description": "Changes the GraphQL fragments variables suffix.\nDefault value: \"FragmentDoc\"",
          "type": "string"
        },
        "documentMode": {
          "$ref": "#/definitions/DocumentMode",
          "description": "Declares how DocumentNode are created:\n- `graphQLTag`: `graphql-tag` or other modules (check `gqlImport`) will be used to generate document nodes. If this is used, document nodes are generated on client side i.e. the module used to generate this will be shipped to the client\n- `documentNode`: document nodes will be generated as objects when we generate the templates.\n- `documentNodeImportFragments`: Similar to documentNode except it imports external fragments instead of embedding them.\n- `external`: document nodes are imported from an external file. To be used with `importDocumentNodeExternallyFrom`\nDefault value: \"graphQLTag\""
        },
        "optimizeDocumentNode": {
          "description": "If you are using `documentNode: documentMode | documentNodeImportFragments`, you can set this to `true` to apply document optimizations for your GraphQL document.\nThis will remove all \"loc\" and \"description\" fields from the compiled document, and will remove all empty arrays (such as `directives`, `arguments` and `variableDefinitions`).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "importOperationTypesFrom": {
          "description": "This config is used internally by presets, but you can use it manually to tell codegen to prefix all base types that it's using.\nThis is useful if you wish to generate base types from `typescript-operations` plugin into a different file, and import it from there.\nDefault value: \"\"",
          "type": "string"
        },
        "importDocumentNodeExternallyFrom": {
          "description": "This config should be used if `documentMode` is `external`. This has 2 usage:\n- any string: This would be the path to import document nodes from. This can be used if we want to manually create the document nodes e.g. Use `graphql-tag` in a separate file and export the generated document\n- 'near-operation-file': This is a special mode that is intended to be used with `near-operation-file` preset to import document nodes from those files. If these files are `.graphql` files, we make use of webpack loader.\nDefault value: \"\"",
          "type": "string"
        },
        "pureMagicComment": {
          "description": "This config adds PURE magic comment to the static variables to enforce treeshaking for your bundler.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "typesPrefix": {
          "description": "Prefixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "typesSuffix": {
          "description": "Suffixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "skipTypename": {
          "description": "Does not add __typename to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        }
      }
    },
    "JavaApolloAndroidPluginConfig": {
      "description": "This plugin and presets creates generated mappers and parsers for a complete type-safe GraphQL requests, for developers that uses Apollo Android runtime.",
      "type": "object",
      "properties": {
        "package": {
          "description": "Customize the Java package name for the generated operations. The default package name will be generated according to the output file path.",
          "type": "string"
        },
        "typePackage": {
          "description": "Customize the Java package name for the types generated based on input types.",
          "type": "string"
        },
        "fragmentPackage": {
          "description": "Customize the Java package name for the fragments generated classes.",
          "type": "string"
        },
        "fileType": {
          "$ref": "#/definitions/FileType"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserves underscores.\nDefault value: \"pascal-case#pascalCase\""
        },
        "typesPrefix": {
          "description": "Prefixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "typesSuffix": {
          "description": "Suffixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "skipTypename": {
          "description": "Does not add __typename to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        }
      }
    },
    "JavaResolversPluginRawConfig": {
      "type": "object",
      "properties": {
        "package": {
          "description": "Customize the Java package name. The default package name will be generated according to the output file path.",
          "type": "string"
        },
        "mappers": {
          "description": "Allow you to replace specific GraphQL types with your custom model classes. This is useful when you want to make sure your resolvers returns the correct class.\nThe default value is the values set by `defaultMapper` configuration.\nYou can use a direct path to the package, or use `package#class` syntax to have it imported.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "defaultMapper": {
          "description": "Sets the default mapper value in case it's not specified by `mappers`.\nYou can use a direct path to the package, or use `package#class` syntax to have it imported.\nThe default mapper is Java's `Object`.\nDefault value: \"Object\"",
          "type": "string"
        },
        "className": {
          "description": "Allow you to customize the parent class name.\nDefault value: \"Resolvers\"",
          "type": "string"
        },
        "listType": {
          "description": "Allow you to customize the list type.\nDefault value: \"Iterable\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserves underscores.\nDefault value: \"pascal-case#pascalCase\""
        },
        "typesPrefix": {
          "description": "Prefixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "typesSuffix": {
          "description": "Suffixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "skipTypename": {
          "description": "Does not add __typename to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        }
      }
    },
    "KotlinResolversPluginRawConfig": {
      "type": "object",
      "properties": {
        "package": {
          "description": "Customize the Java package name. The default package name will be generated according to the output file path.",
          "type": "string"
        },
        "enumValues": {
          "$ref": "#/definitions/EnumValuesMap",
          "description": "Overrides the default value of enum values declared in your GraphQL schema."
        },
        "listType": {
          "description": "Allow you to customize the list type\nDefault value: \"Iterable\"",
          "type": "string"
        },
        "withTypes": {
          "description": "Allow you to enable generation for the types\nDefault value: \"false\"",
          "type": "boolean"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserves underscores.\nDefault value: \"pascal-case#pascalCase\""
        },
        "typesPrefix": {
          "description": "Prefixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "typesSuffix": {
          "description": "Suffixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "skipTypename": {
          "description": "Does not add __typename to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        }
      }
    },
    "FlowPluginConfig": {
      "description": "This plugin generates Flow types based on your `GraphQLSchema`.\n\nIt generates types for your entire schema: types, input types, enum, interface, scalar and union.",
      "type": "object",
      "properties": {
        "useFlowExactObjects": {
          "description": "Generates Flow types as Exact types.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "useFlowReadOnlyTypes": {
          "description": "Generates read-only Flow types\nDefault value: \"false\"",
          "type": "boolean"
        },
        "addUnderscoreToArgsType": {
          "description": "Adds `_` to generated `Args` types in order to avoid duplicate identifiers.",
          "type": "boolean"
        },
        "enumValues": {
          "$ref": "#/definitions/EnumValuesMap",
          "description": "Overrides the default value of enum values declared in your GraphQL schema.\nYou can also map the entire enum to an external type by providing a string that of `module#type`."
        },
        "declarationKind": {
          "description": "Overrides the default output for various GraphQL elements.",
          "anyOf": [
            {
              "$ref": "#/definitions/DeclarationKindConfig"
            },
            {
              "enum": ["abstract class", "class", "interface", "type"],
              "type": "string"
            }
          ]
        },
        "enumPrefix": {
          "description": "Allow you to disable prefixing for generated enums, works in combination with `typesPrefix`.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "fieldWrapperValue": {
          "description": "Allow you to add wrapper for field type, use T as the generic value. Make sure to set `wrapFieldDefinitions` to `true` in order to make this flag work.\nDefault value: \"T\"",
          "type": "string"
        },
        "wrapFieldDefinitions": {
          "description": "Set the to `true` in order to wrap field definitions with `FieldWrapper`.\nThis is useful to allow return types such as Promises and functions.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "onlyOperationTypes": {
          "description": "This will cause the generator to emit types for operations only (basically only enums and scalars)\nDefault value: \"false\"",
          "type": "boolean"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserves underscores.\nDefault value: \"pascal-case#pascalCase\""
        },
        "typesPrefix": {
          "description": "Prefixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "typesSuffix": {
          "description": "Suffixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "skipTypename": {
          "description": "Does not add __typename to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        }
      }
    },
    "RawFlowResolversConfig": {
      "description": "This plugin generates resolvers signature based on your `GraphQLSchema`.\n\nIt generates types for your entire schema: types, input types, enum, interface, scalar and union.\n\nThis plugin requires you to use `@graphql-codegen/flow` as well, because it depends on it's types.",
      "type": "object",
      "properties": {
        "addUnderscoreToArgsType": {
          "description": "Adds `_` to generated `Args` types in order to avoid duplicate identifiers.",
          "type": "boolean"
        },
        "contextType": {
          "description": "Use this configuration to set a custom type for your `context`, and it will\neffect all the resolvers, without the need to override it using generics each time.\nIf you wish to use an external type and import it from another file, you can use `add` plugin\nand add the required `import` statement, or you can use a `module#type` syntax.",
          "type": "string"
        },
        "fieldContextTypes": {
          "$ref": "#/definitions/Array_1",
          "description": "Use this to set a custom type for a specific field `context`.\nIt will only affect the targeted resolvers.\nYou can either use `Field.Path#ContextTypeName` or `Field.Path#ExternalFileName#ContextTypeName`"
        },
        "rootValueType": {
          "description": "Use this configuration to set a custom type for the `rootValue`, and it will\neffect resolvers of all root types (Query, Mutation and Subscription), without the need to override it using generics each time.\nIf you wish to use an external type and import it from another file, you can use `add` plugin\nand add the required `import` statement, or you can use both `module#type` or `module#namespace#type` syntax.",
          "type": "string"
        },
        "mapperTypeSuffix": {
          "description": "Adds a suffix to the imported names to prevent name clashes.",
          "type": "string"
        },
        "mappers": {
          "description": "Replaces a GraphQL type usage with a custom type, allowing you to return custom object from\nyour resolvers.\nYou can use both `module#type` and `module#namespace#type` syntax.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "defaultMapper": {
          "description": "Allow you to set the default mapper when it's not being override by `mappers` or generics.\nYou can specify a type name, or specify a string in `module#type` or `module#namespace#type` format.\nThe default value of mappers it the TypeScript type generated by `typescript` package.",
          "type": "string"
        },
        "avoidOptionals": {
          "description": "This will cause the generator to avoid using optionals (`?`),\nso all field resolvers must be implemented in order to avoid compilation errors.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "showUnusedMappers": {
          "description": "Warns about unused mappers.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "enumValues": {
          "$ref": "#/definitions/EnumValuesMap",
          "description": "Overrides the default value of enum values declared in your GraphQL schema, supported\nin this plugin because of the need for integration with `typescript` package.\nSee documentation under `typescript` plugin for more information and examples."
        },
        "resolverTypeWrapperSignature": {
          "description": "Allow you to override `resolverTypeWrapper` definition.\nDefault value: \"Promise<T> | T\"",
          "type": "string"
        },
        "federation": {
          "description": "Supports Apollo Federation\nDefault value: \"false\"",
          "type": "boolean"
        },
        "enumPrefix": {
          "description": "Allow you to disable prefixing for generated enums, works in combination with `typesPrefix`.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "optionalResolveType": {
          "description": "Sets the `__resolveType` field as optional field.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "immutableTypes": {
          "description": "Generates immutable types by adding `readonly` to properties and uses `ReadonlyArray`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "namespacedImportName": {
          "description": "Prefixes all GraphQL related generated types with that value, as namespaces import.\nYou can use this featuere to allow seperation of plugins to different files.\nDefault value: \"''\"",
          "type": "string"
        },
        "resolverTypeSuffix": {
          "description": "Suffix we add to each generated type resolver.\nDefault value: \"Resolvers\"",
          "type": "string"
        },
        "allResolversTypeName": {
          "description": "The type name to use when exporting all resolvers signature as unified type.\nDefault value: \"Resolvers\"",
          "type": "string"
        },
        "internalResolversPrefix": {
          "type": "string",
          "description": "Defines the prefix value used for `__resolveType` and and `__isTypeOf` resolvers.\nIf you are using `mercurius-js`, please set this field to empty string for better compatiblity.\nDefault value: \"'__'\""
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserves underscores.\nDefault value: \"pascal-case#pascalCase\""
        },
        "typesPrefix": {
          "description": "Prefixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "typesSuffix": {
          "description": "Suffixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "skipTypename": {
          "description": "Does not add __typename to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        }
      }
    },
    "FlowDocumentsPluginConfig": {
      "description": "This plugin generates Flow types based on your `GraphQLSchema` and your GraphQL operations and fragments.\n\nIt generates types for your GraphQL documents: Query, Mutation, Subscription and Fragment.\n\nThis plugin requires you to use `@graphql-codegen/flow` as well, because it depends on it's types.",
      "type": "object",
      "properties": {
        "useFlowExactObjects": {
          "description": "Generates Flow types as Exact types.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "useFlowReadOnlyTypes": {
          "description": "Generates read-only Flow types\nDefault value: \"false\"",
          "type": "boolean"
        },
        "flattenGeneratedTypes": {
          "description": "Flatten fragment spread and inline fragments into a simple selection set before generating.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "preResolveTypes": {
          "description": "Avoid using `Pick` and resolve the actual primitive type of all selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "skipTypeNameForRoot": {
          "description": "Avoid adding `__typename` for root types. This is ignored when a selection explictly specifies `__typename`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "globalNamespace": {
          "description": "Puts all generated code under `global` namespace. Useful for Stencil integration.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "exportFragmentSpreadSubTypes": {
          "description": "If set to true, it will export the sub-types created in order to make it easier to access fields declared under fragment spread.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "addUnderscoreToArgsType": {
          "description": "Adds `_` to generated `Args` types in order to avoid duplicate identifiers.",
          "type": "boolean"
        },
        "enumValues": {
          "$ref": "#/definitions/EnumValuesMap",
          "description": "Overrides the default value of enum values declared in your GraphQL schema.\nYou can also map the entire enum to an external type by providing a string that of `module#type`."
        },
        "declarationKind": {
          "description": "Overrides the default output for various GraphQL elements.",
          "anyOf": [
            {
              "$ref": "#/definitions/DeclarationKindConfig"
            },
            {
              "enum": ["abstract class", "class", "interface", "type"],
              "type": "string"
            }
          ]
        },
        "enumPrefix": {
          "description": "Allow you to disable prefixing for generated enums, works in combination with `typesPrefix`.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "fieldWrapperValue": {
          "description": "Allow you to add wrapper for field type, use T as the generic value. Make sure to set `wrapFieldDefinitions` to `true` in order to make this flag work.\nDefault value: \"T\"",
          "type": "string"
        },
        "wrapFieldDefinitions": {
          "description": "Set the to `true` in order to wrap field definitions with `FieldWrapper`.\nThis is useful to allow return types such as Promises and functions.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "onlyOperationTypes": {
          "description": "This will cause the generator to emit types for operations only (basically only enums and scalars)\nDefault value: \"false\"",
          "type": "boolean"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserves underscores.\nDefault value: \"pascal-case#pascalCase\""
        },
        "typesPrefix": {
          "description": "Prefixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "typesSuffix": {
          "description": "Suffixes all the generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "skipTypename": {
          "description": "Does not add __typename to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        }
      }
    },
    "IntrospectionPluginConfig": {
      "description": "This plugin generates a GraphQL introspection file based on your GraphQL schema.",
      "type": "object",
      "properties": {
        "minify": {
          "description": "Set to `true` in order to minify the JSON output.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "descriptions": {
          "description": "Whether to include descriptions in the introspection result.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "specifiedByUrl": {
          "description": "Whether to include `specifiedByUrl` in the introspection result.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "directiveIsRepeatable": {
          "description": "Whether to include `isRepeatable` flag on directives.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "schemaDescription": {
          "description": "Whether to include `description` field on schema.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "federation": {
          "type": "boolean"
        }
      }
    },
    "FragmentMatcherConfig": {
      "description": "This plugin generates an introspection file but only with Interfaces and Unions, based on your GraphQLSchema.\n\nIf you are using `apollo-client` and your schema contains `interface` or `union` declaration, it's recommended to use Apollo's Fragment Matcher and the result generated by the plugin.\n\nYou can read more about it in `apollo-client` documentation: https://www.apollographql.com/docs/react/data/fragments/#fragments-on-unions-and-interfaces.\n\nFragment Matcher plugin accepts a TypeScript / JavaScript or a JSON file as an output _(`.ts, .tsx, .js, .jsx, .json`)_.\n\nBoth in TypeScript and JavaScript a default export is being used.\n\n> The output is based on the output you choose for the output file name.",
      "type": "object",
      "properties": {
        "module": {
          "description": "Compatible only with JSON extension, allow you to choose the export type, either `module.exports` or `export default`.  Allowed values are: `commonjs`,  `es2015`.\nDefault value: \"es2015\"",
          "enum": ["commonjs", "es2015"],
          "type": "string"
        },
        "apolloClientVersion": {
          "description": "Compatible only with TS/TSX/JS/JSX extensions, allow you to generate output based on your Apollo-Client version. Valid values are: `2`, `3`.\nDefault value: \"3\"",
          "enum": [2, 3],
          "type": "number"
        },
        "useExplicitTyping": {
          "description": "Create an explicit type based on your schema. This can help IDEs autofill your fragment matcher. This is mostly useful if you do more with your fragment matcher than just pass it to an Apollo-Client.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "federation": {
          "type": "boolean"
        }
      }
    },
    "ModulesConfig": {
      "type": "object",
      "properties": {
        "baseTypesPath": {
          "type": "string",
          "description": "Required, should point to the base schema types file.\nThe key of the output is used a the base path for this file."
        },
        "importBaseTypesFrom": {
          "type": "string",
          "description": "Overrides the package import for the base types. Use this if you are within a monorepo and you wish\nto import the base types directly from a different package, and not from a relative path."
        },
        "cwd": {
          "type": "string",
          "description": "Optional, override the `cwd` of the execution. We are using `cwd` to figure out the imports between files. Use this if your execuion path is not your project root directory.\nDefault value: \"process.cwd()\""
        },
        "importTypesNamespace": {
          "type": "string",
          "description": "Optional, override the name of the import namespace used to import from the `baseTypesPath` file.\nDefault value: \"Types\""
        },
        "filename": {
          "type": "string",
          "description": "Required, sets the file name for the generated files."
        },
        "encapsulateModuleTypes": {
          "type": "string",
          "description": "Configure how to encapsulate the module types, to avoid confusion.\n\n`namespace` (default): will wrap all types in a TypeScript namespace, using the module name.\n`prefix`: will prefix all types from a specific module with the module name.\n`none`: will skip encapsulation, and generate type as-is.\nDefault value: \"namespace\""
        }
      }
    },
    "NearOperationFileConfig": {
      "type": "object",
      "properties": {
        "baseTypesPath": {
          "description": "Required, should point to the base schema types file.\nThe key of the output is used a the base path for this file.\n\nIf you wish to use an NPM package or a local workspace package, make sure to prefix the package name with `~`.",
          "type": "string"
        },
        "importAllFragmentsFrom": {
          "description": "Overrides all external fragments import types by using a specific file path or a package name.\n\nIf you wish to use an NPM package or a local workspace package, make sure to prefix the package name with `~`.",
          "type": ["string", "object"]
        },
        "extension": {
          "description": "Optional, sets the extension for the generated files. Use this to override the extension if you are using plugins that requires a different type of extensions (such as `typescript-react-apollo`)\nDefault value: \".generates.ts\"",
          "type": "string"
        },
        "cwd": {
          "description": "Optional, override the `cwd` of the execution. We are using `cwd` to figure out the imports between files. Use this if your execuion path is not your project root directory.\nDefault value: \"process.cwd()\"",
          "type": "string"
        },
        "folder": {
          "description": "Optional, defines a folder, (Relative to the source files) where the generated files will be created.\nDefault value: \"''\"",
          "type": "string"
        },
        "importTypesNamespace": {
          "description": "Optional, override the name of the import namespace used to import from the `baseTypesPath` file.\nDefault value: \"Types\"",
          "type": "string"
        }
      }
    },
    "ImportTypesConfig": {
      "type": "object",
      "properties": {
        "typesPath": {
          "description": "Required, should point to the base schema types file.\nThe key of the output is used a the base path for this file.",
          "type": "string"
        },
        "importTypesNamespace": {
          "description": "Optional, override the name of the import namespace used to import from the `baseTypesPath` file.\nDefault value: \"Types\"",
          "type": "string"
        }
      }
    },
    "Types.InstanceOrArray": {
      "anyOf": [
        {
          "$ref": "#/definitions/Types.SchemaWithLoader"
        },
        {
          "$ref": "#/definitions/Types.SchemaFromCodeFile"
        },
        {
          "$ref": "#/definitions/Types.UrlSchemaWithOptions"
        },
        {
          "$ref": "#/definitions/Types.LocalSchemaPathWithOptions"
        },
        {
          "type": "array",
          "items": {
            "anyOf": [
              {
                "$ref": "#/definitions/Types.SchemaWithLoader"
              },
              {
                "$ref": "#/definitions/Types.SchemaFromCodeFile"
              },
              {
                "$ref": "#/definitions/Types.UrlSchemaWithOptions"
              },
              {
                "$ref": "#/definitions/Types.LocalSchemaPathWithOptions"
              },
              {
                "type": "string"
              }
            ]
          }
        },
        {
          "type": "string"
        }
      ]
    },
    "Types.SchemaWithLoader": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/Types.SchemaWithLoaderOptions"
      }
    },
    "Types.SchemaWithLoaderOptions": {
      "additionalProperties": false,
      "description": "Loads schema using a pointer, with a custom loader (code file).",
      "type": "object",
      "properties": {
        "loader": {
          "description": "Specify a path to a custom code file (local or module) that will handle the schema loading.",
          "type": "string"
        }
      }
    },
    "Types.SchemaFromCodeFile": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/Types.SchemaFromCodeFileOptions"
      }
    },
    "Types.SchemaFromCodeFileOptions": {
      "additionalProperties": false,
      "description": "Loads schema using a pointer, without using `require` while looking for schemas in code files.",
      "type": "object",
      "properties": {
        "noRequire": {
          "description": "Set this to `true` in order to tell codegen not to try to `require` files in order to find schema/docs",
          "type": "boolean"
        },
        "noPluck": {
          "description": "Set this to `true` in order to tell codegen not to try to extract GraphQL AST strings schema/docs",
          "type": "boolean"
        },
        "assumeValid": {
          "description": "Set this to `true` in order to tell codegen to skip documents validation.",
          "type": "boolean"
        }
      }
    },
    "Types.UrlSchemaWithOptions": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/Types.UrlSchemaOptions"
      }
    },
    "Types.UrlSchemaOptions": {
      "additionalProperties": false,
      "description": "Loads a schema from remote endpoint, with custom http options.",
      "type": "object",
      "properties": {
        "headers": {
          "description": "HTTP headers you wish to add to the HTTP request sent by codegen to fetch your GraphQL remote schema.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "customFetch": {
          "description": "Specify a Node module name, or a custom file, to be used instead of standard `fetch`",
          "type": "string"
        },
        "method": {
          "description": "HTTP Method to use, either POST (default) or GET.",
          "type": "string"
        }
      }
    },
    "Types.LocalSchemaPathWithOptions": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/Types.LocalSchemaPathOptions"
      }
    },
    "Types.LocalSchemaPathOptions": {
      "additionalProperties": false,
      "description": "Loads a schema a local file or files, with customized options for parsing/loading.",
      "type": "object",
      "properties": {
        "skipGraphQLImport": {
          "description": "Skips checks for graphql-import syntax and loads the file as-is, without imports support.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "commentDescriptions": {
          "description": "Converts all GraphQL comments (`#` sign) to descriptions during the parse phase, to make it available\nfor plugins later.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "assumeValidSDL": {
          "description": "Set to true to assume the SDL is valid.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "noLocation": {
          "description": "By default, the parser creates AST nodes that know the location\nin the source that they correspond to. This configuration flag\ndisables that behavior for performance or testing.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "allowLegacySDLEmptyFields": {
          "description": "If enabled, the parser will parse empty fields sets in the Schema\nDefinition Language. Otherwise, the parser will follow the current\nspecification.\n\nThis option is provided to ease adoption of the final SDL specification\nand will be removed in v16.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "allowLegacySDLImplementsInterfaces": {
          "description": "If enabled, the parser will parse implemented interfaces with no `&`\ncharacter between each interface. Otherwise, the parser will follow the\ncurrent specification.\n\nThis option is provided to ease adoption of the final SDL specification\nand will be removed in v16.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "experimentalFragmentVariables": {
          "description": "EXPERIMENTAL:\n\nIf enabled, the parser will understand and parse variable definitions\ncontained in a fragment definition. They'll be represented in the\n`variableDefinitions` field of the FragmentDefinitionNode.\n\nThe syntax is identical to normal, query-defined variables. For example:\n\n   fragment A($var: Boolean = false) on T  {\n     ...\n   }\n\nNote: this feature is experimental and may change or be removed in the\nfuture.\nDefault value: \"false\"",
          "type": "boolean"
        }
      }
    },
    "Types.RequireExtension": {
      "anyOf": [
        {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        {
          "type": "string"
        }
      ]
    },
    "Types.InstanceOrArray_1": {
      "anyOf": [
        {
          "$ref": "#/definitions/Types.CustomDocumentLoader"
        },
        {
          "type": "array",
          "items": {
            "anyOf": [
              {
                "$ref": "#/definitions/Types.CustomDocumentLoader"
              },
              {
                "type": "string"
              }
            ]
          }
        },
        {
          "type": "string"
        }
      ]
    },
    "Types.CustomDocumentLoader": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/Types.CustomDocumentLoaderOptions"
      }
    },
    "Types.CustomDocumentLoaderOptions": {
      "additionalProperties": false,
      "description": "Specify a path to a custom loader for your GraphQL documents.",
      "type": "object",
      "properties": {
        "loader": {
          "description": "Specify a path to a custom code file (local or module) that will handle the documents loading.",
          "type": "string"
        }
      }
    },
    "__type": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/T"
      }
    },
    "T": {
      "type": "object"
    },
    "Types.PluginConfig": {
      "$ref": "#/definitions/__type"
    },
    "Types.ConfiguredOutput": {
      "additionalProperties": false,
      "type": "object",
      "properties": {
        "plugins": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/GeneratedPluginsMap"
          },
          "description": "List of plugins to apply to this current output file.\n\nYou can either specify plugins from the community using the NPM package name (after you installed it in your project), or you can use a path to a local file for custom plugins.\n\nYou can find a list of available plugins here: https://graphql-code-generator.com/docs/plugins/index\nNeed a custom plugin? read this: https://graphql-code-generator.com/docs/custom-codegen/index"
        },
        "preset": {
          "description": "If your setup uses Preset to have a more dynamic setup and output, set the name of your preset here.\n\nPresets are a way to have more than one file output, for example: https://graphql-code-generator.com/docs/presets/near-operation-file\n\nYou can either specify a preset from the community using the NPM package name (after you installed it in your project), or you can use a path to a local file for a custom preset.\n\nList of available presets: https://graphql-code-generator.com/docs/presets/presets-index",
          "anyOf": [
            {
              "type": "object",
              "properties": {
                "buildGeneratesSection": {
                  "type": "object"
                }
              }
            },
            {
              "type": "string"
            }
          ]
        },
        "presetConfig": {
          "description": "If your setup uses Preset to have a more dynamic setup and output, set the configuration object of your preset here.\n\nList of available presets: https://graphql-code-generator.com/docs/presets/presets-index",
          "type": "object",
          "additionalProperties": {}
        },
        "overwrite": {
          "description": "A flag to overwrite files if they already exist when generating code (`true` by default).\n\nFor more details: https://graphql-code-generator.com/docs/getting-started/codegen-config",
          "type": "boolean"
        },
        "documents": {
          "$ref": "#/definitions/Types.InstanceOrArray_1",
          "description": "A pointer(s) to your GraphQL documents: query, mutation, subscription and fragment. These documents will be loaded into for all your output files.\nYou can use one of the following:\n\n- Path to a local `.graphql` file\n- Path to a code file (for example: `.js` or `.tsx`) containing GraphQL operation strings.\n- Glob expression pointing to multiple `.graphql` files\n- Glob expression pointing to multiple code files\n- Inline string containing GraphQL SDL operation definition\n\nYou can specify either a single file, or multiple.\n\nFor more details: https://graphql-code-generator.com/docs/getting-started/documents-field"
        },
        "schema": {
          "$ref": "#/definitions/Types.InstanceOrArray",
          "description": "A pointer(s) to your GraphQL schema. This schema will be available only for this specific `generates` record.\nYou can use one of the following:\n\n- URL pointing to a GraphQL endpoint\n- Path to a local `.json` file\n- Path to a local `.graphql` file\n- Glob expression pointing to multiple `.graphql` files\n- Path to a local code file (for example: `.js`) that exports `GraphQLSchema` object\n- Inline string containing GraphQL SDL schema definition\n\nYou can specify either a single schema, or multiple, and GraphQL Code Generator will merge the schemas into a single schema.\n\nFor more details: https://graphql-code-generator.com/docs/getting-started/schema-field"
        },
        "config": {
          "additionalProperties": true
        },
        "hooks": {
          "$ref": "#/definitions/Partial",
          "description": "Specifies scripts to run when events are happening in the codegen core.\nHooks defined on that level will effect only the current output files.\n\nFor more details: https://graphql-code-generator.com/docs/getting-started/lifecycle-hooks"
        }
      },
      "allOf": [
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "typescript-react-query"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/ReactQueryRawPluginConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "typescript-apollo-client-helpers"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/ApolloClientHelpersConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "add"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/AddPluginConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "time"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/TimePluginConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "typescript"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/TypeScriptPluginConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "typescript-operations"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/TypeScriptDocumentsPluginConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "c-sharp"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/CSharpResolversPluginRawConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "c-sharp-operations"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/CSharpOperationsRawPluginConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "schema-ast"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/SchemaASTConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "typescript-type-graphql"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/TypeGraphQLPluginConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "typescript-graphql-files-modules"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/TypeScriptFilesModulesPluginConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "named-operations-object"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/NamedOperationsObjectPluginConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "typescript-graphql-request"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/RawGraphQLRequestPluginConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "typescript-compatibility"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/CompatibilityPluginRawConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "typescript-mongodb"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/TypeScriptMongoPluginConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "typescript-resolvers"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/TypeScriptResolversPluginConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "typescript-apollo-angular"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/ApolloAngularRawPluginConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "typescript-urql"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/UrqlRawPluginConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "typescript-react-apollo"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/ReactApolloRawPluginConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "typescript-vue-apollo"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/VueApolloRawPluginConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "typescript-stencil-apollo"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/StencilApolloRawPluginConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "typescript-document-nodes"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/TypeScriptDocumentNodesRawPluginConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "java-apollo-android"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/JavaApolloAndroidPluginConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "java-resolvers"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/JavaResolversPluginRawConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "java"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/JavaResolversPluginRawConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "kotlin"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/KotlinResolversPluginRawConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "flow"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/FlowPluginConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "flow-resolvers"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/RawFlowResolversConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "flow-operations"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/FlowDocumentsPluginConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "introspection"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/IntrospectionPluginConfig"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "plugins": {
                "contains": {
                  "type": "string",
                  "const": "fragment-matcher"
                }
              }
            }
          },
          "then": {
            "properties": {
              "config": {
                "$ref": "#/definitions/FragmentMatcherConfig"
              }
            }
          }
        }
      ]
    },
    "__type_1": {
      "type": "object",
      "properties": {
        "afterStart": {
          "$ref": "#/definitions/T_1",
          "description": "Triggered with no arguments when the codegen starts (after the `codegen.yml` has beed parsed).\n\nSpecify a shell command to run."
        },
        "beforeDone": {
          "$ref": "#/definitions/T_1",
          "description": "Triggered with no arguments, right before the codegen closes, or when watch mode is stopped.\n\nSpecify a shell command to run."
        },
        "onWatchTriggered": {
          "$ref": "#/definitions/T_1",
          "description": "Triggered every time a file changes when using watch mode.\nTriggered with two arguments: the type of the event (for example, `changed`) and the path of the file."
        },
        "onError": {
          "$ref": "#/definitions/T_1",
          "description": "Triggered in case of a general error in the codegen. The argument is a string containing the error."
        },
        "afterOneFileWrite": {
          "$ref": "#/definitions/T_1",
          "description": "Triggered after a file is written to the file-system. Executed with the path for the file.\nIf the content of the file hasn't changed since last execution - this hooks won't be triggered.\n\n> This is a very useful hook, you can use it for integration with Prettier or other linters."
        },
        "afterAllFileWrite": {
          "$ref": "#/definitions/T_1",
          "description": "Executed after writing all the files to the file-system.\nTriggered with multiple arguments - paths for all files."
        },
        "beforeOneFileWrite": {
          "$ref": "#/definitions/T_1",
          "description": "Triggered before a file is written to the file-system. Executed with the path for the file.\n\nIf the content of the file hasn't changed since last execution - this hooks won't be triggered."
        },
        "beforeAllFileWrite": {
          "$ref": "#/definitions/T_1",
          "description": "Executed after the codegen has done creating the output and before writing the files to the file-system.\n\nTriggered with multiple arguments - paths for all relevant files.\n\n> Not all the files will be actually written to the file-system, because this is triggered before checking if the file has changed since last execution."
        }
      }
    },
    "T_1": {
      "anyOf": [
        {
          "type": "array",
          "items": {
            "type": ["string", "object"]
          }
        },
        {
          "type": ["string", "object"]
        }
      ]
    },
    "Partial": {
      "$ref": "#/definitions/__type_1"
    },
    "__type_2": {
      "type": "object"
    },
    "Types.PackageLoaderFn": {
      "$ref": "#/definitions/__type_2"
    },
    "Array": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "name": {
            "description": "the name of the NPM package name you wish to look for",
            "type": "string"
          },
          "identifier": {
            "description": "the tag identifier name you wish to look for",
            "type": "string"
          }
        }
      }
    },
    "__type_3": {
      "type": "object",
      "properties": {
        "afterStart": {
          "$ref": "#/definitions/T_1",
          "description": "Triggered with no arguments when the codegen starts (after the `codegen.yml` has beed parsed).\n\nSpecify a shell command to run."
        },
        "beforeDone": {
          "$ref": "#/definitions/T_1",
          "description": "Triggered with no arguments, right before the codegen closes, or when watch mode is stopped.\n\nSpecify a shell command to run."
        },
        "onWatchTriggered": {
          "$ref": "#/definitions/T_1",
          "description": "Triggered every time a file changes when using watch mode.\nTriggered with two arguments: the type of the event (for example, `changed`) and the path of the file."
        },
        "onError": {
          "$ref": "#/definitions/T_1",
          "description": "Triggered in case of a general error in the codegen. The argument is a string containing the error."
        },
        "afterOneFileWrite": {
          "$ref": "#/definitions/T_1",
          "description": "Triggered after a file is written to the file-system. Executed with the path for the file.\nIf the content of the file hasn't changed since last execution - this hooks won't be triggered.\n\n> This is a very useful hook, you can use it for integration with Prettier or other linters."
        },
        "afterAllFileWrite": {
          "$ref": "#/definitions/T_1",
          "description": "Executed after writing all the files to the file-system.\nTriggered with multiple arguments - paths for all files."
        },
        "beforeOneFileWrite": {
          "$ref": "#/definitions/T_1",
          "description": "Triggered before a file is written to the file-system. Executed with the path for the file.\n\nIf the content of the file hasn't changed since last execution - this hooks won't be triggered."
        },
        "beforeAllFileWrite": {
          "$ref": "#/definitions/T_1",
          "description": "Executed after the codegen has done creating the output and before writing the files to the file-system.\n\nTriggered with multiple arguments - paths for all relevant files.\n\n> Not all the files will be actually written to the file-system, because this is triggered before checking if the file has changed since last execution."
        }
      }
    },
    "Types.LifecycleHooksDefinition": {
      "$ref": "#/definitions/__type_3"
    },
    "__type_4": {
      "type": "object"
    },
    "Record": {
      "$ref": "#/definitions/__type_4"
    },
    "ScalarsMap": {
      "description": "Scalars map or a string, a map between the GraphQL scalar name and the identifier that should be used",
      "anyOf": [
        {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        {
          "type": "string"
        }
      ]
    },
    "NamingConvention": {
      "anyOf": [
        {
          "$ref": "#/definitions/NamingConventionMap"
        },
        {
          "type": ["string", "object"]
        }
      ]
    },
    "NamingConventionMap": {
      "additionalProperties": false,
      "type": "object",
      "properties": {
        "enumValues": {
          "type": ["string", "object"]
        },
        "typeNames": {
          "type": ["string", "object"]
        },
        "transformUnderscore": {
          "type": "boolean"
        }
      }
    },
    "FragmentDefinitionNode": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string",
          "enum": ["FragmentDefinition"]
        },
        "loc": {
          "$ref": "#/definitions/Location"
        },
        "name": {
          "$ref": "#/definitions/NameNode"
        },
        "variableDefinitions": {
          "$ref": "#/definitions/ReadonlyArray"
        },
        "typeCondition": {
          "$ref": "#/definitions/NamedTypeNode"
        },
        "directives": {
          "$ref": "#/definitions/ReadonlyArray_3"
        },
        "selectionSet": {
          "$ref": "#/definitions/SelectionSetNode"
        }
      }
    },
    "Location": {
      "description": "Contains a range of UTF-8 character offsets and token references that\nidentify the region of the source from which the AST derived.",
      "type": "object",
      "properties": {
        "start": {
          "description": "The character offset at which this Node begins.",
          "type": "number"
        },
        "end": {
          "description": "The character offset at which this Node ends.",
          "type": "number"
        },
        "startToken": {
          "$ref": "#/definitions/Token",
          "description": "The Token at which this Node begins."
        },
        "endToken": {
          "$ref": "#/definitions/Token",
          "description": "The Token at which this Node ends."
        },
        "source": {
          "$ref": "#/definitions/Source",
          "description": "The Source document the AST represents."
        }
      }
    },
    "Token": {
      "description": "Represents a range of characters represented by a lexical token\nwithin a Source.",
      "type": "object",
      "properties": {
        "kind": {
          "$ref": "#/definitions/TokenKindEnum",
          "description": "The kind of Token."
        },
        "start": {
          "description": "The character offset at which this Node begins.",
          "type": "number"
        },
        "end": {
          "description": "The character offset at which this Node ends.",
          "type": "number"
        },
        "line": {
          "description": "The 1-indexed line number on which this Token appears.",
          "type": "number"
        },
        "column": {
          "description": "The 1-indexed column number at which this Token begins.",
          "type": "number"
        },
        "value": {
          "description": "For non-punctuation tokens, represents the interpreted value of the token.",
          "type": "string"
        },
        "prev": {
          "$ref": "#/definitions/Token",
          "description": "Tokens exist as nodes in a double-linked-list amongst all tokens\nincluding ignored tokens. <SOF> is always the first node and <EOF>\nthe last."
        },
        "next": {
          "$ref": "#/definitions/Token"
        }
      }
    },
    "TokenKindEnum": {
      "description": "The enum type representing the token kinds values.",
      "enum": [
        "!",
        "$",
        "&",
        "(",
        ")",
        "...",
        ":",
        "<EOF>",
        "<SOF>",
        "=",
        "@",
        "BlockString",
        "Comment",
        "Float",
        "Int",
        "Name",
        "String",
        "[",
        "]",
        "{",
        "|",
        "}"
      ],
      "type": "string"
    },
    "Source": {
      "description": "A representation of source input to GraphQL. The `name` and `locationOffset` parameters are\noptional, but they are useful for clients who store GraphQL documents in source files.\nFor example, if the GraphQL input starts at line 40 in a file named `Foo.graphql`, it might\nbe useful for `name` to be `\"Foo.graphql\"` and location to be `{ line: 40, column: 1 }`.\nThe `line` and `column` properties in `locationOffset` are 1-indexed.",
      "type": "object",
      "properties": {
        "body": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "locationOffset": {
          "$ref": "#/definitions/Location_1"
        }
      }
    },
    "Location_1": {
      "type": "object",
      "properties": {
        "line": {
          "type": "number"
        },
        "column": {
          "type": "number"
        }
      }
    },
    "NameNode": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string",
          "enum": ["Name"]
        },
        "loc": {
          "$ref": "#/definitions/Location"
        },
        "value": {
          "type": "string"
        }
      }
    },
    "ReadonlyArray": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/VariableDefinitionNode"
      }
    },
    "VariableDefinitionNode": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string",
          "enum": ["VariableDefinition"]
        },
        "loc": {
          "$ref": "#/definitions/Location"
        },
        "variable": {
          "$ref": "#/definitions/VariableNode"
        },
        "type": {
          "$ref": "#/definitions/TypeNode"
        },
        "defaultValue": {
          "$ref": "#/definitions/ValueNode"
        },
        "directives": {
          "$ref": "#/definitions/ReadonlyArray_3"
        }
      }
    },
    "VariableNode": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string",
          "enum": ["Variable"]
        },
        "loc": {
          "$ref": "#/definitions/Location"
        },
        "name": {
          "$ref": "#/definitions/NameNode"
        }
      }
    },
    "TypeNode": {
      "anyOf": [
        {
          "$ref": "#/definitions/NamedTypeNode"
        },
        {
          "$ref": "#/definitions/ListTypeNode"
        },
        {
          "$ref": "#/definitions/NonNullTypeNode"
        }
      ]
    },
    "NamedTypeNode": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string",
          "enum": ["NamedType"]
        },
        "loc": {
          "$ref": "#/definitions/Location"
        },
        "name": {
          "$ref": "#/definitions/NameNode"
        }
      }
    },
    "ListTypeNode": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string",
          "enum": ["ListType"]
        },
        "loc": {
          "$ref": "#/definitions/Location"
        },
        "type": {
          "$ref": "#/definitions/TypeNode"
        }
      }
    },
    "NonNullTypeNode": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string",
          "enum": ["NonNullType"]
        },
        "loc": {
          "$ref": "#/definitions/Location"
        },
        "type": {
          "anyOf": [
            {
              "$ref": "#/definitions/NamedTypeNode"
            },
            {
              "$ref": "#/definitions/ListTypeNode"
            }
          ]
        }
      }
    },
    "ValueNode": {
      "anyOf": [
        {
          "$ref": "#/definitions/VariableNode"
        },
        {
          "$ref": "#/definitions/IntValueNode"
        },
        {
          "$ref": "#/definitions/FloatValueNode"
        },
        {
          "$ref": "#/definitions/StringValueNode"
        },
        {
          "$ref": "#/definitions/BooleanValueNode"
        },
        {
          "$ref": "#/definitions/NullValueNode"
        },
        {
          "$ref": "#/definitions/EnumValueNode"
        },
        {
          "$ref": "#/definitions/ListValueNode"
        },
        {
          "$ref": "#/definitions/ObjectValueNode"
        }
      ]
    },
    "IntValueNode": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string",
          "enum": ["IntValue"]
        },
        "loc": {
          "$ref": "#/definitions/Location"
        },
        "value": {
          "type": "string"
        }
      }
    },
    "FloatValueNode": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string",
          "enum": ["FloatValue"]
        },
        "loc": {
          "$ref": "#/definitions/Location"
        },
        "value": {
          "type": "string"
        }
      }
    },
    "StringValueNode": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string",
          "enum": ["StringValue"]
        },
        "loc": {
          "$ref": "#/definitions/Location"
        },
        "value": {
          "type": "string"
        },
        "block": {
          "type": "boolean"
        }
      }
    },
    "BooleanValueNode": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string",
          "enum": ["BooleanValue"]
        },
        "loc": {
          "$ref": "#/definitions/Location"
        },
        "value": {
          "type": "boolean"
        }
      }
    },
    "NullValueNode": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string",
          "enum": ["NullValue"]
        },
        "loc": {
          "$ref": "#/definitions/Location"
        }
      }
    },
    "EnumValueNode": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string",
          "enum": ["EnumValue"]
        },
        "loc": {
          "$ref": "#/definitions/Location"
        },
        "value": {
          "type": "string"
        }
      }
    },
    "ListValueNode": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string",
          "enum": ["ListValue"]
        },
        "loc": {
          "$ref": "#/definitions/Location"
        },
        "values": {
          "$ref": "#/definitions/ReadonlyArray_1"
        }
      }
    },
    "ReadonlyArray_1": {
      "type": "array",
      "items": {
        "anyOf": [
          {
            "$ref": "#/definitions/VariableNode"
          },
          {
            "$ref": "#/definitions/IntValueNode"
          },
          {
            "$ref": "#/definitions/FloatValueNode"
          },
          {
            "$ref": "#/definitions/StringValueNode"
          },
          {
            "$ref": "#/definitions/BooleanValueNode"
          },
          {
            "$ref": "#/definitions/NullValueNode"
          },
          {
            "$ref": "#/definitions/EnumValueNode"
          },
          {
            "$ref": "#/definitions/ListValueNode"
          },
          {
            "$ref": "#/definitions/ObjectValueNode"
          }
        ]
      }
    },
    "ObjectValueNode": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string",
          "enum": ["ObjectValue"]
        },
        "loc": {
          "$ref": "#/definitions/Location"
        },
        "fields": {
          "$ref": "#/definitions/ReadonlyArray_2"
        }
      }
    },
    "ReadonlyArray_2": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/ObjectFieldNode"
      }
    },
    "ObjectFieldNode": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string",
          "enum": ["ObjectField"]
        },
        "loc": {
          "$ref": "#/definitions/Location"
        },
        "name": {
          "$ref": "#/definitions/NameNode"
        },
        "value": {
          "$ref": "#/definitions/ValueNode"
        }
      }
    },
    "ReadonlyArray_3": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/DirectiveNode"
      }
    },
    "DirectiveNode": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string",
          "enum": ["Directive"]
        },
        "loc": {
          "$ref": "#/definitions/Location"
        },
        "name": {
          "$ref": "#/definitions/NameNode"
        },
        "arguments": {
          "$ref": "#/definitions/ReadonlyArray_4"
        }
      }
    },
    "ReadonlyArray_4": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/ArgumentNode"
      }
    },
    "ArgumentNode": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string",
          "enum": ["Argument"]
        },
        "loc": {
          "$ref": "#/definitions/Location"
        },
        "name": {
          "$ref": "#/definitions/NameNode"
        },
        "value": {
          "$ref": "#/definitions/ValueNode"
        }
      }
    },
    "SelectionSetNode": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string",
          "enum": ["SelectionSet"]
        },
        "loc": {
          "$ref": "#/definitions/Location"
        },
        "selections": {
          "$ref": "#/definitions/ReadonlyArray_5"
        }
      }
    },
    "ReadonlyArray_5": {
      "type": "array",
      "items": {
        "anyOf": [
          {
            "$ref": "#/definitions/FieldNode"
          },
          {
            "$ref": "#/definitions/FragmentSpreadNode"
          },
          {
            "$ref": "#/definitions/InlineFragmentNode"
          }
        ]
      }
    },
    "FieldNode": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string",
          "enum": ["Field"]
        },
        "loc": {
          "$ref": "#/definitions/Location"
        },
        "alias": {
          "$ref": "#/definitions/NameNode"
        },
        "name": {
          "$ref": "#/definitions/NameNode"
        },
        "arguments": {
          "$ref": "#/definitions/ReadonlyArray_4"
        },
        "directives": {
          "$ref": "#/definitions/ReadonlyArray_3"
        },
        "selectionSet": {
          "$ref": "#/definitions/SelectionSetNode"
        }
      }
    },
    "FragmentSpreadNode": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string",
          "enum": ["FragmentSpread"]
        },
        "loc": {
          "$ref": "#/definitions/Location"
        },
        "name": {
          "$ref": "#/definitions/NameNode"
        },
        "directives": {
          "$ref": "#/definitions/ReadonlyArray_3"
        }
      }
    },
    "InlineFragmentNode": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string",
          "enum": ["InlineFragment"]
        },
        "loc": {
          "$ref": "#/definitions/Location"
        },
        "typeCondition": {
          "$ref": "#/definitions/NamedTypeNode"
        },
        "directives": {
          "$ref": "#/definitions/ReadonlyArray_3"
        },
        "selectionSet": {
          "$ref": "#/definitions/SelectionSetNode"
        }
      }
    },
    "__type_5": {
      "type": "object",
      "properties": {
        "path": {
          "description": "Source path, relative to the `baseOutputDir`",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace to import source as",
          "type": "string"
        },
        "identifiers": {
          "description": "Entity names to import",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string"
              },
              "kind": {
                "enum": ["document", "type"],
                "type": "string"
              }
            }
          }
        }
      }
    },
    "ImportSource": {
      "$ref": "#/definitions/__type_5"
    },
    "AvoidOptionalsConfig": {
      "type": "object",
      "properties": {
        "field": {
          "type": "boolean"
        },
        "object": {
          "type": "boolean"
        },
        "inputValue": {
          "type": "boolean"
        },
        "defaultValue": {
          "type": "boolean"
        }
      }
    },
    "EnumValuesMap": {
      "description": "A raw configuration for enumValues map - can be represented with a single string value for a file path,\na map between enum name and a file path, or a map between enum name and an object with explicit enum values.",
      "anyOf": [
        {
          "type": "object",
          "additionalProperties": {
            "anyOf": [
              {
                "allOf": [
                  {
                    "type": "object",
                    "additionalProperties": {
                      "type": ["string", "number"]
                    }
                  },
                  {
                    "$ref": "#/definitions/AdditionalProps"
                  }
                ]
              },
              {
                "type": "string"
              }
            ]
          }
        },
        {
          "type": "string"
        }
      ]
    },
    "AdditionalProps": {
      "type": "object"
    },
    "DeclarationKindConfig": {
      "type": "object",
      "properties": {
        "scalar": {
          "$ref": "#/definitions/DeclarationKind"
        },
        "input": {
          "$ref": "#/definitions/DeclarationKind"
        },
        "type": {
          "$ref": "#/definitions/DeclarationKind"
        },
        "interface": {
          "$ref": "#/definitions/DeclarationKind"
        },
        "arguments": {
          "$ref": "#/definitions/DeclarationKind"
        }
      }
    },
    "DeclarationKind": {
      "enum": ["abstract class", "class", "interface", "type"],
      "type": "string"
    },
    "DocumentMode": {
      "enum": ["documentNode", "documentNodeImportFragments", "external", "graphQLTag", "string"],
      "type": "string"
    },
    "__type_6": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string"
        },
        "interface": {
          "type": "string"
        },
        "field": {
          "type": "string"
        },
        "input": {
          "type": "string"
        },
        "arguments": {
          "type": "string"
        }
      }
    },
    "Partial_1": {
      "$ref": "#/definitions/__type_6"
    },
    "Array_1": {
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "StencilComponentType": {
      "enum": ["class", "functional"],
      "type": "string"
    },
    "FileType": {
      "enum": [0, 1, 2, 3],
      "type": "number"
    },
    "GeneratedPluginsMap": {
      "anyOf": [
        {
          "type": "object",
          "additionalProperties": true,
          "properties": {
            "typescript-react-query": {
              "additionalProperties": false,
              "$ref": "#/definitions/ReactQueryRawPluginConfig"
            },
            "@graphql-codegen/typescript-react-query": {
              "additionalProperties": false,
              "$ref": "#/definitions/ReactQueryRawPluginConfig"
            },
            "typescript-apollo-client-helpers": {
              "additionalProperties": false,
              "$ref": "#/definitions/ApolloClientHelpersConfig"
            },
            "@graphql-codegen/typescript-apollo-client-helpers": {
              "additionalProperties": false,
              "$ref": "#/definitions/ApolloClientHelpersConfig"
            },
            "add": {
              "additionalProperties": false,
              "$ref": "#/definitions/AddPluginConfig"
            },
            "@graphql-codegen/add": {
              "additionalProperties": false,
              "$ref": "#/definitions/AddPluginConfig"
            },
            "time": {
              "additionalProperties": false,
              "$ref": "#/definitions/TimePluginConfig"
            },
            "@graphql-codegen/time": {
              "additionalProperties": false,
              "$ref": "#/definitions/TimePluginConfig"
            },
            "typescript": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeScriptPluginConfig"
            },
            "@graphql-codegen/typescript": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeScriptPluginConfig"
            },
            "typescript-operations": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeScriptDocumentsPluginConfig"
            },
            "@graphql-codegen/typescript-operations": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeScriptDocumentsPluginConfig"
            },
            "c-sharp": {
              "additionalProperties": false,
              "$ref": "#/definitions/CSharpResolversPluginRawConfig"
            },
            "@graphql-codegen/c-sharp": {
              "additionalProperties": false,
              "$ref": "#/definitions/CSharpResolversPluginRawConfig"
            },
            "c-sharp-operations": {
              "additionalProperties": false,
              "$ref": "#/definitions/CSharpOperationsRawPluginConfig"
            },
            "@graphql-codegen/c-sharp-operations": {
              "additionalProperties": false,
              "$ref": "#/definitions/CSharpOperationsRawPluginConfig"
            },
            "schema-ast": {
              "additionalProperties": false,
              "$ref": "#/definitions/SchemaASTConfig"
            },
            "@graphql-codegen/schema-ast": {
              "additionalProperties": false,
              "$ref": "#/definitions/SchemaASTConfig"
            },
            "typescript-type-graphql": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeGraphQLPluginConfig"
            },
            "@graphql-codegen/typescript-type-graphql": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeGraphQLPluginConfig"
            },
            "typescript-graphql-files-modules": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeScriptFilesModulesPluginConfig"
            },
            "@graphql-codegen/typescript-graphql-files-modules": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeScriptFilesModulesPluginConfig"
            },
            "named-operations-object": {
              "additionalProperties": false,
              "$ref": "#/definitions/NamedOperationsObjectPluginConfig"
            },
            "@graphql-codegen/named-operations-object": {
              "additionalProperties": false,
              "$ref": "#/definitions/NamedOperationsObjectPluginConfig"
            },
            "typescript-graphql-request": {
              "additionalProperties": false,
              "$ref": "#/definitions/RawGraphQLRequestPluginConfig"
            },
            "@graphql-codegen/typescript-graphql-request": {
              "additionalProperties": false,
              "$ref": "#/definitions/RawGraphQLRequestPluginConfig"
            },
            "typescript-compatibility": {
              "additionalProperties": false,
              "$ref": "#/definitions/CompatibilityPluginRawConfig"
            },
            "@graphql-codegen/typescript-compatibility": {
              "additionalProperties": false,
              "$ref": "#/definitions/CompatibilityPluginRawConfig"
            },
            "typescript-mongodb": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeScriptMongoPluginConfig"
            },
            "@graphql-codegen/typescript-mongodb": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeScriptMongoPluginConfig"
            },
            "typescript-resolvers": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeScriptResolversPluginConfig"
            },
            "@graphql-codegen/typescript-resolvers": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeScriptResolversPluginConfig"
            },
            "typescript-apollo-angular": {
              "additionalProperties": false,
              "$ref": "#/definitions/ApolloAngularRawPluginConfig"
            },
            "@graphql-codegen/typescript-apollo-angular": {
              "additionalProperties": false,
              "$ref": "#/definitions/ApolloAngularRawPluginConfig"
            },
            "typescript-urql": {
              "additionalProperties": false,
              "$ref": "#/definitions/UrqlRawPluginConfig"
            },
            "@graphql-codegen/typescript-urql": {
              "additionalProperties": false,
              "$ref": "#/definitions/UrqlRawPluginConfig"
            },
            "typescript-react-apollo": {
              "additionalProperties": false,
              "$ref": "#/definitions/ReactApolloRawPluginConfig"
            },
            "@graphql-codegen/typescript-react-apollo": {
              "additionalProperties": false,
              "$ref": "#/definitions/ReactApolloRawPluginConfig"
            },
            "typescript-vue-apollo": {
              "additionalProperties": false,
              "$ref": "#/definitions/VueApolloRawPluginConfig"
            },
            "@graphql-codegen/typescript-vue-apollo": {
              "additionalProperties": false,
              "$ref": "#/definitions/VueApolloRawPluginConfig"
            },
            "typescript-stencil-apollo": {
              "additionalProperties": false,
              "$ref": "#/definitions/StencilApolloRawPluginConfig"
            },
            "@graphql-codegen/typescript-stencil-apollo": {
              "additionalProperties": false,
              "$ref": "#/definitions/StencilApolloRawPluginConfig"
            },
            "typescript-document-nodes": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeScriptDocumentNodesRawPluginConfig"
            },
            "@graphql-codegen/typescript-document-nodes": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeScriptDocumentNodesRawPluginConfig"
            },
            "java-apollo-android": {
              "additionalProperties": false,
              "$ref": "#/definitions/JavaApolloAndroidPluginConfig"
            },
            "@graphql-codegen/java-apollo-android": {
              "additionalProperties": false,
              "$ref": "#/definitions/JavaApolloAndroidPluginConfig"
            },
            "java-resolvers": {
              "additionalProperties": false,
              "$ref": "#/definitions/JavaResolversPluginRawConfig"
            },
            "@graphql-codegen/java-resolvers": {
              "additionalProperties": false,
              "$ref": "#/definitions/JavaResolversPluginRawConfig"
            },
            "java": {
              "additionalProperties": false,
              "$ref": "#/definitions/JavaResolversPluginRawConfig"
            },
            "@graphql-codegen/java": {
              "additionalProperties": false,
              "$ref": "#/definitions/JavaResolversPluginRawConfig"
            },
            "kotlin": {
              "additionalProperties": false,
              "$ref": "#/definitions/KotlinResolversPluginRawConfig"
            },
            "@graphql-codegen/kotlin": {
              "additionalProperties": false,
              "$ref": "#/definitions/KotlinResolversPluginRawConfig"
            },
            "flow": {
              "additionalProperties": false,
              "$ref": "#/definitions/FlowPluginConfig"
            },
            "@graphql-codegen/flow": {
              "additionalProperties": false,
              "$ref": "#/definitions/FlowPluginConfig"
            },
            "flow-resolvers": {
              "additionalProperties": false,
              "$ref": "#/definitions/RawFlowResolversConfig"
            },
            "@graphql-codegen/flow-resolvers": {
              "additionalProperties": false,
              "$ref": "#/definitions/RawFlowResolversConfig"
            },
            "flow-operations": {
              "additionalProperties": false,
              "$ref": "#/definitions/FlowDocumentsPluginConfig"
            },
            "@graphql-codegen/flow-operations": {
              "additionalProperties": false,
              "$ref": "#/definitions/FlowDocumentsPluginConfig"
            },
            "introspection": {
              "additionalProperties": false,
              "$ref": "#/definitions/IntrospectionPluginConfig"
            },
            "@graphql-codegen/introspection": {
              "additionalProperties": false,
              "$ref": "#/definitions/IntrospectionPluginConfig"
            },
            "fragment-matcher": {
              "additionalProperties": false,
              "$ref": "#/definitions/FragmentMatcherConfig"
            },
            "@graphql-codegen/fragment-matcher": {
              "additionalProperties": false,
              "$ref": "#/definitions/FragmentMatcherConfig"
            }
          }
        },
        {
          "type": "string",
          "oneOf": [
            {
              "const": "typescript-react-query",
              "description": "This plugin generates `React-Query` Hooks with TypeScript typings.\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` - and thus shares a similar configuration.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-react-query\n\n=> Make sure to include \"@graphql-codegen/typescript-react-query\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-react-query",
              "description": "This plugin generates `React-Query` Hooks with TypeScript typings.\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` - and thus shares a similar configuration.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-react-query\n\n=> Make sure to include \"@graphql-codegen/typescript-react-query\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-apollo-client-helpers",
              "description": "\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-apollo-client-helpers\n\n=> Make sure to include \"@graphql-codegen/typescript-apollo-client-helpers\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-apollo-client-helpers",
              "description": "\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-apollo-client-helpers\n\n=> Make sure to include \"@graphql-codegen/typescript-apollo-client-helpers\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "add",
              "description": "\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/add\n\n=> Make sure to include \"@graphql-codegen/add\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/add",
              "description": "\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/add\n\n=> Make sure to include \"@graphql-codegen/add\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "time",
              "description": "\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/time\n\n=> Make sure to include \"@graphql-codegen/time\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/time",
              "description": "\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/time\n\n=> Make sure to include \"@graphql-codegen/time\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript",
              "description": "This plugin generates the base TypeScript types, based on your GraphQL schema.\n\nThe types generated by this plugin are simple, and refers to the exact structure of your schema, and it's used as the base types for other plugins (such as `typescript-operations` / `typescript-resolvers`)\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript\n\n=> Make sure to include \"@graphql-codegen/typescript\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript",
              "description": "This plugin generates the base TypeScript types, based on your GraphQL schema.\n\nThe types generated by this plugin are simple, and refers to the exact structure of your schema, and it's used as the base types for other plugins (such as `typescript-operations` / `typescript-resolvers`)\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript\n\n=> Make sure to include \"@graphql-codegen/typescript\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-operations",
              "description": "This plugin generates TypeScript types based on your GraphQLSchema *and* your GraphQL operations and fragments.\nIt generates types for your GraphQL documents: Query, Mutation, Subscription and Fragment.\n\nNote: In most configurations, this plugin requires you to use `typescript as well, because it depends on its base types.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-operations\n\n=> Make sure to include \"@graphql-codegen/typescript-operations\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-operations",
              "description": "This plugin generates TypeScript types based on your GraphQLSchema *and* your GraphQL operations and fragments.\nIt generates types for your GraphQL documents: Query, Mutation, Subscription and Fragment.\n\nNote: In most configurations, this plugin requires you to use `typescript as well, because it depends on its base types.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-operations\n\n=> Make sure to include \"@graphql-codegen/typescript-operations\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "c-sharp",
              "description": "This plugin generates C# `class` identifier for your schema types.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/c-sharp\n\n=> Make sure to include \"@graphql-codegen/c-sharp\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/c-sharp",
              "description": "This plugin generates C# `class` identifier for your schema types.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/c-sharp\n\n=> Make sure to include \"@graphql-codegen/c-sharp\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "c-sharp-operations",
              "description": "This plugin generates C# `class` based on your GraphQL operations.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/c-sharp-operations\n\n=> Make sure to include \"@graphql-codegen/c-sharp-operations\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/c-sharp-operations",
              "description": "This plugin generates C# `class` based on your GraphQL operations.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/c-sharp-operations\n\n=> Make sure to include \"@graphql-codegen/c-sharp-operations\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "schema-ast",
              "description": "This plugin prints the merged schema as string. If multiple schemas are provided, they will be merged and printed as one schema.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/schema-ast\n\n=> Make sure to include \"@graphql-codegen/schema-ast\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/schema-ast",
              "description": "This plugin prints the merged schema as string. If multiple schemas are provided, they will be merged and printed as one schema.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/schema-ast\n\n=> Make sure to include \"@graphql-codegen/schema-ast\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-type-graphql",
              "description": "\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-type-graphql\n\n=> Make sure to include \"@graphql-codegen/typescript-type-graphql\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-type-graphql",
              "description": "\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-type-graphql\n\n=> Make sure to include \"@graphql-codegen/typescript-type-graphql\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-graphql-files-modules",
              "description": "This plugin generates TypeScript typings for `.graphql` files containing GraphQL documents, which later on can be consumed using [`graphql-tag/loader`](https://github.com/apollographql/graphql-tag#webpack-preprocessing-with-graphql-tagloader) or use `string` types if you will use the operations as raw strings, and get type-check and type-safety for your imports. This means that any time you import objects from `.graphql` files, your IDE will provide auto-complete.\n\nThis plugin also handles `.graphql` files containing multiple GraphQL documents, and name the imports according to the operation name.\n\n> ⚠ Fragments are not generated with named imports, only as default imports, due to `graphql-tag/loader` behavior.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-graphql-files-modules\n\n=> Make sure to include \"@graphql-codegen/typescript-graphql-files-modules\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-graphql-files-modules",
              "description": "This plugin generates TypeScript typings for `.graphql` files containing GraphQL documents, which later on can be consumed using [`graphql-tag/loader`](https://github.com/apollographql/graphql-tag#webpack-preprocessing-with-graphql-tagloader) or use `string` types if you will use the operations as raw strings, and get type-check and type-safety for your imports. This means that any time you import objects from `.graphql` files, your IDE will provide auto-complete.\n\nThis plugin also handles `.graphql` files containing multiple GraphQL documents, and name the imports according to the operation name.\n\n> ⚠ Fragments are not generated with named imports, only as default imports, due to `graphql-tag/loader` behavior.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-graphql-files-modules\n\n=> Make sure to include \"@graphql-codegen/typescript-graphql-files-modules\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "named-operations-object",
              "description": "\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/named-operations-object\n\n=> Make sure to include \"@graphql-codegen/named-operations-object\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/named-operations-object",
              "description": "\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/named-operations-object\n\n=> Make sure to include \"@graphql-codegen/named-operations-object\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-graphql-request",
              "description": "This plugin generates [`graphql-request`](https://www.npmjs.com/package/graphql-request) ready-to-use SDK, which is fully-typed.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-graphql-request\n\n=> Make sure to include \"@graphql-codegen/typescript-graphql-request\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-graphql-request",
              "description": "This plugin generates [`graphql-request`](https://www.npmjs.com/package/graphql-request) ready-to-use SDK, which is fully-typed.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-graphql-request\n\n=> Make sure to include \"@graphql-codegen/typescript-graphql-request\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-compatibility",
              "description": "If you are migrating from <1.0, we created a new plugin called `typescript-compatibility` that generates backward compatibility for the `typescript-operations` and `typescript-react-apollo` plugins.\n\nIt generates types that are pointing to the new form of types. It supports _most_ of the use-cases.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-compatibility\n\n=> Make sure to include \"@graphql-codegen/typescript-compatibility\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-compatibility",
              "description": "If you are migrating from <1.0, we created a new plugin called `typescript-compatibility` that generates backward compatibility for the `typescript-operations` and `typescript-react-apollo` plugins.\n\nIt generates types that are pointing to the new form of types. It supports _most_ of the use-cases.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-compatibility\n\n=> Make sure to include \"@graphql-codegen/typescript-compatibility\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-mongodb",
              "description": "\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-mongodb\n\n=> Make sure to include \"@graphql-codegen/typescript-mongodb\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-mongodb",
              "description": "\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-mongodb\n\n=> Make sure to include \"@graphql-codegen/typescript-mongodb\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-resolvers",
              "description": "This plugin generates TypeScript signature for `resolve` functions of your GraphQL API.\nYou can use this plugin a to generate simple resolvers signature based on your GraphQL types, or you can change it's behavior be providing custom model types (mappers).\n\nYou can find a blog post explaining the usage of this plugin here: https://the-guild.dev/blog/better-type-safety-for-resolvers-with-graphql-codegen\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-resolvers\n\n=> Make sure to include \"@graphql-codegen/typescript-resolvers\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-resolvers",
              "description": "This plugin generates TypeScript signature for `resolve` functions of your GraphQL API.\nYou can use this plugin a to generate simple resolvers signature based on your GraphQL types, or you can change it's behavior be providing custom model types (mappers).\n\nYou can find a blog post explaining the usage of this plugin here: https://the-guild.dev/blog/better-type-safety-for-resolvers-with-graphql-codegen\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-resolvers\n\n=> Make sure to include \"@graphql-codegen/typescript-resolvers\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-apollo-angular",
              "description": "This plugin generates Apollo services (`Query`, `Mutation` and `Subscription`) with TypeScript typings.\n\nIt will generate a strongly typed Angular service for every defined query, mutation or subscription. The generated Angular services are ready to inject and use within your Angular component.\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` - and thus shares a similar configuration.\n\nTo shed some more light regards this template, it's recommended to go through the this article: http://apollographql.com/docs/angular/basics/services.html , and to read the Code Generation with Apollo Angular: https://the-guild.dev/blog/apollo-angular-12\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-apollo-angular\n\n=> Make sure to include \"@graphql-codegen/typescript-apollo-angular\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-apollo-angular",
              "description": "This plugin generates Apollo services (`Query`, `Mutation` and `Subscription`) with TypeScript typings.\n\nIt will generate a strongly typed Angular service for every defined query, mutation or subscription. The generated Angular services are ready to inject and use within your Angular component.\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` - and thus shares a similar configuration.\n\nTo shed some more light regards this template, it's recommended to go through the this article: http://apollographql.com/docs/angular/basics/services.html , and to read the Code Generation with Apollo Angular: https://the-guild.dev/blog/apollo-angular-12\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-apollo-angular\n\n=> Make sure to include \"@graphql-codegen/typescript-apollo-angular\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-urql",
              "description": "This plugin generates `urql` (https://github.com/FormidableLabs/urql) components and HOC with TypeScript typings.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-urql\n\n=> Make sure to include \"@graphql-codegen/typescript-urql\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-urql",
              "description": "This plugin generates `urql` (https://github.com/FormidableLabs/urql) components and HOC with TypeScript typings.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-urql\n\n=> Make sure to include \"@graphql-codegen/typescript-urql\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-react-apollo",
              "description": "This plugin generates React Apollo components and HOC with TypeScript typings.\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` - and thus shares a similar configuration.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-react-apollo\n\n=> Make sure to include \"@graphql-codegen/typescript-react-apollo\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-react-apollo",
              "description": "This plugin generates React Apollo components and HOC with TypeScript typings.\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` - and thus shares a similar configuration.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-react-apollo\n\n=> Make sure to include \"@graphql-codegen/typescript-react-apollo\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-vue-apollo",
              "description": "This plugin generates\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-vue-apollo\n\n=> Make sure to include \"@graphql-codegen/typescript-vue-apollo\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-vue-apollo",
              "description": "This plugin generates\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-vue-apollo\n\n=> Make sure to include \"@graphql-codegen/typescript-vue-apollo\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-stencil-apollo",
              "description": "This plugin generates Stencil Apollo functional components typings\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` - and thus shares a similar configuration.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-stencil-apollo\n\n=> Make sure to include \"@graphql-codegen/typescript-stencil-apollo\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-stencil-apollo",
              "description": "This plugin generates Stencil Apollo functional components typings\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` - and thus shares a similar configuration.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-stencil-apollo\n\n=> Make sure to include \"@graphql-codegen/typescript-stencil-apollo\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-document-nodes",
              "description": "This plugin generates TypeScript source (`.ts`) file from GraphQL files (`.graphql`).\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-document-nodes\n\n=> Make sure to include \"@graphql-codegen/typescript-document-nodes\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-document-nodes",
              "description": "This plugin generates TypeScript source (`.ts`) file from GraphQL files (`.graphql`).\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/typescript-document-nodes\n\n=> Make sure to include \"@graphql-codegen/typescript-document-nodes\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "java-apollo-android",
              "description": "This plugin and presets creates generated mappers and parsers for a complete type-safe GraphQL requests, for developers that uses Apollo Android runtime.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/java-apollo-android\n\n=> Make sure to include \"@graphql-codegen/java-apollo-android\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/java-apollo-android",
              "description": "This plugin and presets creates generated mappers and parsers for a complete type-safe GraphQL requests, for developers that uses Apollo Android runtime.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/java-apollo-android\n\n=> Make sure to include \"@graphql-codegen/java-apollo-android\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "java-resolvers",
              "description": "\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/java-resolvers\n\n=> Make sure to include \"@graphql-codegen/java-resolvers\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/java-resolvers",
              "description": "\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/java-resolvers\n\n=> Make sure to include \"@graphql-codegen/java-resolvers\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "java",
              "description": "\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/java\n\n=> Make sure to include \"@graphql-codegen/java\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/java",
              "description": "\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/java\n\n=> Make sure to include \"@graphql-codegen/java\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "kotlin",
              "description": "\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/kotlin\n\n=> Make sure to include \"@graphql-codegen/kotlin\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/kotlin",
              "description": "\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/kotlin\n\n=> Make sure to include \"@graphql-codegen/kotlin\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "flow",
              "description": "This plugin generates Flow types based on your `GraphQLSchema`.\n\nIt generates types for your entire schema: types, input types, enum, interface, scalar and union.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/flow\n\n=> Make sure to include \"@graphql-codegen/flow\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/flow",
              "description": "This plugin generates Flow types based on your `GraphQLSchema`.\n\nIt generates types for your entire schema: types, input types, enum, interface, scalar and union.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/flow\n\n=> Make sure to include \"@graphql-codegen/flow\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "flow-resolvers",
              "description": "This plugin generates resolvers signature based on your `GraphQLSchema`.\n\nIt generates types for your entire schema: types, input types, enum, interface, scalar and union.\n\nThis plugin requires you to use `@graphql-codegen/flow` as well, because it depends on it's types.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/flow-resolvers\n\n=> Make sure to include \"@graphql-codegen/flow-resolvers\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/flow-resolvers",
              "description": "This plugin generates resolvers signature based on your `GraphQLSchema`.\n\nIt generates types for your entire schema: types, input types, enum, interface, scalar and union.\n\nThis plugin requires you to use `@graphql-codegen/flow` as well, because it depends on it's types.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/flow-resolvers\n\n=> Make sure to include \"@graphql-codegen/flow-resolvers\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "flow-operations",
              "description": "This plugin generates Flow types based on your `GraphQLSchema` and your GraphQL operations and fragments.\n\nIt generates types for your GraphQL documents: Query, Mutation, Subscription and Fragment.\n\nThis plugin requires you to use `@graphql-codegen/flow` as well, because it depends on it's types.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/flow-operations\n\n=> Make sure to include \"@graphql-codegen/flow-operations\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/flow-operations",
              "description": "This plugin generates Flow types based on your `GraphQLSchema` and your GraphQL operations and fragments.\n\nIt generates types for your GraphQL documents: Query, Mutation, Subscription and Fragment.\n\nThis plugin requires you to use `@graphql-codegen/flow` as well, because it depends on it's types.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/flow-operations\n\n=> Make sure to include \"@graphql-codegen/flow-operations\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "introspection",
              "description": "This plugin generates a GraphQL introspection file based on your GraphQL schema.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/introspection\n\n=> Make sure to include \"@graphql-codegen/introspection\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/introspection",
              "description": "This plugin generates a GraphQL introspection file based on your GraphQL schema.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/introspection\n\n=> Make sure to include \"@graphql-codegen/introspection\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "fragment-matcher",
              "description": "This plugin generates an introspection file but only with Interfaces and Unions, based on your GraphQLSchema.\n\nIf you are using `apollo-client` and your schema contains `interface` or `union` declaration, it's recommended to use Apollo's Fragment Matcher and the result generated by the plugin.\n\nYou can read more about it in `apollo-client` documentation: https://www.apollographql.com/docs/react/data/fragments/#fragments-on-unions-and-interfaces.\n\nFragment Matcher plugin accepts a TypeScript / JavaScript or a JSON file as an output _(`.ts, .tsx, .js, .jsx, .json`)_.\n\nBoth in TypeScript and JavaScript a default export is being used.\n\n> The output is based on the output you choose for the output file name.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/fragment-matcher\n\n=> Make sure to include \"@graphql-codegen/fragment-matcher\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/fragment-matcher",
              "description": "This plugin generates an introspection file but only with Interfaces and Unions, based on your GraphQLSchema.\n\nIf you are using `apollo-client` and your schema contains `interface` or `union` declaration, it's recommended to use Apollo's Fragment Matcher and the result generated by the plugin.\n\nYou can read more about it in `apollo-client` documentation: https://www.apollographql.com/docs/react/data/fragments/#fragments-on-unions-and-interfaces.\n\nFragment Matcher plugin accepts a TypeScript / JavaScript or a JSON file as an output _(`.ts, .tsx, .js, .jsx, .json`)_.\n\nBoth in TypeScript and JavaScript a default export is being used.\n\n> The output is based on the output you choose for the output file name.\n\nFor more details and documentation: https://graphql-code-generator.com/docs/plugins/fragment-matcher\n\n=> Make sure to include \"@graphql-codegen/fragment-matcher\" in your package.json file and install your dependencies.\n\n"
            }
          ]
        },
        {
          "type": "string",
          "description": "Point to a custom plugin loaded from your file-system.",
          "pattern": "(\\\\?([^\\/]*[\\/])*)([^\\/]+)$"
        },
        {
          "type": "string",
          "description": "You can point to any third-party module from node_modules that matches the requirements of a GraphQL Codegen plugin."
        }
      ]
    }
  },
  "$ref": "#/definitions/Types.Config"
}
