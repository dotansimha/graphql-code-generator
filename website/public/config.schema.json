{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "Types.Config": {
      "description": "Represents the root YAML schema for the config file.",
      "additionalProperties": false,
      "type": "object",
      "properties": {
        "schema": {
          "$ref": "#/definitions/Types.InstanceOrArray",
          "description": "A pointer(s) to your GraphQL schema. This schema will be the base schema for all your outputs.\nYou can use one of the following:\n\n- URL pointing to a GraphQL endpoint\n- Path to a local `.json` file\n- Path to a local `.graphql` file\n- Glob expression pointing to multiple `.graphql` files\n- Path to a local code file (for example: `.js`) that exports `GraphQLSchema` object\n- Inline string containing GraphQL SDL schema definition\n\nYou can specify either a single schema, or multiple, and GraphQL Code Generator will merge the schemas into a single schema.\n\nFor more details: https://graphql-code-generator.com/docs/config-reference/schema-field"
        },
        "require": {
          "$ref": "#/definitions/Types.RequireExtension",
          "description": "A path to a file which defines custom Node.JS require() handlers for custom file extensions.\nThis is essential if the code generator has to go through files which require other files in an unsupported format (by default).\n\nFor more details: https://graphql-code-generator.com/docs/config-reference/require-field\nSee more information about require.extensions: https://gist.github.com/jamestalmage/df922691475cff66c7e6.\n\nNote: values that specified in your .yml file will get loaded after loading the config .yml file."
        },
        "customFetch": {
          "description": "Specify a Node module name, a custom file, or a function, to be used instead of a standard `fetch`.",
          "anyOf": [
            {
              "$ref": "#/definitions/Types.CustomSchemaFetcher",
              "description": "A function to use for fetching the schema."
            },
            { "type": "string" }
          ]
        },
        "documents": {
          "$ref": "#/definitions/Types.InstanceOrArray_1",
          "description": "A pointer(s) to your GraphQL documents: query, mutation, subscription and fragment. These documents will be loaded into for all your output files.\nYou can use one of the following:\n\n- Path to a local `.graphql` file\n- Path to a code file (for example: `.js` or `.tsx`) containing GraphQL operation strings.\n- Glob expression pointing to multiple `.graphql` files\n- Glob expression pointing to multiple code files\n- Inline string containing GraphQL SDL operation definition\n\nYou can specify either a single file, or multiple.\n\nFor more details: https://graphql-code-generator.com/docs/config-reference/documents-field"
        },
        "config": {
          "type": "object",
          "additionalProperties": true,
          "description": "Configuration object containing key => value that will be passed to the plugins.\nSpecifying configuration in this level of your configuration file will pass it to all plugins, in all outputs.\n\nThe options may vary depends on what plugins you are using.\n\nFor more details: https://graphql-code-generator.com/docs/config-reference/config-field"
        },
        "generates": {
          "description": "A map where the key represents an output path for the generated code and the value represents a set of options which are relevant for that specific file.\n\nFor more details: https://graphql-code-generator.com/docs/config-reference/codegen-config",
          "type": "object",
          "additionalProperties": {
            "anyOf": [
              { "type": "array", "items": { "$ref": "#/definitions/Types.ConfiguredPlugin" } },
              { "$ref": "#/definitions/Types.ConfiguredOutput" }
            ]
          }
        },
        "overwrite": {
          "description": "A flag to overwrite files if they already exist when generating code (`true` by default).\n\nFor more details: https://graphql-code-generator.com/docs/config-reference/codegen-config",
          "type": "boolean"
        },
        "watch": {
          "description": "A flag to trigger codegen when there are changes in the specified GraphQL schemas.\n\nYou can either specify a boolean to turn it on/off or specify an array of glob patterns to add custom files to the watch.\n\nFor more details: https://graphql-code-generator.com/docs/getting-started/development-workflow#watch-mode",
          "anyOf": [{ "type": "array", "items": { "type": "string" } }, { "type": ["string", "boolean"] }]
        },
        "ignoreNoDocuments": {
          "description": "A flag to suppress non-zero exit code when there are no documents to generate.",
          "type": "boolean"
        },
        "emitLegacyCommonJSImports": {
          "description": "A flag to disable adding `.js` extension to the output file. Default: `true`.",
          "type": "boolean"
        },
        "importExtension": {
          "description": "Append this extension to all imports.\nUseful for ESM environments that require file extensions in import statements.",
          "anyOf": [
            { "type": "array", "items": { "type": "string" } },
            { "enum": [""], "type": "string" }
          ]
        },
        "silent": { "description": "A flag to suppress printing errors when they occur.", "type": "boolean" },
        "verbose": { "description": "A flag to output more detailed information about tasks", "type": "boolean" },
        "debug": { "description": "A flag to output debug logs", "type": "boolean" },
        "errorsOnly": { "description": "A flag to print only errors.", "type": "boolean" },
        "pluginLoader": {
          "$ref": "#/definitions/Types.PackageLoaderFn",
          "description": "If you are using the programmatic API in a browser environment, you can override this configuration to load your plugins in a way different than require."
        },
        "pluginContext": {
          "description": "Additional context passed to plugins",
          "type": "object",
          "additionalProperties": {}
        },
        "pluckConfig": {
          "description": "Allows you to override the configuration for `@graphql-tools/graphql-tag-pluck`, the tool that extracts your GraphQL operations from your code files.\n\nFor more details: https://graphql-code-generator.com/docs/config-reference/documents-field#graphql-tag-pluck",
          "type": "object",
          "properties": {
            "modules": {
              "$ref": "#/definitions/Array",
              "description": "An array of package name and identifier that will be used to track down your gql usages and imports. Use this if your code files imports gql from another library or you have a custom gql tag. identifier is the named export, so don't provide it if the tag function is imported as default."
            },
            "gqlMagicComment": {
              "description": "Configures the magic GraphQL comments to look for. The default is `GraphQL`.",
              "type": "string"
            },
            "globalIdentifier": {
              "description": "Overrides the name of the default GraphQL name identifier.",
              "type": "string"
            },
            "globalGqlIdentifierName": {
              "description": "Allows to use a global identifier instead of a module import.",
              "anyOf": [{ "type": "array", "items": { "type": "string" } }, { "type": "string" }]
            }
          }
        },
        "hooks": {
          "$ref": "#/definitions/Partial",
          "description": "Specifies scripts to run when events are happening in the codegen core.\nHooks defined on that level will effect all output files.\n\nFor more details: https://graphql-code-generator.com/docs/config-reference/lifecycle-hooks"
        },
        "noSilentErrors": {
          "description": "Alows to raise errors if any matched files are not valid GraphQL. Default: false.",
          "type": "boolean"
        },
        "allowPartialOutputs": {
          "description": "If `true`, write to files whichever `generates` block succeeds. If `false`, one failed `generates` means no output is written to files. Default: false",
          "type": "boolean"
        }
      }
    },
    "FlutterFreezedPluginConfig": {
      "description": "configure the `flutter-freezed` plugin",
      "type": "object",
      "properties": {
        "camelCasedEnums": {
          "type": "{(boolean | DartIdentifierCasing)}",
          "description": "Setting this option to `true` will camelCase enum values as required by Dart's recommended linter.\n\nIf set to false, the original casing as specified in the Graphql Schema is used\n\nYou can also transform the casing by specifying your preferred casing for Enum values.\n\nAvailable options are: `'snake_case'`, `'camelCase'` and `'PascalCase'`\n\nFor consistency, this option applies the same configuration to all Enum Types in the GraphQL Schema\nDefault value: \"true\""
        },
        "copyWith": {
          "type": "{(boolean | TypeNamePattern)}",
          "description": "The [`freezed`](https://pub.dev/packages/freezed) library has this option enabled by default.\nUse this option to enable/disable this option completely.\n\nThe plugin by default generates immutable Freezed models using the `@freezed` decorator.\n\nIf this option is configured, the plugin will generate immutable Freezed models using the `@Freezed(copyWith: value)` instead.\n\nSetting a boolean value will enable/disable this option globally for every GraphQL Type\nbut you can also set this option to `true` for one or more GraphQL Types using a `TypeNamePattern`.\nDefault value: \"undefined\""
        },
        "customScalars": {
          "type": "{(Record<string, string>)}",
          "description": "The `key` is the GraphQL Scalar Type and the `value` is the equivalent Dart Type\n\nThe plugin automatically handles built-in GraphQL Scalar Types so only specify the custom Scalars in your Graphql Schema.\nDefault value: \"[object Object]\""
        },
        "defaultValues": {
          "type": "{([pattern: FieldNamePattern, value: string, appliesOn: AppliesOnParameters[]][])}",
          "description": "This will annotate the generated parameter with a `@Default(value: defaultValue)` decorator.\n\nThe default value will be interpolated into the `@Default(value: ${value})` decorator so\nUse backticks for the value element so that you can use quotation marks for string values.\nE.g: `\"I'm a string default value\"` but `Episode.jedi` is not a string value.\n\nUse the `appliesOn` to specify where this option should be applied on\nDefault value: \"undefined\""
        },
        "deprecated": {
          "type": "{([pattern: Pattern, appliesOn: (AppliesOnFactory | AppliesOnParameters)[]][])}",
          "description": "Using a TypeNamePattern, you can mark an entire factory constructor for one or more GraphQL types as deprecated.\n\nLikewise, using a FieldNamePattern, you can mark one or more fields as deprecated\n\nSince the first element in the tuple has a type signature of `Pattern`,\nyou can use either TypeNamePattern or FieldNamePattern or use both\nby composing them with `Pattern.compose(...)`\n\nUse the `appliesOn` to specify which block this option should be applied on\nDefault value: \"undefined\""
        },
        "equal": {
          "type": "{(boolean | TypeNamePattern)}",
          "description": "The [`freezed`](https://pub.dev/packages/freezed) library has this option enabled by default.\nUse this option to enable/disable this option completely.\n\nThe plugin by default generates immutable Freezed models using the `@freezed` decorator.\n\nIf this option is configured, the plugin will generate immutable Freezed models using the `@Freezed(equal: value)` instead.\n\nSetting a boolean value will enable/disable this option globally for every GraphQL Type\nbut you can also set this option to `true` for one or more GraphQL Types using a `TypeNamePattern`.\nDefault value: \"undefined\""
        },
        "escapeDartKeywords": {
          "type": "{(boolean | [pattern: Pattern, prefix?: string, suffix?: string, appliesOn?: AppliesOn[]][])}",
          "description": "Wraps the fields names that are valid Dart keywords with the prefix and suffix given\nDefault value: \"true\""
        },
        "final": {
          "type": "{([pattern: FieldNamePattern, appliesOn: AppliesOnParameters[]][])}",
          "description": "This will mark the specified parameters as final\nDefault value: \"undefined\""
        },
        "ignoreTypes": {
          "type": "{(TypeNamePattern)}",
          "description": "names of GraphQL types to ignore when generating Freezed classes\nDefault value: \"undefined\""
        },
        "immutable": {
          "type": "{(boolean | TypeNamePattern)}",
          "description": "The [`freezed`](https://pub.dev/packages/freezed) library  by default generates immutable models decorated with the `@freezed` decorator.\nThis option if set to `false` the plugin will generate mutable Freezed models using the `@unfreezed` decorator instead.\n\nSetting a boolean value will enable/disable this option globally for every GraphQL Type\nbut you can also set this option to `true` for one or more GraphQL Types using a `TypeNamePattern`.\nDefault value: \"undefined\""
        },
        "makeCollectionsUnmodifiable": {
          "type": "{(boolean | TypeNamePattern)}",
          "description": "allows collections(lists/maps) to be modified even if class is immutable\nDefault value: \"undefined\""
        },
        "mergeTypes": {
          "type": "{(Record<string, TypeName[]>)}",
          "description": "maps over the value(array of typeNames) and transform each as a named factory constructor inside a class generated for the key(target GraphQL Object Type).\nDefault value: \"undefined\""
        },
        "mutableInputs": {
          "description": "since inputs will be used to collect data, it makes sense to make them mutable with Freezed's `@unfreezed` decorator.\n\nThis overrides(in order words: has a higher precedence than) the `immutable` config value `ONLY` for GraphQL `input types`.\nDefault value: \"true\"",
          "anyOf": [{ "$ref": "#/definitions/TypeNamePattern" }, { "type": "boolean" }]
        },
        "privateEmptyConstructor": {
          "description": "if true, defines a private empty constructor to allow getter and methods to work on the class\nDefault value: \"true\"",
          "anyOf": [{ "$ref": "#/definitions/TypeNamePattern" }, { "type": "boolean" }]
        },
        "unionClass": {
          "description": "customize the key to be used for fromJson with multiple constructors\nDefault value: \"undefined\"",
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              { "$ref": "#/definitions/TypeNamePattern" },
              { "type": "string" },
              { "$ref": "#/definitions/UnionValueCase" },
              {
                "type": "array",
                "items": {
                  "type": "array",
                  "items": [{ "$ref": "#/definitions/TypeName" }, { "type": "string" }],
                  "minItems": 2,
                  "maxItems": 2
                }
              }
            ],
            "minItems": 1,
            "maxItems": 4
          }
        }
      }
    },
    "ReactQueryRawPluginConfig": {
      "description": "This plugin generates `React-Query` Hooks with TypeScript typings.\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` - and thus shares a similar configuration.\n\n> **If you are using the `react-query` package instead of the `@tanstack/react-query` package in your project, please set the `legacyMode` option to `true`.**",
      "type": "object",
      "properties": {
        "fetcher": {
          "description": "Customize the fetcher you wish to use in the generated file. React-Query is agnostic to the data-fetching layer, so you should provide it, or use a custom one.\n\nThe following options are available to use:\n\n- 'fetch' - requires you to specify endpoint and headers on each call, and uses `fetch` to do the actual http call.\n- `{ endpoint: string, fetchParams: RequestInit }`: hardcode your endpoint and fetch options into the generated output, using the environment `fetch` method. You can also use `process.env.MY_VAR` as endpoint or header value.\n- `file#identifier` - You can use custom fetcher method that should implement the exported `ReactQueryFetcher` interface. Example: `./my-fetcher#myCustomFetcher`.\n- `graphql-request`: Will generate each hook with `client` argument, where you should pass your own `GraphQLClient` (created from `graphql-request`).",
          "anyOf": [
            { "$ref": "#/definitions/HardcodedFetch" },
            { "type": "object", "properties": { "func": { "type": "string" }, "isReactHook": { "type": "boolean" } } },
            { "type": "string" }
          ]
        },
        "exposeDocument": {
          "description": "For each generate query hook adds `document` field with a\ncorresponding GraphQL query. Useful for `queryClient.fetchQuery`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "exposeQueryKeys": {
          "description": "For each generate query hook adds getKey(variables: QueryVariables) function. Useful for cache updates. If addInfiniteQuery is true, it will also add a getKey function to each infinite query.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "exposeMutationKeys": {
          "description": "For each generate mutation hook adds getKey() function. Useful for call outside of functional component.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "exposeFetcher": {
          "description": "For each generate query hook adds `fetcher` field with a corresponding GraphQL query using the fetcher.\nIt is useful for `queryClient.fetchQuery` and `queryClient.prefetchQuery`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "errorType": {
          "description": "Changes the default \"TError\" generic type.\nDefault value: \"unknown\"",
          "type": "string"
        },
        "addInfiniteQuery": {
          "description": "Adds an Infinite Query along side the standard one\nDefault value: \"false\"",
          "type": "boolean"
        },
        "legacyMode": {
          "description": "If false, it will work with `@tanstack/react-query`, default value is true.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally, you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserve underscores.\n\nAvailable case functions in `change-case-all` are `camelCase`, `capitalCase`, `constantCase`, `dotCase`, `headerCase`, `noCase`, `paramCase`, `pascalCase`, `pathCase`, `sentenceCase`, `snakeCase`, `lowerCase`, `localeLowerCase`, `lowerCaseFirst`, `spongeCase`, `titleCase`, `upperCase`, `localeUpperCase` and `upperCaseFirst`\n[See more](https://github.com/btxtiger/change-case-all)\nDefault value: \"change-case-all#pascalCase\""
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "documentVariablePrefix": {
          "description": "Changes the GraphQL operations variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariableSuffix": {
          "description": "Changes the GraphQL operations variables suffix.\nDefault value: \"Document\"",
          "type": "string"
        },
        "fragmentVariablePrefix": {
          "description": "Changes the GraphQL fragments variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "fragmentVariableSuffix": {
          "description": "Changes the GraphQL fragments variables suffix.\nDefault value: \"FragmentDoc\"",
          "type": "string"
        },
        "pureMagicComment": {
          "description": "This config adds PURE magic comment to the static variables to enforce treeshaking for your bundler.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "optimizeDocumentNode": {
          "description": "If you are using `documentNode: documentMode | documentNodeImportFragments`, you can set this to `true` to apply document optimizations for your GraphQL document.\nThis will remove all \"loc\" and \"description\" fields from the compiled document, and will remove all empty arrays (such as `directives`, `arguments` and `variableDefinitions`).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "experimentalFragmentVariables": {
          "description": "If set to true, it will enable support for parsing variables on fragments.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "typesPrefix": { "description": "Prefixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "typesSuffix": { "description": "Suffixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "inlineFragmentTypes": {
          "description": "Whether fragment types should be inlined into other operations.\n\"inline\" is the default behavior and will perform deep inlining fragment types within operation type definitions.\n\"combine\" is the previous behavior that uses fragment type references without inlining the types (and might cause issues with deeply nested fragment that uses list types).\nDefault value: \"inline\"",
          "type": "string"
        },
        "emitLegacyCommonJSImports": {
          "description": "Emit legacy common js imports.\nDefault it will be `true` this way it ensure that generated code works with [non-compliant bundlers](https://github.com/dotansimha/graphql-code-generator/issues/8065).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "strictScalars": {
          "description": "Makes scalars strict.\n\nIf scalars are found in the schema that are not defined in `scalars`\nan error will be thrown during codegen.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "defaultScalarType": {
          "description": "Allows you to override the type that unknown scalars will have.\nDefault value: \"any\"",
          "type": "string"
        },
        "skipTypename": {
          "description": "Does not add `__typename` to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "dedupeFragments": {
          "description": "Removes fragment duplicates for reducing data transfer.\nIt is done by removing sub-fragments imports from fragment definition\nInstead - all of them are imported to the Operation node.\nDefault value: \"false\"",
          "type": "boolean"
        }
      }
    },
    "RTKConfig": {
      "type": "object",
      "properties": {
        "importBaseApiFrom": {
          "description": "Define where to import the base api to inject endpoints into",
          "type": "string"
        },
        "importBaseApiAlternateName": {
          "description": "Change the import name of the baseApi from default 'api'\nDefault value: \"'api'\"",
          "type": "string"
        },
        "exportHooks": {
          "description": "Whether to export React Hooks from the generated api. Enable only when using the `\"@reduxjs/toolkit/query/react\"` import of `createApi`\nDefault value: \"false\"",
          "type": "boolean"
        },
        "overrideExisting": {
          "description": "Sets the `overrideExisting` option, for example to allow for hot module reloading when running graphql-codegen in watch mode.\nWill directly be injected as code.\nDefault value: \"undefined\"",
          "type": "string"
        }
      }
    },
    "RawGenericSdkPluginConfig": {
      "description": "This plugin generate a generic SDK (without any Requester implemented), allow you to easily customize the way you fetch your data, without loosing the strongly-typed integration.",
      "type": "object",
      "properties": {
        "usingObservableFrom": {
          "description": "usingObservableFrom: `import Observable from 'zen-observable'`\nOR\nusingObservableFrom: `import { Observable } from 'rxjs'`",
          "type": "string"
        },
        "rawRequest": {
          "description": "By default the `request` method return the `data` or `errors` key from the response. If you need to access the `extensions` key you can use the `rawRequest` method.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "noGraphQLTag": {
          "description": "Deprecated. Changes the documentMode to `documentNode`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "gqlImport": {
          "description": "Customize from which module will `gql` be imported from.\nThis is useful if you want to use modules other than `graphql-tag`, e.g. `graphql.macro`.\nDefault value: \"graphql-tag#gql\"",
          "type": "string"
        },
        "documentNodeImport": {
          "description": "Customize from which module will `DocumentNode` be imported from.\nThis is useful if you want to use modules other than `graphql`, e.g. `@graphql-typed-document-node`.\nDefault value: \"graphql#DocumentNode\"",
          "type": "string"
        },
        "noExport": {
          "description": "Set this configuration to `true` if you wish to tell codegen to generate code with no `export` identifier.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariablePrefix": {
          "description": "Changes the GraphQL operations variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariableSuffix": {
          "description": "Changes the GraphQL operations variables suffix.\nDefault value: \"Document\"",
          "type": "string"
        },
        "fragmentVariablePrefix": {
          "description": "Changes the GraphQL fragments variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "fragmentVariableSuffix": {
          "description": "Changes the GraphQL fragments variables suffix.\nDefault value: \"FragmentDoc\"",
          "type": "string"
        },
        "documentMode": {
          "$ref": "#/definitions/DocumentMode",
          "description": "Declares how DocumentNode are created:\n\n- `graphQLTag`: `graphql-tag` or other modules (check `gqlImport`) will be used to generate document nodes. If this is used, document nodes are generated on client side i.e. the module used to generate this will be shipped to the client\n- `documentNode`: document nodes will be generated as objects when we generate the templates.\n- `documentNodeImportFragments`: Similar to documentNode except it imports external fragments instead of embedding them.\n- `external`: document nodes are imported from an external file. To be used with `importDocumentNodeExternallyFrom`\n\nNote that some plugins (like `typescript-graphql-request`) also supports `string` for this parameter.\nDefault value: \"graphQLTag\""
        },
        "optimizeDocumentNode": {
          "description": "If you are using `documentNode: documentMode | documentNodeImportFragments`, you can set this to `true` to apply document optimizations for your GraphQL document.\nThis will remove all \"loc\" and \"description\" fields from the compiled document, and will remove all empty arrays (such as `directives`, `arguments` and `variableDefinitions`).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "importOperationTypesFrom": {
          "description": "This config is used internally by presets, but you can use it manually to tell codegen to prefix all base types that it's using.\nThis is useful if you wish to generate base types from `typescript-operations` plugin into a different file, and import it from there.\nDefault value: \"\"",
          "type": "string"
        },
        "importDocumentNodeExternallyFrom": {
          "description": "This config should be used if `documentMode` is `external`. This has 2 usage:\n\n- any string: This would be the path to import document nodes from. This can be used if we want to manually create the document nodes e.g. Use `graphql-tag` in a separate file and export the generated document\n- 'near-operation-file': This is a special mode that is intended to be used with `near-operation-file` preset to import document nodes from those files. If these files are `.graphql` files, we make use of webpack loader.\nDefault value: \"\"",
          "type": "string"
        },
        "pureMagicComment": {
          "description": "This config adds PURE magic comment to the static variables to enforce treeshaking for your bundler.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "experimentalFragmentVariables": {
          "description": "If set to true, it will enable support for parsing variables on fragments.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "strictScalars": {
          "description": "Makes scalars strict.\n\nIf scalars are found in the schema that are not defined in `scalars`\nan error will be thrown during codegen.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "defaultScalarType": {
          "description": "Allows you to override the type that unknown scalars will have.\nDefault value: \"any\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally, you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserve underscores.\n\nAvailable case functions in `change-case-all` are `camelCase`, `capitalCase`, `constantCase`, `dotCase`, `headerCase`, `noCase`, `paramCase`, `pascalCase`, `pathCase`, `sentenceCase`, `snakeCase`, `lowerCase`, `localeLowerCase`, `lowerCaseFirst`, `spongeCase`, `titleCase`, `upperCase`, `localeUpperCase` and `upperCaseFirst`\n[See more](https://github.com/btxtiger/change-case-all)\nDefault value: \"change-case-all#pascalCase\""
        },
        "typesPrefix": { "description": "Prefixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "typesSuffix": { "description": "Suffixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "skipTypename": {
          "description": "Does not add `__typename` to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "dedupeFragments": {
          "description": "Removes fragment duplicates for reducing data transfer.\nIt is done by removing sub-fragments imports from fragment definition\nInstead - all of them are imported to the Operation node.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "inlineFragmentTypes": {
          "description": "Whether fragment types should be inlined into other operations.\n\"inline\" is the default behavior and will perform deep inlining fragment types within operation type definitions.\n\"combine\" is the previous behavior that uses fragment type references without inlining the types (and might cause issues with deeply nested fragment that uses list types).\nDefault value: \"inline\"",
          "type": "string"
        },
        "emitLegacyCommonJSImports": {
          "description": "Emit legacy common js imports.\nDefault it will be `true` this way it ensure that generated code works with [non-compliant bundlers](https://github.com/dotansimha/graphql-code-generator/issues/8065).\nDefault value: \"true\"",
          "type": "boolean"
        }
      }
    },
    "ApolloClientHelpersConfig": {
      "type": "object",
      "properties": {
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "requireKeyFields": {
          "type": "boolean",
          "description": "Remove optional sign from all `keyFields` fields.\nDefault value: \"false\""
        },
        "requirePoliciesForAllTypes": {
          "type": "boolean",
          "description": "Remove optional sign from all generated keys of the root TypePolicy.\nDefault value: \"false\""
        }
      }
    },
    "AddPluginConfig": {
      "type": "object",
      "properties": {
        "placement": {
          "description": "Allow you to choose where to add the content.\nDefault value: \"prepend\"",
          "enum": ["append", "content", "prepend"],
          "type": "string"
        },
        "content": {
          "description": "The actual content you wish to add, either a string or array of strings.\nYou can also specify a path to a local file and the content if it will be loaded by codegen.",
          "anyOf": [{ "type": "array", "items": { "type": "string" } }, { "type": "string" }]
        }
      }
    },
    "TimePluginConfig": {
      "type": "object",
      "properties": {
        "format": {
          "description": "Customize the Moment format of the output time.\nDefault value: \"YYYY-MM-DDTHH:mm:ssZ\"",
          "type": "string"
        },
        "message": {
          "description": "Customize the comment message\nDefault value: \"'Generated on'\"",
          "type": "string"
        }
      }
    },
    "TypeScriptPluginConfig": {
      "description": "This plugin generates the base TypeScript types, based on your GraphQL schema.\n\nThe types generated by this plugin are simple, and refers to the exact structure of your schema, and it's used as the base types for other plugins (such as `typescript-operations` / `typescript-resolvers`)",
      "type": "object",
      "properties": {
        "avoidOptionals": {
          "description": "This will cause the generator to avoid using TypeScript optionals (`?`) on types,\nso the following definition: `type A { myField: String }` will output `myField: Maybe<string>`\ninstead of `myField?: Maybe<string>`.\nDefault value: \"false\"",
          "anyOf": [{ "$ref": "#/definitions/AvoidOptionalsConfig" }, { "type": "boolean" }]
        },
        "constEnums": {
          "description": "Will prefix every generated `enum` with `const`, you can read more about const enums here: https://www.typescriptlang.org/docs/handbook/enums.html.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "enumsAsTypes": {
          "description": "Generates enum as TypeScript string union `type` instead of an `enum`. Useful if you wish to generate `.d.ts` declaration file instead of `.ts`, or if you want to avoid using TypeScript enums due to bundle size concerns\nDefault value: \"false\"",
          "type": "boolean"
        },
        "numericEnums": {
          "description": "Controls whether to preserve typescript enum values as numbers\nDefault value: \"false\"",
          "type": "boolean"
        },
        "futureProofEnums": {
          "description": "This option controls whether or not a catch-all entry is added to enum type definitions for values that may be added in the future.\nThis is useful if you are using `relay`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "futureProofUnions": {
          "description": "This option controls whether or not a catch-all entry is added to union type definitions for values that may be added in the future.\nThis is useful if you are using `relay`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "enumsAsConst": {
          "description": "Generates enum as TypeScript `const assertions` instead of `enum`. This can even be used to enable enum-like patterns in plain JavaScript code if you choose not to use TypeScriptâ€™s enum construct.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "onlyEnums": {
          "description": "This will cause the generator to emit types for enums only.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "onlyOperationTypes": {
          "description": "This will cause the generator to emit types for operations only (basically only enums and scalars).\nInteracts well with `preResolveTypes: true`\nDefault value: \"false\"",
          "type": "boolean"
        },
        "immutableTypes": {
          "description": "Generates immutable types by adding `readonly` to properties and uses `ReadonlyArray`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "maybeValue": {
          "description": "Allow to override the type value of `Maybe`.\nDefault value: \"T | null\"",
          "type": "string"
        },
        "inputMaybeValue": {
          "description": "Allow to override the type value of `Maybe` for input types and arguments.\nThis is useful in case you want to differentiate between the wrapper of input and output types.\nBy default, this type just refers to `Maybe` type, but you can override its definition.\nDefault value: \"Maybe<T>\"",
          "type": "string"
        },
        "noExport": {
          "description": "Set to `true` in order to generate output without `export` modifier.\nThis is useful if you are generating `.d.ts` file and want it to be globally available.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "disableDescriptions": {
          "description": "Set the value to `true` in order to disable all description generation.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useImplementingTypes": {
          "description": "When a GraphQL interface is used for a field, this flag will use the implementing types, instead of the interface itself.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "wrapEntireFieldDefinitions": {
          "type": "boolean",
          "description": "Set to `true` in order to wrap field definitions with `EntireFieldWrapper`.\nThis is useful to allow return types such as Promises and functions for fields.\nDiffers from `wrapFieldDefinitions` in that this wraps the entire field definition if i.e. the field is an Array, while\n`wrapFieldDefinitions` will wrap every single value inside the array.\nDefault value: \"false\""
        },
        "entireFieldWrapperValue": {
          "type": "string",
          "description": "Allow to override the type value of `EntireFieldWrapper`. This wrapper applies outside of Array and Maybe\nunlike `fieldWrapperValue`, that will wrap the inner type.\nDefault value: \"T | Promise<T> | (() => T | Promise<T>)\""
        },
        "allowEnumStringTypes": { "description": "Allow using enum string values directly.", "type": "boolean" },
        "addUnderscoreToArgsType": {
          "description": "Adds `_` to generated `Args` types in order to avoid duplicate identifiers.",
          "type": "boolean"
        },
        "enumValues": {
          "$ref": "#/definitions/EnumValuesMap",
          "description": "Overrides the default value of enum values declared in your GraphQL schema.\nYou can also map the entire enum to an external type by providing a string that of `module#type`."
        },
        "declarationKind": {
          "description": "Overrides the default output for various GraphQL elements.",
          "anyOf": [
            { "$ref": "#/definitions/DeclarationKindConfig" },
            { "enum": ["abstract class", "class", "interface", "type"], "type": "string" }
          ]
        },
        "enumPrefix": {
          "description": "Allow you to disable prefixing for generated enums, works in combination with `typesPrefix`.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "enumSuffix": {
          "description": "Allow you to disable suffixing for generated enums, works in combination with `typesSuffix`.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "fieldWrapperValue": {
          "description": "Allow you to add wrapper for field type, use T as the generic value. Make sure to set `wrapFieldDefinitions` to `true` in order to make this flag work.\nDefault value: \"T\"",
          "type": "string"
        },
        "wrapFieldDefinitions": {
          "description": "Set to `true` in order to wrap field definitions with `FieldWrapper`.\nThis is useful to allow return types such as Promises and functions.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "ignoreEnumValuesFromSchema": {
          "description": "This will cause the generator to ignore enum values defined in GraphQLSchema\nDefault value: \"false\"",
          "type": "boolean"
        },
        "directiveArgumentAndInputFieldMappings": {
          "$ref": "#/definitions/DirectiveArgumentAndInputFieldMappings",
          "description": "Replaces a GraphQL scalar with a custom type based on the applied directive on an argument or input field.\n\nYou can use both `module#type` and `module#namespace#type` syntax.\nWill NOT work with introspected schemas since directives are not exported.\nOnly works with directives on ARGUMENT_DEFINITION or INPUT_FIELD_DEFINITION.\n\n**WARNING:** Using this option does only change the type definitions.\n\nFor actually ensuring that a type is correct at runtime you will have to use schema transforms (e.g. with [@graphql-tools/utils mapSchema](https://graphql-tools.com/docs/schema-directives)) that apply those rules!\nOtherwise, you might end up with a runtime type mismatch which could cause unnoticed bugs or runtime errors.\n\nPlease use this configuration option with care!"
        },
        "directiveArgumentAndInputFieldMappingTypeSuffix": {
          "description": "Adds a suffix to the imported names to prevent name clashes.",
          "type": "string"
        },
        "strictScalars": {
          "description": "Makes scalars strict.\n\nIf scalars are found in the schema that are not defined in `scalars`\nan error will be thrown during codegen.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "defaultScalarType": {
          "description": "Allows you to override the type that unknown scalars will have.\nDefault value: \"any\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap_1",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention_1",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally, you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserve underscores.\n\nAvailable case functions in `change-case-all` are `camelCase`, `capitalCase`, `constantCase`, `dotCase`, `headerCase`, `noCase`, `paramCase`, `pascalCase`, `pathCase`, `sentenceCase`, `snakeCase`, `lowerCase`, `localeLowerCase`, `lowerCaseFirst`, `spongeCase`, `titleCase`, `upperCase`, `localeUpperCase` and `upperCaseFirst`\n[See more](https://github.com/btxtiger/change-case-all)\nDefault value: \"change-case-all#pascalCase\""
        },
        "typesPrefix": { "description": "Prefixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "typesSuffix": { "description": "Suffixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "skipTypename": {
          "description": "Does not add `__typename` to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "inlineFragmentTypes": {
          "description": "Whether fragment types should be inlined into other operations.\n\"inline\" is the default behavior and will perform deep inlining fragment types within operation type definitions.\n\"combine\" is the previous behavior that uses fragment type references without inlining the types (and might cause issues with deeply nested fragment that uses list types).\n\"mask\" transforms the types for use with fragment masking. Useful when masked types are needed when not using the \"client\" preset e.g. such as combining it with Apollo Client's data masking feature.\nDefault value: \"inline\"",
          "type": "string"
        },
        "emitLegacyCommonJSImports": {
          "description": "Emit legacy common js imports.\nDefault it will be `true` this way it ensure that generated code works with [non-compliant bundlers](https://github.com/dotansimha/graphql-code-generator/issues/8065).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "importExtension": {
          "description": "Append this extension to all imports.\nUseful for ESM environments that require file extensions in import statements.",
          "type": "string"
        },
        "extractAllFieldsToTypes": {
          "description": "Extract all field types to their own types, instead of inlining them.\nThis helps to reduce type duplication, and makes type errors more readable.\nIt can also significantly reduce the size of the generated code, the generation time,\nand the typechecking time.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "printFieldsOnNewLines": {
          "description": "If you prefer to have each field in generated types printed on a new line, set this to true.\nThis can be useful for improving readability of the resulting types,\nwithout resorting to running tools like Prettier on the output.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "includeExternalFragments": {
          "description": "Whether to include external fragments in the generated code. External fragments are not defined\nin the same location as the operation definition.\nDefault value: \"false\"",
          "type": "boolean"
        }
      }
    },
    "TypeScriptDocumentsPluginConfig": {
      "description": "This plugin generates TypeScript types based on your GraphQLSchema _and_ your GraphQL operations and fragments.\nIt generates types for your GraphQL documents: Query, Mutation, Subscription and Fragment.\n\nNote: In most configurations, this plugin requires you to use `typescript as well, because it depends on its base types.",
      "type": "object",
      "properties": {
        "arrayInputCoercion": {
          "description": "The [GraphQL spec](https://spec.graphql.org/draft/#sel-FAHjBJFCAACE_Gh7d)\nallows arrays and a single primitive value for list input. This allows to\ndeactivate that behavior to only accept arrays instead of single values. If\nset to `false`, the definition: `query foo(bar: [Int!]!): Foo` will output\n`bar: Array<Int>` instead of `bar: Array<Int> | Int` for the variable part.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "avoidOptionals": {
          "description": "This will cause the generator to avoid using TypeScript optionals (`?`) on types,\nso the following definition: `type A { myField: String }` will output `myField: Maybe<string>`\ninstead of `myField?: Maybe<string>`.\nDefault value: \"false\"",
          "anyOf": [{ "$ref": "#/definitions/AvoidOptionalsConfig" }, { "type": "boolean" }]
        },
        "immutableTypes": {
          "description": "Generates immutable types by adding `readonly` to properties and uses `ReadonlyArray`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "flattenGeneratedTypes": {
          "description": "Flatten fragment spread and inline fragments into a simple selection set before generating.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "flattenGeneratedTypesIncludeFragments": {
          "description": "Include all fragments types when flattenGeneratedTypes is enabled.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "noExport": {
          "description": "Set to `true` in order to generate output without `export` modifier.\nThis is useful if you are generating `.d.ts` file and want it to be globally available.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "globalNamespace": { "type": "boolean" },
        "addOperationExport": {
          "type": "boolean",
          "description": "Add const export of the operation name to output file. Pay attention that the file should be `d.ts`.\nYou can combine it with `near-operation-file preset` and therefore the types will be generated along with graphql file. Then you need to set extension in `presetConfig` to be `.gql.d.ts` and by that you can import `gql` file in `ts` files.\nIt will allow you to get everything with one import:\n\n```ts\nimport { GetClient, GetClientQuery, GetClientQueryVariables } from './GetClient.gql.js'\n```\nDefault value: \"false\""
        },
        "maybeValue": {
          "description": "Allow to override the type value of `Maybe`.\nDefault value: \"T | null\"",
          "type": "string"
        },
        "allowUndefinedQueryVariables": {
          "description": "Adds undefined as a possible type for query variables\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nullability": {
          "description": "Options related to handling nullability",
          "type": "object",
          "properties": { "errorHandlingClient": { "type": "boolean" } }
        },
        "preResolveTypes": {
          "description": "Uses primitive types where possible.\nSet to `false` in order to use `Pick` and take use the types generated by `typescript` plugin.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "skipTypeNameForRoot": {
          "description": "Avoid adding `__typename` for root types. This is ignored when a selection explicitly specifies `__typename`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "exportFragmentSpreadSubTypes": {
          "description": "If set to true, it will export the sub-types created in order to make it easier to access fields declared under fragment spread.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "experimentalFragmentVariables": {
          "description": "If set to true, it will enable support for parsing variables on fragments.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "mergeFragmentTypes": {
          "description": "If set to true, merge equal fragment interfaces.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "customDirectives": {
          "$ref": "#/definitions/CustomDirectivesConfig",
          "description": "Configures behavior for use with custom directives from\nvarious GraphQL libraries."
        },
        "addUnderscoreToArgsType": {
          "description": "Adds `_` to generated `Args` types in order to avoid duplicate identifiers.",
          "type": "boolean"
        },
        "enumValues": {
          "$ref": "#/definitions/EnumValuesMap",
          "description": "Overrides the default value of enum values declared in your GraphQL schema.\nYou can also map the entire enum to an external type by providing a string that of `module#type`."
        },
        "declarationKind": {
          "description": "Overrides the default output for various GraphQL elements.",
          "anyOf": [
            { "$ref": "#/definitions/DeclarationKindConfig" },
            { "enum": ["abstract class", "class", "interface", "type"], "type": "string" }
          ]
        },
        "enumPrefix": {
          "description": "Allow you to disable prefixing for generated enums, works in combination with `typesPrefix`.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "enumSuffix": {
          "description": "Allow you to disable suffixing for generated enums, works in combination with `typesSuffix`.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "fieldWrapperValue": {
          "description": "Allow you to add wrapper for field type, use T as the generic value. Make sure to set `wrapFieldDefinitions` to `true` in order to make this flag work.\nDefault value: \"T\"",
          "type": "string"
        },
        "wrapFieldDefinitions": {
          "description": "Set to `true` in order to wrap field definitions with `FieldWrapper`.\nThis is useful to allow return types such as Promises and functions.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "onlyEnums": {
          "description": "This will cause the generator to emit types for enums only\nDefault value: \"false\"",
          "type": "boolean"
        },
        "onlyOperationTypes": {
          "description": "This will cause the generator to emit types for operations only (basically only enums and scalars)\nDefault value: \"false\"",
          "type": "boolean"
        },
        "ignoreEnumValuesFromSchema": {
          "description": "This will cause the generator to ignore enum values defined in GraphQLSchema\nDefault value: \"false\"",
          "type": "boolean"
        },
        "wrapEntireFieldDefinitions": {
          "type": "boolean",
          "description": "Set to `true` in order to wrap field definitions with `EntireFieldWrapper`.\nThis is useful to allow return types such as Promises and functions for fields.\nDiffers from `wrapFieldDefinitions` in that this wraps the entire field definition if i.e. the field is an Array, while\n`wrapFieldDefinitions` will wrap every single value inside the array.\nDefault value: \"true\""
        },
        "entireFieldWrapperValue": {
          "type": "string",
          "description": "Allow to override the type value of `EntireFieldWrapper`. This wrapper applies outside of Array and Maybe\nunlike `fieldWrapperValue`, that will wrap the inner type.\nDefault value: \"T | Promise<T> | (() => T | Promise<T>)\""
        },
        "directiveArgumentAndInputFieldMappings": {
          "$ref": "#/definitions/DirectiveArgumentAndInputFieldMappings",
          "description": "Replaces a GraphQL scalar with a custom type based on the applied directive on an argument or input field.\n\nYou can use both `module#type` and `module#namespace#type` syntax.\nWill NOT work with introspected schemas since directives are not exported.\nOnly works with directives on ARGUMENT_DEFINITION or INPUT_FIELD_DEFINITION.\n\n**WARNING:** Using this option does only change the type definitions.\n\nFor actually ensuring that a type is correct at runtime you will have to use schema transforms (e.g. with [@graphql-tools/utils mapSchema](https://graphql-tools.com/docs/schema-directives)) that apply those rules!\nOtherwise, you might end up with a runtime type mismatch which could cause unnoticed bugs or runtime errors.\n\nPlease use this configuration option with care!"
        },
        "directiveArgumentAndInputFieldMappingTypeSuffix": {
          "description": "Adds a suffix to the imported names to prevent name clashes.",
          "type": "string"
        },
        "strictScalars": {
          "description": "Makes scalars strict.\n\nIf scalars are found in the schema that are not defined in `scalars`\nan error will be thrown during codegen.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "defaultScalarType": {
          "description": "Allows you to override the type that unknown scalars will have.\nDefault value: \"any\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap_1",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention_1",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally, you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserve underscores.\n\nAvailable case functions in `change-case-all` are `camelCase`, `capitalCase`, `constantCase`, `dotCase`, `headerCase`, `noCase`, `paramCase`, `pascalCase`, `pathCase`, `sentenceCase`, `snakeCase`, `lowerCase`, `localeLowerCase`, `lowerCaseFirst`, `spongeCase`, `titleCase`, `upperCase`, `localeUpperCase` and `upperCaseFirst`\n[See more](https://github.com/btxtiger/change-case-all)\nDefault value: \"change-case-all#pascalCase\""
        },
        "typesPrefix": { "description": "Prefixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "typesSuffix": { "description": "Suffixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "skipTypename": {
          "description": "Does not add `__typename` to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "inlineFragmentTypes": {
          "description": "Whether fragment types should be inlined into other operations.\n\"inline\" is the default behavior and will perform deep inlining fragment types within operation type definitions.\n\"combine\" is the previous behavior that uses fragment type references without inlining the types (and might cause issues with deeply nested fragment that uses list types).\n\"mask\" transforms the types for use with fragment masking. Useful when masked types are needed when not using the \"client\" preset e.g. such as combining it with Apollo Client's data masking feature.\nDefault value: \"inline\"",
          "type": "string"
        },
        "emitLegacyCommonJSImports": {
          "description": "Emit legacy common js imports.\nDefault it will be `true` this way it ensure that generated code works with [non-compliant bundlers](https://github.com/dotansimha/graphql-code-generator/issues/8065).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "importExtension": {
          "description": "Append this extension to all imports.\nUseful for ESM environments that require file extensions in import statements.",
          "type": "string"
        },
        "extractAllFieldsToTypes": {
          "description": "Extract all field types to their own types, instead of inlining them.\nThis helps to reduce type duplication, and makes type errors more readable.\nIt can also significantly reduce the size of the generated code, the generation time,\nand the typechecking time.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "printFieldsOnNewLines": {
          "description": "If you prefer to have each field in generated types printed on a new line, set this to true.\nThis can be useful for improving readability of the resulting types,\nwithout resorting to running tools like Prettier on the output.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "includeExternalFragments": {
          "description": "Whether to include external fragments in the generated code. External fragments are not defined\nin the same location as the operation definition.\nDefault value: \"false\"",
          "type": "boolean"
        }
      }
    },
    "CSharpResolversPluginRawConfig": {
      "description": "This plugin generates C# `class` identifier for your schema types.",
      "type": "object",
      "properties": {
        "enumValues": {
          "$ref": "#/definitions/EnumValuesMap_1",
          "description": "Overrides the default value of enum values declared in your GraphQL schema."
        },
        "namespaceName": {
          "description": "Allow you to customize the namespace name.\nDefault value: \"GraphQLCodeGen\"",
          "type": "string"
        },
        "className": {
          "description": "Allow you to customize the parent class name.\nDefault value: \"Types\"",
          "type": "string"
        },
        "listType": {
          "description": "Allow you to customize the list type\nDefault value: \"IEnumerable\"",
          "type": "string"
        },
        "emitRecords": {
          "description": "Emit C# 9.0+ records instead of classes\nDefault value: \"false\"",
          "type": "boolean"
        },
        "emitJsonAttributes": {
          "description": "Should JSON attributes be emitted for produced types and properties ot not\nDefault value: \"true\"",
          "type": "boolean"
        },
        "jsonAttributesSource": {
          "$ref": "#/definitions/JsonAttributesSource",
          "description": "Library that should be used to emit JSON attributes. Ignored when `emitJsonAttributes` is `false` or not specified\nDefault value: \"Newtonsoft.Json\""
        },
        "strictScalars": {
          "description": "Makes scalars strict.\n\nIf scalars are found in the schema that are not defined in `scalars`\nan error will be thrown during codegen.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "defaultScalarType": {
          "description": "Allows you to override the type that unknown scalars will have.\nDefault value: \"any\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap_2",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention_2",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally, you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserve underscores.\n\nAvailable case functions in `change-case-all` are `camelCase`, `capitalCase`, `constantCase`, `dotCase`, `headerCase`, `noCase`, `paramCase`, `pascalCase`, `pathCase`, `sentenceCase`, `snakeCase`, `lowerCase`, `localeLowerCase`, `lowerCaseFirst`, `spongeCase`, `titleCase`, `upperCase`, `localeUpperCase` and `upperCaseFirst`\n[See more](https://github.com/btxtiger/change-case-all)\nDefault value: \"change-case-all#pascalCase\""
        },
        "typesPrefix": { "description": "Prefixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "typesSuffix": { "description": "Suffixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "skipTypename": {
          "description": "Does not add `__typename` to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "dedupeFragments": {
          "description": "Removes fragment duplicates for reducing data transfer.\nIt is done by removing sub-fragments imports from fragment definition\nInstead - all of them are imported to the Operation node.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "inlineFragmentTypes": {
          "description": "Whether fragment types should be inlined into other operations.\n\"inline\" is the default behavior and will perform deep inlining fragment types within operation type definitions.\n\"combine\" is the previous behavior that uses fragment type references without inlining the types (and might cause issues with deeply nested fragment that uses list types).\nDefault value: \"inline\"",
          "type": "string"
        },
        "emitLegacyCommonJSImports": {
          "description": "Emit legacy common js imports.\nDefault it will be `true` this way it ensure that generated code works with [non-compliant bundlers](https://github.com/dotansimha/graphql-code-generator/issues/8065).\nDefault value: \"true\"",
          "type": "boolean"
        }
      }
    },
    "CSharpOperationsRawPluginConfig": {
      "description": "This plugin generates C# `class` based on your GraphQL operations.",
      "type": "object",
      "properties": {
        "namespaceName": {
          "description": "Allow you to customize the namespace name.\nDefault value: \"GraphQLCodeGen\"",
          "type": "string"
        },
        "namedClient": { "description": "Defined the global value of `namedClient`.", "type": "string" },
        "querySuffix": {
          "description": "Allows to define a custom suffix for query operations.\nDefault value: \"GQL\"",
          "type": "string"
        },
        "mutationSuffix": {
          "description": "Allows to define a custom suffix for mutation operations.\nDefault value: \"GQL\"",
          "type": "string"
        },
        "subscriptionSuffix": {
          "description": "Allows to define a custom suffix for Subscription operations.\nDefault value: \"GQL\"",
          "type": "string"
        },
        "typesafeOperation": {
          "description": "Allows to generate operation methods with class definitions for request/response parameters\nDefault value: \"false\"",
          "type": "boolean"
        },
        "noGraphQLTag": {
          "description": "Deprecated. Changes the documentMode to `documentNode`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "gqlImport": {
          "description": "Customize from which module will `gql` be imported from.\nThis is useful if you want to use modules other than `graphql-tag`, e.g. `graphql.macro`.\nDefault value: \"graphql-tag#gql\"",
          "type": "string"
        },
        "documentNodeImport": {
          "description": "Customize from which module will `DocumentNode` be imported from.\nThis is useful if you want to use modules other than `graphql`, e.g. `@graphql-typed-document-node`.\nDefault value: \"graphql#DocumentNode\"",
          "type": "string"
        },
        "noExport": {
          "description": "Set this configuration to `true` if you wish to tell codegen to generate code with no `export` identifier.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariablePrefix": {
          "description": "Changes the GraphQL operations variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariableSuffix": {
          "description": "Changes the GraphQL operations variables suffix.\nDefault value: \"Document\"",
          "type": "string"
        },
        "fragmentVariablePrefix": {
          "description": "Changes the GraphQL fragments variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "fragmentVariableSuffix": {
          "description": "Changes the GraphQL fragments variables suffix.\nDefault value: \"FragmentDoc\"",
          "type": "string"
        },
        "documentMode": {
          "$ref": "#/definitions/DocumentMode_1",
          "description": "Declares how DocumentNode are created:\n\n- `graphQLTag`: `graphql-tag` or other modules (check `gqlImport`) will be used to generate document nodes. If this is used, document nodes are generated on client side i.e. the module used to generate this will be shipped to the client\n- `documentNode`: document nodes will be generated as objects when we generate the templates.\n- `documentNodeImportFragments`: Similar to documentNode except it imports external fragments instead of embedding them.\n- `external`: document nodes are imported from an external file. To be used with `importDocumentNodeExternallyFrom`\n\nNote that some plugins (like `typescript-graphql-request`) also supports `string` for this parameter.\nDefault value: \"graphQLTag\""
        },
        "optimizeDocumentNode": {
          "description": "If you are using `documentNode: documentMode | documentNodeImportFragments`, you can set this to `true` to apply document optimizations for your GraphQL document.\nThis will remove all \"loc\" and \"description\" fields from the compiled document, and will remove all empty arrays (such as `directives`, `arguments` and `variableDefinitions`).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "importOperationTypesFrom": {
          "description": "This config is used internally by presets, but you can use it manually to tell codegen to prefix all base types that it's using.\nThis is useful if you wish to generate base types from `typescript-operations` plugin into a different file, and import it from there.\nDefault value: \"\"",
          "type": "string"
        },
        "importDocumentNodeExternallyFrom": {
          "description": "This config should be used if `documentMode` is `external`. This has 2 usage:\n\n- any string: This would be the path to import document nodes from. This can be used if we want to manually create the document nodes e.g. Use `graphql-tag` in a separate file and export the generated document\n- 'near-operation-file': This is a special mode that is intended to be used with `near-operation-file` preset to import document nodes from those files. If these files are `.graphql` files, we make use of webpack loader.\nDefault value: \"\"",
          "type": "string"
        },
        "pureMagicComment": {
          "description": "This config adds PURE magic comment to the static variables to enforce treeshaking for your bundler.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "experimentalFragmentVariables": {
          "description": "If set to true, it will enable support for parsing variables on fragments.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "strictScalars": {
          "description": "Makes scalars strict.\n\nIf scalars are found in the schema that are not defined in `scalars`\nan error will be thrown during codegen.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "defaultScalarType": {
          "description": "Allows you to override the type that unknown scalars will have.\nDefault value: \"any\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap_2",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention_2",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally, you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserve underscores.\n\nAvailable case functions in `change-case-all` are `camelCase`, `capitalCase`, `constantCase`, `dotCase`, `headerCase`, `noCase`, `paramCase`, `pascalCase`, `pathCase`, `sentenceCase`, `snakeCase`, `lowerCase`, `localeLowerCase`, `lowerCaseFirst`, `spongeCase`, `titleCase`, `upperCase`, `localeUpperCase` and `upperCaseFirst`\n[See more](https://github.com/btxtiger/change-case-all)\nDefault value: \"change-case-all#pascalCase\""
        },
        "typesPrefix": { "description": "Prefixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "typesSuffix": { "description": "Suffixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "skipTypename": {
          "description": "Does not add `__typename` to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "dedupeFragments": {
          "description": "Removes fragment duplicates for reducing data transfer.\nIt is done by removing sub-fragments imports from fragment definition\nInstead - all of them are imported to the Operation node.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "inlineFragmentTypes": {
          "description": "Whether fragment types should be inlined into other operations.\n\"inline\" is the default behavior and will perform deep inlining fragment types within operation type definitions.\n\"combine\" is the previous behavior that uses fragment type references without inlining the types (and might cause issues with deeply nested fragment that uses list types).\nDefault value: \"inline\"",
          "type": "string"
        },
        "emitLegacyCommonJSImports": {
          "description": "Emit legacy common js imports.\nDefault it will be `true` this way it ensure that generated code works with [non-compliant bundlers](https://github.com/dotansimha/graphql-code-generator/issues/8065).\nDefault value: \"true\"",
          "type": "boolean"
        }
      }
    },
    "SchemaASTConfig": {
      "description": "This plugin prints the merged schema as string. If multiple schemas are provided, they will be merged and printed as one schema.",
      "type": "object",
      "properties": {
        "includeDirectives": {
          "description": "Include directives to Schema output.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "includeIntrospectionTypes": {
          "description": "Include introspection types to Schema output.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "commentDescriptions": {
          "description": "Set to true in order to print description as comments (using `#` instead of `\"\"\"`)\nDefault value: \"false\"",
          "type": "boolean"
        },
        "sort": { "description": "Set to false to disable sorting\nDefault value: \"true\"", "type": "boolean" },
        "federation": { "type": "boolean" }
      }
    },
    "TypeGraphQLPluginConfig": {
      "type": "object",
      "properties": {
        "decoratorName": {
          "$ref": "#/definitions/Partial_1",
          "description": "allow overriding of TypeGraphQL decorator types\nDefault value: \"{ type: 'ObjectType', interface: 'InterfaceType', arguments: 'ArgsType', field: 'Field', input: 'InputType' }\""
        },
        "decorateTypes": {
          "description": "Specifies the objects that will have TypeGraphQL decorators prepended to them, by name. Non-matching types will still be output, but without decorators. If not set, all types will be decorated.",
          "type": "array",
          "items": { "type": "string" }
        },
        "avoidOptionals": {
          "description": "This will cause the generator to avoid using TypeScript optionals (`?`) on types,\nso the following definition: `type A { myField: String }` will output `myField: Maybe<string>`\ninstead of `myField?: Maybe<string>`.\nDefault value: \"false\"",
          "anyOf": [{ "$ref": "#/definitions/AvoidOptionalsConfig_1" }, { "type": "boolean" }]
        },
        "constEnums": {
          "description": "Will prefix every generated `enum` with `const`, you can read more about const enums here: https://www.typescriptlang.org/docs/handbook/enums.html.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "enumsAsTypes": {
          "description": "Generates enum as TypeScript string union `type` instead of an `enum`. Useful if you wish to generate `.d.ts` declaration file instead of `.ts`, or if you want to avoid using TypeScript enums due to bundle size concerns\nDefault value: \"false\"",
          "type": "boolean"
        },
        "numericEnums": {
          "description": "Controls whether to preserve typescript enum values as numbers\nDefault value: \"false\"",
          "type": "boolean"
        },
        "futureProofEnums": {
          "description": "This option controls whether or not a catch-all entry is added to enum type definitions for values that may be added in the future.\nThis is useful if you are using `relay`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "futureProofUnions": {
          "description": "This option controls whether or not a catch-all entry is added to union type definitions for values that may be added in the future.\nThis is useful if you are using `relay`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "enumsAsConst": {
          "description": "Generates enum as TypeScript `const assertions` instead of `enum`. This can even be used to enable enum-like patterns in plain JavaScript code if you choose not to use TypeScriptâ€™s enum construct.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "onlyEnums": {
          "description": "This will cause the generator to emit types for enums only.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "onlyOperationTypes": {
          "description": "This will cause the generator to emit types for operations only (basically only enums and scalars).\nInteracts well with `preResolveTypes: true`\nDefault value: \"false\"",
          "type": "boolean"
        },
        "immutableTypes": {
          "description": "Generates immutable types by adding `readonly` to properties and uses `ReadonlyArray`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "maybeValue": {
          "description": "Allow to override the type value of `Maybe`.\nDefault value: \"T | null\"",
          "type": "string"
        },
        "inputMaybeValue": {
          "description": "Allow to override the type value of `Maybe` for input types and arguments.\nThis is useful in case you want to differentiate between the wrapper of input and output types.\nBy default, this type just refers to `Maybe` type, but you can override its definition.\nDefault value: \"Maybe<T>\"",
          "type": "string"
        },
        "noExport": {
          "description": "Set to `true` in order to generate output without `export` modifier.\nThis is useful if you are generating `.d.ts` file and want it to be globally available.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "disableDescriptions": {
          "description": "Set the value to `true` in order to disable all description generation.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useImplementingTypes": {
          "description": "When a GraphQL interface is used for a field, this flag will use the implementing types, instead of the interface itself.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "wrapEntireFieldDefinitions": {
          "type": "boolean",
          "description": "Set to `true` in order to wrap field definitions with `EntireFieldWrapper`.\nThis is useful to allow return types such as Promises and functions for fields.\nDiffers from `wrapFieldDefinitions` in that this wraps the entire field definition if i.e. the field is an Array, while\n`wrapFieldDefinitions` will wrap every single value inside the array.\nDefault value: \"false\""
        },
        "entireFieldWrapperValue": {
          "type": "string",
          "description": "Allow to override the type value of `EntireFieldWrapper`. This wrapper applies outside of Array and Maybe\nunlike `fieldWrapperValue`, that will wrap the inner type.\nDefault value: \"T | Promise<T> | (() => T | Promise<T>)\""
        },
        "allowEnumStringTypes": { "description": "Allow using enum string values directly.", "type": "boolean" },
        "addUnderscoreToArgsType": {
          "description": "Adds `_` to generated `Args` types in order to avoid duplicate identifiers.",
          "type": "boolean"
        },
        "enumValues": {
          "$ref": "#/definitions/EnumValuesMap_1",
          "description": "Overrides the default value of enum values declared in your GraphQL schema.\nYou can also map the entire enum to an external type by providing a string that of `module#type`."
        },
        "declarationKind": {
          "description": "Overrides the default output for various GraphQL elements.",
          "anyOf": [
            { "$ref": "#/definitions/DeclarationKindConfig_1" },
            { "enum": ["abstract class", "class", "interface", "type"], "type": "string" }
          ]
        },
        "enumPrefix": {
          "description": "Allow you to disable prefixing for generated enums, works in combination with `typesPrefix`.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "fieldWrapperValue": {
          "description": "Allow you to add wrapper for field type, use T as the generic value. Make sure to set `wrapFieldDefinitions` to `true` in order to make this flag work.\nDefault value: \"T\"",
          "type": "string"
        },
        "wrapFieldDefinitions": {
          "description": "Set to `true` in order to wrap field definitions with `FieldWrapper`.\nThis is useful to allow return types such as Promises and functions.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "ignoreEnumValuesFromSchema": {
          "description": "This will cause the generator to ignore enum values defined in GraphQLSchema\nDefault value: \"false\"",
          "type": "boolean"
        },
        "directiveArgumentAndInputFieldMappings": {
          "$ref": "#/definitions/DirectiveArgumentAndInputFieldMappings_1",
          "description": "Replaces a GraphQL scalar with a custom type based on the applied directive on an argument or input field.\n\nYou can use both `module#type` and `module#namespace#type` syntax.\nWill NOT work with introspected schemas since directives are not exported.\nOnly works with directives on ARGUMENT_DEFINITION or INPUT_FIELD_DEFINITION.\n\n**WARNING:** Using this option does only change the type definitions.\n\nFor actually ensuring that a type is correct at runtime you will have to use schema transforms (e.g. with [@graphql-tools/utils mapSchema](https://graphql-tools.com/docs/schema-directives)) that apply those rules!\nOtherwise, you might end up with a runtime type mismatch which could cause unnoticed bugs or runtime errors.\n\nPlease use this configuration option with care!"
        },
        "directiveArgumentAndInputFieldMappingTypeSuffix": {
          "description": "Adds a suffix to the imported names to prevent name clashes.",
          "type": "string"
        },
        "strictScalars": {
          "description": "Makes scalars strict.\n\nIf scalars are found in the schema that are not defined in `scalars`\nan error will be thrown during codegen.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "defaultScalarType": {
          "description": "Allows you to override the type that unknown scalars will have.\nDefault value: \"any\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap_2",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention_2",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally, you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserve underscores.\n\nAvailable case functions in `change-case-all` are `camelCase`, `capitalCase`, `constantCase`, `dotCase`, `headerCase`, `noCase`, `paramCase`, `pascalCase`, `pathCase`, `sentenceCase`, `snakeCase`, `lowerCase`, `localeLowerCase`, `lowerCaseFirst`, `spongeCase`, `titleCase`, `upperCase`, `localeUpperCase` and `upperCaseFirst`\n[See more](https://github.com/btxtiger/change-case-all)\nDefault value: \"change-case-all#pascalCase\""
        },
        "typesPrefix": { "description": "Prefixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "typesSuffix": { "description": "Suffixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "skipTypename": {
          "description": "Does not add `__typename` to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "dedupeFragments": {
          "description": "Removes fragment duplicates for reducing data transfer.\nIt is done by removing sub-fragments imports from fragment definition\nInstead - all of them are imported to the Operation node.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "inlineFragmentTypes": {
          "description": "Whether fragment types should be inlined into other operations.\n\"inline\" is the default behavior and will perform deep inlining fragment types within operation type definitions.\n\"combine\" is the previous behavior that uses fragment type references without inlining the types (and might cause issues with deeply nested fragment that uses list types).\nDefault value: \"inline\"",
          "type": "string"
        },
        "emitLegacyCommonJSImports": {
          "description": "Emit legacy common js imports.\nDefault it will be `true` this way it ensure that generated code works with [non-compliant bundlers](https://github.com/dotansimha/graphql-code-generator/issues/8065).\nDefault value: \"true\"",
          "type": "boolean"
        }
      }
    },
    "TypeScriptFilesModulesPluginConfig": {
      "description": "This plugin generates TypeScript typings for `.graphql` files containing GraphQL documents, which later on can be consumed using [`graphql-tag/loader`](https://github.com/apollographql/graphql-tag#webpack-preprocessing-with-graphql-tagloader) or use `string` types if you will use the operations as raw strings, and get type-check and type-safety for your imports. This means that any time you import objects from `.graphql` files, your IDE will provide auto-complete.\n\nThis plugin also handles `.graphql` files containing multiple GraphQL documents, and name the imports according to the operation name.\n\n> âš  Fragments are not generated with named imports, only as default imports, due to `graphql-tag/loader` behavior.",
      "type": "object",
      "properties": {
        "modulePathPrefix": {
          "description": "Allows specifying a module definition path prefix to provide distinction\nbetween generated types.\nDefault value: \"\"",
          "type": "string"
        },
        "relativeToCwd": {
          "description": "By default, only the filename is being used to generate TS module declarations. Setting this to `true` will generate it with a full path based on the CWD.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "prefix": {
          "description": "By default, a wildcard is being added as prefix, you can change that to a custom prefix\nDefault value: \"*\\/\"",
          "type": "string"
        },
        "type": {
          "description": "By default, the named exports will have a type `DocumentNode`. Change this to \"string\" if you only use raw strings.\nDefault value: \"DocumentNode\"",
          "enum": ["DocumentNode", "string"],
          "type": "string"
        }
      }
    },
    "NamedOperationsObjectPluginConfig": {
      "type": "object",
      "properties": {
        "identifierName": {
          "description": "Allow you to customize the name of the exported identifier\nDefault value: \"namedOperations\"",
          "type": "string"
        },
        "useConsts": {
          "description": "Will generate a const string instead of regular string.\nDefault value: \"false\"",
          "type": "boolean"
        }
      }
    },
    "RawGraphQLRequestPluginConfig": {
      "description": "This plugin generates [`graphql-request`](https://npmjs.com/package/graphql-request) ready-to-use SDK, which is fully-typed.",
      "type": "object",
      "properties": {
        "rawRequest": {
          "description": "By default, the `request` method return the `data` or `errors` key from the response. If you need to access the `extensions` key you can use the `rawRequest` method.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "extensionsType": {
          "description": "Allows you to override the type for extensions when `rawRequest` is enabled.\nDefault value: \"any\"",
          "type": "string"
        },
        "noGraphQLTag": {
          "description": "Deprecated. Changes the documentMode to `documentNode`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "gqlImport": {
          "description": "Customize from which module will `gql` be imported from.\nThis is useful if you want to use modules other than `graphql-tag`, e.g. `graphql.macro`.\nDefault value: \"graphql-tag#gql\"",
          "type": "string"
        },
        "documentNodeImport": {
          "description": "Customize from which module will `DocumentNode` be imported from.\nThis is useful if you want to use modules other than `graphql`, e.g. `@graphql-typed-document-node`.\nDefault value: \"graphql#DocumentNode\"",
          "type": "string"
        },
        "noExport": {
          "description": "Set this configuration to `true` if you wish to tell codegen to generate code with no `export` identifier.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariablePrefix": {
          "description": "Changes the GraphQL operations variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariableSuffix": {
          "description": "Changes the GraphQL operations variables suffix.\nDefault value: \"Document\"",
          "type": "string"
        },
        "fragmentVariablePrefix": {
          "description": "Changes the GraphQL fragments variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "fragmentVariableSuffix": {
          "description": "Changes the GraphQL fragments variables suffix.\nDefault value: \"FragmentDoc\"",
          "type": "string"
        },
        "documentMode": {
          "$ref": "#/definitions/DocumentMode",
          "description": "Declares how DocumentNode are created:\n\n- `graphQLTag`: `graphql-tag` or other modules (check `gqlImport`) will be used to generate document nodes. If this is used, document nodes are generated on client side i.e. the module used to generate this will be shipped to the client\n- `documentNode`: document nodes will be generated as objects when we generate the templates.\n- `documentNodeImportFragments`: Similar to documentNode except it imports external fragments instead of embedding them.\n- `external`: document nodes are imported from an external file. To be used with `importDocumentNodeExternallyFrom`\n\nNote that some plugins (like `typescript-graphql-request`) also supports `string` for this parameter.\nDefault value: \"graphQLTag\""
        },
        "optimizeDocumentNode": {
          "description": "If you are using `documentNode: documentMode | documentNodeImportFragments`, you can set this to `true` to apply document optimizations for your GraphQL document.\nThis will remove all \"loc\" and \"description\" fields from the compiled document, and will remove all empty arrays (such as `directives`, `arguments` and `variableDefinitions`).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "importOperationTypesFrom": {
          "description": "This config is used internally by presets, but you can use it manually to tell codegen to prefix all base types that it's using.\nThis is useful if you wish to generate base types from `typescript-operations` plugin into a different file, and import it from there.\nDefault value: \"\"",
          "type": "string"
        },
        "importDocumentNodeExternallyFrom": {
          "description": "This config should be used if `documentMode` is `external`. This has 2 usage:\n\n- any string: This would be the path to import document nodes from. This can be used if we want to manually create the document nodes e.g. Use `graphql-tag` in a separate file and export the generated document\n- 'near-operation-file': This is a special mode that is intended to be used with `near-operation-file` preset to import document nodes from those files. If these files are `.graphql` files, we make use of webpack loader.\nDefault value: \"\"",
          "type": "string"
        },
        "pureMagicComment": {
          "description": "This config adds PURE magic comment to the static variables to enforce treeshaking for your bundler.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "experimentalFragmentVariables": {
          "description": "If set to true, it will enable support for parsing variables on fragments.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "strictScalars": {
          "description": "Makes scalars strict.\n\nIf scalars are found in the schema that are not defined in `scalars`\nan error will be thrown during codegen.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "defaultScalarType": {
          "description": "Allows you to override the type that unknown scalars will have.\nDefault value: \"any\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally, you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserve underscores.\n\nAvailable case functions in `change-case-all` are `camelCase`, `capitalCase`, `constantCase`, `dotCase`, `headerCase`, `noCase`, `paramCase`, `pascalCase`, `pathCase`, `sentenceCase`, `snakeCase`, `lowerCase`, `localeLowerCase`, `lowerCaseFirst`, `spongeCase`, `titleCase`, `upperCase`, `localeUpperCase` and `upperCaseFirst`\n[See more](https://github.com/btxtiger/change-case-all)\nDefault value: \"change-case-all#pascalCase\""
        },
        "typesPrefix": { "description": "Prefixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "typesSuffix": { "description": "Suffixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "skipTypename": {
          "description": "Does not add `__typename` to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "dedupeFragments": {
          "description": "Removes fragment duplicates for reducing data transfer.\nIt is done by removing sub-fragments imports from fragment definition\nInstead - all of them are imported to the Operation node.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "inlineFragmentTypes": {
          "description": "Whether fragment types should be inlined into other operations.\n\"inline\" is the default behavior and will perform deep inlining fragment types within operation type definitions.\n\"combine\" is the previous behavior that uses fragment type references without inlining the types (and might cause issues with deeply nested fragment that uses list types).\nDefault value: \"inline\"",
          "type": "string"
        },
        "emitLegacyCommonJSImports": {
          "description": "Emit legacy common js imports.\nDefault it will be `true` this way it ensure that generated code works with [non-compliant bundlers](https://github.com/dotansimha/graphql-code-generator/issues/8065).\nDefault value: \"true\"",
          "type": "boolean"
        }
      }
    },
    "TypeScriptMongoPluginConfig": {
      "type": "object",
      "properties": {
        "dbTypeSuffix": {
          "description": "Customize the suffix for the generated GraphQL `type`s.\nDefault value: \"DbObject\"",
          "type": "string"
        },
        "dbInterfaceSuffix": {
          "description": "Customize the suffix for the generated GraphQL `interface`s.\nDefault value: \"DbObject\"",
          "type": "string"
        },
        "objectIdType": {
          "description": "Customize the type of `_id` fields. You can either specify a type name, or specify `module#type`.\nDefault value: \"mongodb#ObjectId\"",
          "type": "string"
        },
        "idFieldName": {
          "description": "Customize the name of the id field generated after using `@id` directive over a GraphQL field.\nDefault value: \"_id\"",
          "type": "string"
        },
        "enumsAsString": {
          "description": "Replaces generated `enum` values with `string`.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "avoidOptionals": {
          "description": "This will cause the generator to avoid using TypeScript optionals (`?`),\nso the following definition: `type A { myField: String }` will output `myField: Maybe<string>`\ninstead of `myField?: Maybe<string>`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "strictScalars": {
          "description": "Makes scalars strict.\n\nIf scalars are found in the schema that are not defined in `scalars`\nan error will be thrown during codegen.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "defaultScalarType": {
          "description": "Allows you to override the type that unknown scalars will have.\nDefault value: \"any\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally, you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserve underscores.\n\nAvailable case functions in `change-case-all` are `camelCase`, `capitalCase`, `constantCase`, `dotCase`, `headerCase`, `noCase`, `paramCase`, `pascalCase`, `pathCase`, `sentenceCase`, `snakeCase`, `lowerCase`, `localeLowerCase`, `lowerCaseFirst`, `spongeCase`, `titleCase`, `upperCase`, `localeUpperCase` and `upperCaseFirst`\n[See more](https://github.com/btxtiger/change-case-all)\nDefault value: \"change-case-all#pascalCase\""
        },
        "typesPrefix": { "description": "Prefixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "typesSuffix": { "description": "Suffixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "skipTypename": {
          "description": "Does not add `__typename` to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "dedupeFragments": {
          "description": "Removes fragment duplicates for reducing data transfer.\nIt is done by removing sub-fragments imports from fragment definition\nInstead - all of them are imported to the Operation node.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "inlineFragmentTypes": {
          "description": "Whether fragment types should be inlined into other operations.\n\"inline\" is the default behavior and will perform deep inlining fragment types within operation type definitions.\n\"combine\" is the previous behavior that uses fragment type references without inlining the types (and might cause issues with deeply nested fragment that uses list types).\nDefault value: \"inline\"",
          "type": "string"
        },
        "emitLegacyCommonJSImports": {
          "description": "Emit legacy common js imports.\nDefault it will be `true` this way it ensure that generated code works with [non-compliant bundlers](https://github.com/dotansimha/graphql-code-generator/issues/8065).\nDefault value: \"true\"",
          "type": "boolean"
        }
      }
    },
    "TypeScriptResolversPluginConfig": {
      "description": "This plugin generates TypeScript signature for `resolve` functions of your GraphQL API.\nYou can use this plugin to generate simple resolvers signature based on your GraphQL types, or you can change its behavior be providing custom model types (mappers).\n\nYou can find a blog post explaining the usage of this plugin here: https://the-guild.dev/blog/better-type-safety-for-resolvers-with-graphql-codegen",
      "type": "object",
      "properties": {
        "useIndexSignature": {
          "description": "Adds an index signature to any generates resolver.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "noSchemaStitching": {
          "description": "Disables/Enables Schema Stitching support.\nBy default, the resolver signature does not include the support for schema-stitching.\nSet to `false` to enable that.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "wrapFieldDefinitions": {
          "description": "Set to `true` in order to wrap field definitions with `FieldWrapper`.\nThis is useful to allow return types such as Promises and functions. Needed for\ncompatibility with `federation: true` when\nDefault value: \"true\"",
          "type": "boolean"
        },
        "customResolveInfo": {
          "description": "You can provide your custom GraphQLResolveInfo instead of the default one from graphql-js\nDefault value: \"graphql#GraphQLResolveInfo\"",
          "type": "string"
        },
        "customResolverFn": {
          "description": "You can provide your custom ResolveFn instead the default. It has to be a type that uses the generics `<TResult, TParent, TContext, TArgs>`\nDefault value: \"(parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => Promise<TResult> | TResult\"",
          "type": "string"
        },
        "directiveResolverMappings": {
          "$ref": "#/definitions/Record",
          "description": "Map the usage of a directive into using a specific resolver."
        },
        "allowParentTypeOverride": {
          "description": "Allow you to override the `ParentType` generic in each resolver, by avoid enforcing the base type of the generated generic type.\n\nThis will generate `ParentType = Type` instead of `ParentType extends Type = Type` in each resolver.",
          "type": "boolean"
        },
        "optionalInfoArgument": {
          "description": "Sets `info` argument of resolver function to be optional field. Useful for testing.",
          "type": "boolean"
        },
        "makeResolverTypeCallable": {
          "description": "Set to `true` in order to allow the Resolver type to be callable",
          "type": "boolean"
        },
        "addUnderscoreToArgsType": {
          "description": "Adds `_` to generated `Args` types in order to avoid duplicate identifiers.",
          "type": "boolean"
        },
        "contextType": {
          "description": "Use this configuration to set a custom type for your `context`, and it will\naffect all the resolvers, without the need to override it using generics each time.\nIf you wish to use an external type and import it from another file, you can use `add` plugin\nand add the required `import` statement, or you can use a `module#type` syntax.",
          "type": "string"
        },
        "fieldContextTypes": {
          "$ref": "#/definitions/Array_1",
          "description": "Use this to set a custom type for a specific field `context`.\nIt will only affect the targeted resolvers.\nYou can either use `Field.Path#ContextTypeName` or `Field.Path#ExternalFileName#ContextTypeName`"
        },
        "rootValueType": {
          "description": "Use this configuration to set a custom type for the `rootValue`, and it will\naffect resolvers of all root types (Query, Mutation and Subscription), without the need to override it using generics each time.\nIf you wish to use an external type and import it from another file, you can use `add` plugin\nand add the required `import` statement, or you can use both `module#type` or `module#namespace#type` syntax.",
          "type": "string"
        },
        "directiveContextTypes": {
          "$ref": "#/definitions/Array_1",
          "description": "Use this to set a custom type for a specific field `context` decorated by a directive.\nIt will only affect the targeted resolvers.\nYou can either use `Field.Path#ContextTypeName` or `Field.Path#ExternalFileName#ContextTypeName`\n\nContextTypeName should by a generic Type that take the context or field context type as only type parameter."
        },
        "mapperTypeSuffix": {
          "description": "Adds a suffix to the imported names to prevent name clashes.",
          "type": "string"
        },
        "mappers": {
          "description": "Replaces a GraphQL type usage with a custom type, allowing you to return custom object from\nyour resolvers.\nYou can use both `module#type` and `module#namespace#type` syntax.",
          "type": "object",
          "additionalProperties": { "type": "string" }
        },
        "defaultMapper": {
          "description": "Allow you to set the default mapper when it's not being override by `mappers` or generics.\nYou can specify a type name, or specify a string in `module#type` or `module#namespace#type` format.\nThe default value of mappers is the TypeScript type generated by `typescript` package.",
          "type": "string"
        },
        "avoidOptionals": {
          "description": "This will cause the generator to avoid using optionals (`?`),\nso all field resolvers must be implemented in order to avoid compilation errors.\nDefault value: \"false\"",
          "anyOf": [{ "$ref": "#/definitions/AvoidOptionalsConfig" }, { "type": "boolean" }]
        },
        "showUnusedMappers": {
          "description": "Warns about unused mappers.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "enumValues": {
          "$ref": "#/definitions/EnumValuesMap",
          "description": "Overrides the default value of enum values declared in your GraphQL schema, supported\nin this plugin because of the need for integration with `typescript` package.\nSee documentation under `typescript` plugin for more information and examples."
        },
        "resolverTypeWrapperSignature": {
          "description": "Allow you to override `resolverTypeWrapper` definition.\nDefault value: \"Promise<T> | T\"",
          "type": "string"
        },
        "federation": { "description": "Supports Apollo Federation\nDefault value: \"false\"", "type": "boolean" },
        "enumPrefix": {
          "description": "Allow you to disable prefixing for generated enums, works in combination with `typesPrefix`.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "enumSuffix": {
          "description": "Allow you to disable suffixing for generated enums, works in combination with `typesSuffix`.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "customDirectives": {
          "description": "Configures behavior for custom directives from various GraphQL libraries.",
          "type": "object",
          "properties": { "semanticNonNull": { "type": "boolean" } }
        },
        "optionalResolveType": {
          "description": "Sets the `__resolveType` field as optional field.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "immutableTypes": {
          "description": "Generates immutable types by adding `readonly` to properties and uses `ReadonlyArray`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "namespacedImportName": {
          "description": "Prefixes all GraphQL related generated types with that value, as namespaces import.\nYou can use this feature to allow separation of plugins to different files.\nDefault value: \"''\"",
          "type": "string"
        },
        "resolverTypeSuffix": {
          "description": "Suffix we add to each generated type resolver.\nDefault value: \"Resolvers\"",
          "type": "string"
        },
        "allResolversTypeName": {
          "description": "The type name to use when exporting all resolvers signature as unified type.\nDefault value: \"Resolvers\"",
          "type": "string"
        },
        "internalResolversPrefix": {
          "type": "string",
          "description": "Defines the prefix value used for `__resolveType` and `__isTypeOf` resolvers.\nIf you are using `mercurius-js`, please set this field to empty string for better compatibility.\nDefault value: \"'__'\""
        },
        "resolversNonOptionalTypename": {
          "description": "Makes `__typename` of resolver mappings non-optional without affecting the base types.\nDefault value: \"false\"",
          "anyOf": [{ "$ref": "#/definitions/ResolversNonOptionalTypenameConfig" }, { "type": "boolean" }]
        },
        "avoidCheckingAbstractTypesRecursively": {
          "type": "boolean",
          "description": "If true, recursively goes through all object type's fields, checks if they have abstract types and generates expected types correctly.\nThis may not work for cases where provided default mapper types are also nested e.g. `defaultMapper: DeepPartial<{T}>` or `defaultMapper: Partial<{T}>`.\nDefault value: \"false\""
        },
        "addInterfaceFieldResolverTypes": {
          "description": "If true, add field resolver types to Interfaces.\nBy default, GraphQL Interfaces do not trigger any field resolvers,\nmeaning every implementing type must implement the same resolver for the shared fields.\n\nSome tools provide a way to change the default behaviour by making GraphQL Objects inherit\nmissing resolvers from their Interface types. In these cases, it is fine to turn this option to true.\n\nFor example, if you are using `@graphql-tools/schema#makeExecutableSchema` with `inheritResolversFromInterfaces: true`,\nyou can make `addInterfaceFieldResolverTypes: true` as well\nhttps://the-guild.dev/graphql/tools/docs/generate-schema#makeexecutableschema\nDefault value: \"false\"",
          "type": "boolean"
        },
        "strictScalars": {
          "description": "Makes scalars strict.\n\nIf scalars are found in the schema that are not defined in `scalars`\nan error will be thrown during codegen.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "defaultScalarType": {
          "description": "Allows you to override the type that unknown scalars will have.\nDefault value: \"any\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap_1",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention_1",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally, you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserve underscores.\n\nAvailable case functions in `change-case-all` are `camelCase`, `capitalCase`, `constantCase`, `dotCase`, `headerCase`, `noCase`, `paramCase`, `pascalCase`, `pathCase`, `sentenceCase`, `snakeCase`, `lowerCase`, `localeLowerCase`, `lowerCaseFirst`, `spongeCase`, `titleCase`, `upperCase`, `localeUpperCase` and `upperCaseFirst`\n[See more](https://github.com/btxtiger/change-case-all)\nDefault value: \"change-case-all#pascalCase\""
        },
        "typesPrefix": { "description": "Prefixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "typesSuffix": { "description": "Suffixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "skipTypename": {
          "description": "Does not add `__typename` to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "inlineFragmentTypes": {
          "description": "Whether fragment types should be inlined into other operations.\n\"inline\" is the default behavior and will perform deep inlining fragment types within operation type definitions.\n\"combine\" is the previous behavior that uses fragment type references without inlining the types (and might cause issues with deeply nested fragment that uses list types).\n\"mask\" transforms the types for use with fragment masking. Useful when masked types are needed when not using the \"client\" preset e.g. such as combining it with Apollo Client's data masking feature.\nDefault value: \"inline\"",
          "type": "string"
        },
        "emitLegacyCommonJSImports": {
          "description": "Emit legacy common js imports.\nDefault it will be `true` this way it ensure that generated code works with [non-compliant bundlers](https://github.com/dotansimha/graphql-code-generator/issues/8065).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "importExtension": {
          "description": "Append this extension to all imports.\nUseful for ESM environments that require file extensions in import statements.",
          "type": "string"
        },
        "extractAllFieldsToTypes": {
          "description": "Extract all field types to their own types, instead of inlining them.\nThis helps to reduce type duplication, and makes type errors more readable.\nIt can also significantly reduce the size of the generated code, the generation time,\nand the typechecking time.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "printFieldsOnNewLines": {
          "description": "If you prefer to have each field in generated types printed on a new line, set this to true.\nThis can be useful for improving readability of the resulting types,\nwithout resorting to running tools like Prettier on the output.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "includeExternalFragments": {
          "description": "Whether to include external fragments in the generated code. External fragments are not defined\nin the same location as the operation definition.\nDefault value: \"false\"",
          "type": "boolean"
        }
      }
    },
    "ApolloAngularRawPluginConfig": {
      "description": "This plugin generates Apollo services (`Query`, `Mutation` and `Subscription`) with TypeScript typings.\n\nIt will generate a strongly typed Angular service for every defined query, mutation or subscription. The generated Angular services are ready to inject and use within your Angular component.\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` - and thus shares a similar configuration.\n\nTo shed some more light regards this template, it's recommended to go through this article: https://apollo-angular.com/docs/get-started, and to read the Code Generation with Apollo Angular: https://the-guild.dev/blog/apollo-angular-12",
      "type": "object",
      "properties": {
        "apolloAngularVersion": {
          "description": "Version of `apollo-angular` package\nDefault value: \"2\"",
          "type": "number"
        },
        "ngModule": {
          "description": "Allows to define `ngModule` as part of the plugin's config so it's globally available.",
          "type": "string"
        },
        "namedClient": { "description": "Defined the global value of `namedClient`.", "type": "string" },
        "serviceName": { "description": "Defined the global value of `serviceName`.", "type": "string" },
        "serviceProvidedInRoot": {
          "description": "Defined the global value of `serviceProvidedInRoot`.",
          "type": "boolean"
        },
        "serviceProvidedIn": { "description": "Define the Injector of the SDK class.", "type": "string" },
        "sdkClass": {
          "description": "Set to `true` in order to generate a SDK service class that uses all generated services.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "querySuffix": {
          "description": "Allows to define a custom suffix for query operations.\nDefault value: \"GQL\"",
          "type": "string"
        },
        "mutationSuffix": {
          "description": "Allows to define a custom suffix for mutation operations.\nDefault value: \"GQL\"",
          "type": "string"
        },
        "subscriptionSuffix": {
          "description": "Allows to define a custom suffix for Subscription operations.\nDefault value: \"GQL\"",
          "type": "string"
        },
        "apolloAngularPackage": {
          "description": "Allows to define a custom Apollo-Angular package to import types from.\nDefault value: \"'apollo-angular'\"",
          "type": "string"
        },
        "additionalDI": {
          "description": "Add additional dependency injections for generated services\nDefault value: \"\"",
          "type": "array",
          "items": { "type": "string" }
        },
        "addExplicitOverride": {
          "description": "Add `override` modifier to make the generated code compatible with the `noImplicitOverride` option of Typescript v4.3+.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "noGraphQLTag": {
          "description": "Deprecated. Changes the documentMode to `documentNode`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "gqlImport": {
          "description": "Customize from which module will `gql` be imported from.\nThis is useful if you want to use modules other than `graphql-tag`, e.g. `graphql.macro`.\nDefault value: \"graphql-tag#gql\"",
          "type": "string"
        },
        "documentNodeImport": {
          "description": "Customize from which module will `DocumentNode` be imported from.\nThis is useful if you want to use modules other than `graphql`, e.g. `@graphql-typed-document-node`.\nDefault value: \"graphql#DocumentNode\"",
          "type": "string"
        },
        "noExport": {
          "description": "Set this configuration to `true` if you wish to tell codegen to generate code with no `export` identifier.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariablePrefix": {
          "description": "Changes the GraphQL operations variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariableSuffix": {
          "description": "Changes the GraphQL operations variables suffix.\nDefault value: \"Document\"",
          "type": "string"
        },
        "fragmentVariablePrefix": {
          "description": "Changes the GraphQL fragments variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "fragmentVariableSuffix": {
          "description": "Changes the GraphQL fragments variables suffix.\nDefault value: \"FragmentDoc\"",
          "type": "string"
        },
        "documentMode": {
          "$ref": "#/definitions/DocumentMode",
          "description": "Declares how DocumentNode are created:\n\n- `graphQLTag`: `graphql-tag` or other modules (check `gqlImport`) will be used to generate document nodes. If this is used, document nodes are generated on client side i.e. the module used to generate this will be shipped to the client\n- `documentNode`: document nodes will be generated as objects when we generate the templates.\n- `documentNodeImportFragments`: Similar to documentNode except it imports external fragments instead of embedding them.\n- `external`: document nodes are imported from an external file. To be used with `importDocumentNodeExternallyFrom`\n\nNote that some plugins (like `typescript-graphql-request`) also supports `string` for this parameter.\nDefault value: \"graphQLTag\""
        },
        "optimizeDocumentNode": {
          "description": "If you are using `documentNode: documentMode | documentNodeImportFragments`, you can set this to `true` to apply document optimizations for your GraphQL document.\nThis will remove all \"loc\" and \"description\" fields from the compiled document, and will remove all empty arrays (such as `directives`, `arguments` and `variableDefinitions`).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "importOperationTypesFrom": {
          "description": "This config is used internally by presets, but you can use it manually to tell codegen to prefix all base types that it's using.\nThis is useful if you wish to generate base types from `typescript-operations` plugin into a different file, and import it from there.\nDefault value: \"\"",
          "type": "string"
        },
        "importDocumentNodeExternallyFrom": {
          "description": "This config should be used if `documentMode` is `external`. This has 2 usage:\n\n- any string: This would be the path to import document nodes from. This can be used if we want to manually create the document nodes e.g. Use `graphql-tag` in a separate file and export the generated document\n- 'near-operation-file': This is a special mode that is intended to be used with `near-operation-file` preset to import document nodes from those files. If these files are `.graphql` files, we make use of webpack loader.\nDefault value: \"\"",
          "type": "string"
        },
        "pureMagicComment": {
          "description": "This config adds PURE magic comment to the static variables to enforce treeshaking for your bundler.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "experimentalFragmentVariables": {
          "description": "If set to true, it will enable support for parsing variables on fragments.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "strictScalars": {
          "description": "Makes scalars strict.\n\nIf scalars are found in the schema that are not defined in `scalars`\nan error will be thrown during codegen.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "defaultScalarType": {
          "description": "Allows you to override the type that unknown scalars will have.\nDefault value: \"any\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally, you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserve underscores.\n\nAvailable case functions in `change-case-all` are `camelCase`, `capitalCase`, `constantCase`, `dotCase`, `headerCase`, `noCase`, `paramCase`, `pascalCase`, `pathCase`, `sentenceCase`, `snakeCase`, `lowerCase`, `localeLowerCase`, `lowerCaseFirst`, `spongeCase`, `titleCase`, `upperCase`, `localeUpperCase` and `upperCaseFirst`\n[See more](https://github.com/btxtiger/change-case-all)\nDefault value: \"change-case-all#pascalCase\""
        },
        "typesPrefix": { "description": "Prefixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "typesSuffix": { "description": "Suffixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "skipTypename": {
          "description": "Does not add `__typename` to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "dedupeFragments": {
          "description": "Removes fragment duplicates for reducing data transfer.\nIt is done by removing sub-fragments imports from fragment definition\nInstead - all of them are imported to the Operation node.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "inlineFragmentTypes": {
          "description": "Whether fragment types should be inlined into other operations.\n\"inline\" is the default behavior and will perform deep inlining fragment types within operation type definitions.\n\"combine\" is the previous behavior that uses fragment type references without inlining the types (and might cause issues with deeply nested fragment that uses list types).\nDefault value: \"inline\"",
          "type": "string"
        },
        "emitLegacyCommonJSImports": {
          "description": "Emit legacy common js imports.\nDefault it will be `true` this way it ensure that generated code works with [non-compliant bundlers](https://github.com/dotansimha/graphql-code-generator/issues/8065).\nDefault value: \"true\"",
          "type": "boolean"
        }
      }
    },
    "NhostPluginConfig": {
      "description": "This plugin generates the Typescript schema that enables queries and mutations to be typed in the Nhost SDK.",
      "type": "object",
      "properties": {
        "scalars": {
          "$ref": "#/definitions/ScalarsMap_3",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        }
      }
    },
    "UrqlRawPluginConfig": {
      "description": "This plugin generates `urql` (https://github.com/FormidableLabs/urql) components and HOC with TypeScript typings.",
      "type": "object",
      "properties": {
        "withComponent": {
          "description": "Customized the output by enabling/disabling the generated Component.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "withHooks": {
          "description": "Customized the output by enabling/disabling the generated React Hooks.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "urqlImportFrom": {
          "description": "You can specify module that exports components `Query`, `Mutation`, `Subscription` and HOCs\nThis is useful for further abstraction of some common tasks (e.g. error handling).\nFilepath relative to generated file can be also specified.\nDefault value: \"urql\"",
          "type": "string"
        },
        "noGraphQLTag": {
          "description": "Deprecated. Changes the documentMode to `documentNode`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "gqlImport": {
          "description": "Customize from which module will `gql` be imported from.\nThis is useful if you want to use modules other than `graphql-tag`, e.g. `graphql.macro`.\nDefault value: \"graphql-tag#gql\"",
          "type": "string"
        },
        "documentNodeImport": {
          "description": "Customize from which module will `DocumentNode` be imported from.\nThis is useful if you want to use modules other than `graphql`, e.g. `@graphql-typed-document-node`.\nDefault value: \"graphql#DocumentNode\"",
          "type": "string"
        },
        "noExport": {
          "description": "Set this configuration to `true` if you wish to tell codegen to generate code with no `export` identifier.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariablePrefix": {
          "description": "Changes the GraphQL operations variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariableSuffix": {
          "description": "Changes the GraphQL operations variables suffix.\nDefault value: \"Document\"",
          "type": "string"
        },
        "fragmentVariablePrefix": {
          "description": "Changes the GraphQL fragments variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "fragmentVariableSuffix": {
          "description": "Changes the GraphQL fragments variables suffix.\nDefault value: \"FragmentDoc\"",
          "type": "string"
        },
        "documentMode": {
          "$ref": "#/definitions/DocumentMode",
          "description": "Declares how DocumentNode are created:\n\n- `graphQLTag`: `graphql-tag` or other modules (check `gqlImport`) will be used to generate document nodes. If this is used, document nodes are generated on client side i.e. the module used to generate this will be shipped to the client\n- `documentNode`: document nodes will be generated as objects when we generate the templates.\n- `documentNodeImportFragments`: Similar to documentNode except it imports external fragments instead of embedding them.\n- `external`: document nodes are imported from an external file. To be used with `importDocumentNodeExternallyFrom`\n\nNote that some plugins (like `typescript-graphql-request`) also supports `string` for this parameter.\nDefault value: \"graphQLTag\""
        },
        "optimizeDocumentNode": {
          "description": "If you are using `documentNode: documentMode | documentNodeImportFragments`, you can set this to `true` to apply document optimizations for your GraphQL document.\nThis will remove all \"loc\" and \"description\" fields from the compiled document, and will remove all empty arrays (such as `directives`, `arguments` and `variableDefinitions`).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "importOperationTypesFrom": {
          "description": "This config is used internally by presets, but you can use it manually to tell codegen to prefix all base types that it's using.\nThis is useful if you wish to generate base types from `typescript-operations` plugin into a different file, and import it from there.\nDefault value: \"\"",
          "type": "string"
        },
        "importDocumentNodeExternallyFrom": {
          "description": "This config should be used if `documentMode` is `external`. This has 2 usage:\n\n- any string: This would be the path to import document nodes from. This can be used if we want to manually create the document nodes e.g. Use `graphql-tag` in a separate file and export the generated document\n- 'near-operation-file': This is a special mode that is intended to be used with `near-operation-file` preset to import document nodes from those files. If these files are `.graphql` files, we make use of webpack loader.\nDefault value: \"\"",
          "type": "string"
        },
        "pureMagicComment": {
          "description": "This config adds PURE magic comment to the static variables to enforce treeshaking for your bundler.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "experimentalFragmentVariables": {
          "description": "If set to true, it will enable support for parsing variables on fragments.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "strictScalars": {
          "description": "Makes scalars strict.\n\nIf scalars are found in the schema that are not defined in `scalars`\nan error will be thrown during codegen.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "defaultScalarType": {
          "description": "Allows you to override the type that unknown scalars will have.\nDefault value: \"any\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally, you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserve underscores.\n\nAvailable case functions in `change-case-all` are `camelCase`, `capitalCase`, `constantCase`, `dotCase`, `headerCase`, `noCase`, `paramCase`, `pascalCase`, `pathCase`, `sentenceCase`, `snakeCase`, `lowerCase`, `localeLowerCase`, `lowerCaseFirst`, `spongeCase`, `titleCase`, `upperCase`, `localeUpperCase` and `upperCaseFirst`\n[See more](https://github.com/btxtiger/change-case-all)\nDefault value: \"change-case-all#pascalCase\""
        },
        "typesPrefix": { "description": "Prefixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "typesSuffix": { "description": "Suffixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "skipTypename": {
          "description": "Does not add `__typename` to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "dedupeFragments": {
          "description": "Removes fragment duplicates for reducing data transfer.\nIt is done by removing sub-fragments imports from fragment definition\nInstead - all of them are imported to the Operation node.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "inlineFragmentTypes": {
          "description": "Whether fragment types should be inlined into other operations.\n\"inline\" is the default behavior and will perform deep inlining fragment types within operation type definitions.\n\"combine\" is the previous behavior that uses fragment type references without inlining the types (and might cause issues with deeply nested fragment that uses list types).\nDefault value: \"inline\"",
          "type": "string"
        },
        "emitLegacyCommonJSImports": {
          "description": "Emit legacy common js imports.\nDefault it will be `true` this way it ensure that generated code works with [non-compliant bundlers](https://github.com/dotansimha/graphql-code-generator/issues/8065).\nDefault value: \"true\"",
          "type": "boolean"
        }
      }
    },
    "ReactApolloRawPluginConfig": {
      "description": "This plugin generates React Apollo components and HOC with TypeScript typings.\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` - and thus shares a similar configuration.",
      "type": "object",
      "properties": {
        "withComponent": {
          "description": "Customize the output by enabling/disabling the generated Component (deprecated since Apollo-Client v3). For more details: https://apollographql.com/docs/react/api/react/components\nDefault value: \"false\"",
          "type": "boolean"
        },
        "withHOC": {
          "description": "Customize the output by enabling/disabling the HOC (deprecated since Apollo-Client v3). For more details: https://apollographql.com/docs/react/api/react/hoc\nDefault value: \"false\"",
          "type": "boolean"
        },
        "withHooks": {
          "description": "Customized the output by enabling/disabling the generated React Hooks. For more details: https://apollographql.com/docs/react/api/react/hooks\nDefault value: \"true\"",
          "type": "boolean"
        },
        "withMutationFn": {
          "description": "Customized the output by enabling/disabling the generated mutation function signature.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "withRefetchFn": {
          "description": "Enable generating a function to be used with refetchQueries\nDefault value: \"false\"",
          "type": "boolean"
        },
        "apolloReactCommonImportFrom": {
          "description": "Customize the package where apollo-react common lib is loaded from.\nDefault value: \"@apollo/react-common\"",
          "type": "string"
        },
        "apolloReactComponentsImportFrom": {
          "description": "Customize the package where apollo-react component lib is loaded from.\nDefault value: \"@apollo/react-components\"",
          "type": "string"
        },
        "apolloReactHocImportFrom": {
          "description": "Customize the package where apollo-react HOC lib is loaded from.\nDefault value: \"@apollo/react-hoc\"",
          "type": "string"
        },
        "apolloReactHooksImportFrom": {
          "description": "Customize the package where apollo-react hooks lib is loaded from.\nDefault value: \"@apollo/react-hooks\"",
          "type": "string"
        },
        "componentSuffix": {
          "description": "You can specify a suffix that gets attached to the name of the generated component.\nDefault value: \"Component\"",
          "type": "string"
        },
        "reactApolloVersion": {
          "description": "Sets the version of react-apollo.\nIf you are using the old (deprecated) package of `react-apollo`, please set this configuration to `2`.\nIf you are using Apollo-Client v3, please set this to `3`.\nDefault value: \"3\"",
          "enum": [2, 3],
          "type": "number"
        },
        "withResultType": {
          "description": "Customized the output by enabling/disabling the generated result type.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "withMutationOptionsType": {
          "description": "Customized the output by enabling/disabling the generated mutation option type.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "addDocBlocks": {
          "description": "Allows you to enable/disable the generation of docblocks in generated code.\nSome IDE's (like VSCode) add extra inline information with docblocks, you can disable this feature if your preferred IDE does not.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "defaultBaseOptions": { "type": "object", "additionalProperties": { "type": "string" } },
        "hooksSuffix": { "type": "string" },
        "noGraphQLTag": {
          "description": "Deprecated. Changes the documentMode to `documentNode`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "gqlImport": {
          "description": "Customize from which module will `gql` be imported from.\nThis is useful if you want to use modules other than `graphql-tag`, e.g. `graphql.macro`.\nDefault value: \"graphql-tag#gql\"",
          "type": "string"
        },
        "documentNodeImport": {
          "description": "Customize from which module will `DocumentNode` be imported from.\nThis is useful if you want to use modules other than `graphql`, e.g. `@graphql-typed-document-node`.\nDefault value: \"graphql#DocumentNode\"",
          "type": "string"
        },
        "noExport": {
          "description": "Set this configuration to `true` if you wish to tell codegen to generate code with no `export` identifier.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariablePrefix": {
          "description": "Changes the GraphQL operations variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariableSuffix": {
          "description": "Changes the GraphQL operations variables suffix.\nDefault value: \"Document\"",
          "type": "string"
        },
        "fragmentVariablePrefix": {
          "description": "Changes the GraphQL fragments variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "fragmentVariableSuffix": {
          "description": "Changes the GraphQL fragments variables suffix.\nDefault value: \"FragmentDoc\"",
          "type": "string"
        },
        "documentMode": {
          "$ref": "#/definitions/DocumentMode",
          "description": "Declares how DocumentNode are created:\n\n- `graphQLTag`: `graphql-tag` or other modules (check `gqlImport`) will be used to generate document nodes. If this is used, document nodes are generated on client side i.e. the module used to generate this will be shipped to the client\n- `documentNode`: document nodes will be generated as objects when we generate the templates.\n- `documentNodeImportFragments`: Similar to documentNode except it imports external fragments instead of embedding them.\n- `external`: document nodes are imported from an external file. To be used with `importDocumentNodeExternallyFrom`\n\nNote that some plugins (like `typescript-graphql-request`) also supports `string` for this parameter.\nDefault value: \"graphQLTag\""
        },
        "optimizeDocumentNode": {
          "description": "If you are using `documentNode: documentMode | documentNodeImportFragments`, you can set this to `true` to apply document optimizations for your GraphQL document.\nThis will remove all \"loc\" and \"description\" fields from the compiled document, and will remove all empty arrays (such as `directives`, `arguments` and `variableDefinitions`).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "importOperationTypesFrom": {
          "description": "This config is used internally by presets, but you can use it manually to tell codegen to prefix all base types that it's using.\nThis is useful if you wish to generate base types from `typescript-operations` plugin into a different file, and import it from there.\nDefault value: \"\"",
          "type": "string"
        },
        "importDocumentNodeExternallyFrom": {
          "description": "This config should be used if `documentMode` is `external`. This has 2 usage:\n\n- any string: This would be the path to import document nodes from. This can be used if we want to manually create the document nodes e.g. Use `graphql-tag` in a separate file and export the generated document\n- 'near-operation-file': This is a special mode that is intended to be used with `near-operation-file` preset to import document nodes from those files. If these files are `.graphql` files, we make use of webpack loader.\nDefault value: \"\"",
          "type": "string"
        },
        "pureMagicComment": {
          "description": "This config adds PURE magic comment to the static variables to enforce treeshaking for your bundler.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "experimentalFragmentVariables": {
          "description": "If set to true, it will enable support for parsing variables on fragments.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "strictScalars": {
          "description": "Makes scalars strict.\n\nIf scalars are found in the schema that are not defined in `scalars`\nan error will be thrown during codegen.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "defaultScalarType": {
          "description": "Allows you to override the type that unknown scalars will have.\nDefault value: \"any\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally, you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserve underscores.\n\nAvailable case functions in `change-case-all` are `camelCase`, `capitalCase`, `constantCase`, `dotCase`, `headerCase`, `noCase`, `paramCase`, `pascalCase`, `pathCase`, `sentenceCase`, `snakeCase`, `lowerCase`, `localeLowerCase`, `lowerCaseFirst`, `spongeCase`, `titleCase`, `upperCase`, `localeUpperCase` and `upperCaseFirst`\n[See more](https://github.com/btxtiger/change-case-all)\nDefault value: \"change-case-all#pascalCase\""
        },
        "typesPrefix": { "description": "Prefixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "typesSuffix": { "description": "Suffixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "skipTypename": {
          "description": "Does not add `__typename` to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "dedupeFragments": {
          "description": "Removes fragment duplicates for reducing data transfer.\nIt is done by removing sub-fragments imports from fragment definition\nInstead - all of them are imported to the Operation node.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "inlineFragmentTypes": {
          "description": "Whether fragment types should be inlined into other operations.\n\"inline\" is the default behavior and will perform deep inlining fragment types within operation type definitions.\n\"combine\" is the previous behavior that uses fragment type references without inlining the types (and might cause issues with deeply nested fragment that uses list types).\nDefault value: \"inline\"",
          "type": "string"
        },
        "emitLegacyCommonJSImports": {
          "description": "Emit legacy common js imports.\nDefault it will be `true` this way it ensure that generated code works with [non-compliant bundlers](https://github.com/dotansimha/graphql-code-generator/issues/8065).\nDefault value: \"true\"",
          "type": "boolean"
        }
      }
    },
    "VueApolloRawPluginConfig": {
      "description": "This plugin generates",
      "type": "object",
      "properties": {
        "withCompositionFunctions": {
          "description": "Customized the output by enabling/disabling the generated Vue composition functions.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "vueApolloComposableImportFrom": { "type": "string", "description": "\nDefault value: \"\"" },
        "vueCompositionApiImportFrom": { "type": "string", "description": "\nDefault value: \"\"" },
        "addDocBlocks": {
          "description": "Allows you to enable/disable the generation of docblocks in generated code.\nSome IDE's (like VSCode) add extra inline information with docblocks, you can disable this feature if your preferred IDE does not.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "noGraphQLTag": {
          "description": "Deprecated. Changes the documentMode to `documentNode`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "gqlImport": {
          "description": "Customize from which module will `gql` be imported from.\nThis is useful if you want to use modules other than `graphql-tag`, e.g. `graphql.macro`.\nDefault value: \"graphql-tag#gql\"",
          "type": "string"
        },
        "documentNodeImport": {
          "description": "Customize from which module will `DocumentNode` be imported from.\nThis is useful if you want to use modules other than `graphql`, e.g. `@graphql-typed-document-node`.\nDefault value: \"graphql#DocumentNode\"",
          "type": "string"
        },
        "noExport": {
          "description": "Set this configuration to `true` if you wish to tell codegen to generate code with no `export` identifier.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariablePrefix": {
          "description": "Changes the GraphQL operations variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariableSuffix": {
          "description": "Changes the GraphQL operations variables suffix.\nDefault value: \"Document\"",
          "type": "string"
        },
        "fragmentVariablePrefix": {
          "description": "Changes the GraphQL fragments variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "fragmentVariableSuffix": {
          "description": "Changes the GraphQL fragments variables suffix.\nDefault value: \"FragmentDoc\"",
          "type": "string"
        },
        "documentMode": {
          "$ref": "#/definitions/DocumentMode",
          "description": "Declares how DocumentNode are created:\n\n- `graphQLTag`: `graphql-tag` or other modules (check `gqlImport`) will be used to generate document nodes. If this is used, document nodes are generated on client side i.e. the module used to generate this will be shipped to the client\n- `documentNode`: document nodes will be generated as objects when we generate the templates.\n- `documentNodeImportFragments`: Similar to documentNode except it imports external fragments instead of embedding them.\n- `external`: document nodes are imported from an external file. To be used with `importDocumentNodeExternallyFrom`\n\nNote that some plugins (like `typescript-graphql-request`) also supports `string` for this parameter.\nDefault value: \"graphQLTag\""
        },
        "optimizeDocumentNode": {
          "description": "If you are using `documentNode: documentMode | documentNodeImportFragments`, you can set this to `true` to apply document optimizations for your GraphQL document.\nThis will remove all \"loc\" and \"description\" fields from the compiled document, and will remove all empty arrays (such as `directives`, `arguments` and `variableDefinitions`).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "importOperationTypesFrom": {
          "description": "This config is used internally by presets, but you can use it manually to tell codegen to prefix all base types that it's using.\nThis is useful if you wish to generate base types from `typescript-operations` plugin into a different file, and import it from there.\nDefault value: \"\"",
          "type": "string"
        },
        "importDocumentNodeExternallyFrom": {
          "description": "This config should be used if `documentMode` is `external`. This has 2 usage:\n\n- any string: This would be the path to import document nodes from. This can be used if we want to manually create the document nodes e.g. Use `graphql-tag` in a separate file and export the generated document\n- 'near-operation-file': This is a special mode that is intended to be used with `near-operation-file` preset to import document nodes from those files. If these files are `.graphql` files, we make use of webpack loader.\nDefault value: \"\"",
          "type": "string"
        },
        "pureMagicComment": {
          "description": "This config adds PURE magic comment to the static variables to enforce treeshaking for your bundler.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "experimentalFragmentVariables": {
          "description": "If set to true, it will enable support for parsing variables on fragments.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "strictScalars": {
          "description": "Makes scalars strict.\n\nIf scalars are found in the schema that are not defined in `scalars`\nan error will be thrown during codegen.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "defaultScalarType": {
          "description": "Allows you to override the type that unknown scalars will have.\nDefault value: \"any\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally, you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserve underscores.\n\nAvailable case functions in `change-case-all` are `camelCase`, `capitalCase`, `constantCase`, `dotCase`, `headerCase`, `noCase`, `paramCase`, `pascalCase`, `pathCase`, `sentenceCase`, `snakeCase`, `lowerCase`, `localeLowerCase`, `lowerCaseFirst`, `spongeCase`, `titleCase`, `upperCase`, `localeUpperCase` and `upperCaseFirst`\n[See more](https://github.com/btxtiger/change-case-all)\nDefault value: \"change-case-all#pascalCase\""
        },
        "typesPrefix": { "description": "Prefixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "typesSuffix": { "description": "Suffixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "skipTypename": {
          "description": "Does not add `__typename` to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "dedupeFragments": {
          "description": "Removes fragment duplicates for reducing data transfer.\nIt is done by removing sub-fragments imports from fragment definition\nInstead - all of them are imported to the Operation node.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "inlineFragmentTypes": {
          "description": "Whether fragment types should be inlined into other operations.\n\"inline\" is the default behavior and will perform deep inlining fragment types within operation type definitions.\n\"combine\" is the previous behavior that uses fragment type references without inlining the types (and might cause issues with deeply nested fragment that uses list types).\nDefault value: \"inline\"",
          "type": "string"
        },
        "emitLegacyCommonJSImports": {
          "description": "Emit legacy common js imports.\nDefault it will be `true` this way it ensure that generated code works with [non-compliant bundlers](https://github.com/dotansimha/graphql-code-generator/issues/8065).\nDefault value: \"true\"",
          "type": "boolean"
        }
      }
    },
    "VueApolloSmartOpsRawPluginConfig": {
      "description": "This plugin generates Vue Apollo Smart Query, Smart Subscription and mutation operation functions with\nTypeScript typings.\n\nThis plugin relies on some helper functions and types from the `vue-apollo-smart-ops` package. That package also adds\nsome optional functionality for improved error handling in Vue Apollo operations which can be configured in the\ngenerated code from this plugin.\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` -\nand thus shares a similar configuration.",
      "type": "object",
      "properties": {
        "withSmartOperationFunctions": {
          "description": "Customize the output by enabling/disabling the generated Vue Apollo Smart Operations functions.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "vueApolloOperationFunctionsImportFrom": {
          "description": "The `typescript-vue-apollo-smart-ops` plugin requires three functions that are used to define your\nquery, subscription and mutation operation functions:\n\n- `createMutationFunction`\n- `createSmartQueryOptionsFunction`\n- `createSmartSubscriptionOptionsFunction`\n\nBy default, these functions are provided by the `vue-apollo-smart-ops` package, but you can substitute\nyour own import path if you want to replace them with other implementations.\nDefault value: \"vue-apollo-smart-ops\"",
          "type": "string"
        },
        "vueApolloErrorType": {
          "description": "The operation functions generated by `typescript-vue-apollo-smart-ops` include some functionality for\nerror handling. This configuration parameter allows you to customise the name of the error type that\nwill be used. The default is to use `ApolloError` from the `apollo-client` package.\nDefault value: \"ApolloError\"",
          "type": "string"
        },
        "vueApolloErrorTypeImportFrom": {
          "description": "The operation functions generated by `typescript-vue-apollo-smart-ops` include some functionality for\nerror handling. This configuration parameter allows you to customise the package where the error type\nwill be imported from. The default is to use `ApolloError` from the `apollo-client` package.\nDefault value: \"vue-apollo-smart-ops\"",
          "type": "string"
        },
        "vueApolloErrorHandlerFunction": {
          "description": "The operation functions generated by `typescript-vue-apollo-smart-ops` include some functionality for\nerror handling. You may supply an error handler function that will be called when an error occurs in\na query, subscription or mutation operation. This function should implement the\n`ApolloOperationErrorHandlerFunction` interface from `vue-apollo-smart-ops` package. You can\nhave a custom handler in your app that shows a notification to the user, for example. If unspecified,\nthis functionality will be disabled and errors handled (or not) by Vue Apollo in the normal way.\nDefault value: \"undefined\"",
          "type": "string"
        },
        "vueApolloErrorHandlerFunctionImportFrom": {
          "description": "The import path where `vueApolloErrorHandlerFunction` should be imported from. Can be a package name\nor a local file path (anything that works in an import statement).\nDefault value: \"undefined\"",
          "type": "string"
        },
        "vueAppType": {
          "description": "The operation functions generated by `typescript-vue-apollo-smart-ops` include some functionality for\nerror handling. When an error occurs, the Vue app instance is passed to the error handler. You can\ncustomise the expected type of the app object. For example, a Nuxt.js app might use `NuxtApp` from\n`@nuxt/types/app` instead. When unspecified, the default type is `Vue` from `vue/types/vue`.\nDefault value: \"undefined\"",
          "type": "string"
        },
        "vueAppTypeImportFrom": {
          "description": "The import path where `vueAppType` should be imported from. Can be a package name or a local file path\n(anything that works in an import statement).\nDefault value: \"undefined\"",
          "type": "string"
        },
        "addDocBlocks": {
          "description": "Allows you to enable/disable the generation of docblocks in generated code.\nSome IDE's (like VSCode) add extra inline information with docblocks, you can disable this feature if\nyour preferred IDE does not.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "noGraphQLTag": {
          "description": "Deprecated. Changes the documentMode to `documentNode`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "gqlImport": {
          "description": "Customize from which module will `gql` be imported from.\nThis is useful if you want to use modules other than `graphql-tag`, e.g. `graphql.macro`.\nDefault value: \"graphql-tag#gql\"",
          "type": "string"
        },
        "documentNodeImport": {
          "description": "Customize from which module will `DocumentNode` be imported from.\nThis is useful if you want to use modules other than `graphql`, e.g. `@graphql-typed-document-node`.\nDefault value: \"graphql#DocumentNode\"",
          "type": "string"
        },
        "noExport": {
          "description": "Set this configuration to `true` if you wish to tell codegen to generate code with no `export` identifier.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariablePrefix": {
          "description": "Changes the GraphQL operations variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariableSuffix": {
          "description": "Changes the GraphQL operations variables suffix.\nDefault value: \"Document\"",
          "type": "string"
        },
        "fragmentVariablePrefix": {
          "description": "Changes the GraphQL fragments variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "fragmentVariableSuffix": {
          "description": "Changes the GraphQL fragments variables suffix.\nDefault value: \"FragmentDoc\"",
          "type": "string"
        },
        "documentMode": {
          "$ref": "#/definitions/DocumentMode",
          "description": "Declares how DocumentNode are created:\n\n- `graphQLTag`: `graphql-tag` or other modules (check `gqlImport`) will be used to generate document nodes. If this is used, document nodes are generated on client side i.e. the module used to generate this will be shipped to the client\n- `documentNode`: document nodes will be generated as objects when we generate the templates.\n- `documentNodeImportFragments`: Similar to documentNode except it imports external fragments instead of embedding them.\n- `external`: document nodes are imported from an external file. To be used with `importDocumentNodeExternallyFrom`\n\nNote that some plugins (like `typescript-graphql-request`) also supports `string` for this parameter.\nDefault value: \"graphQLTag\""
        },
        "optimizeDocumentNode": {
          "description": "If you are using `documentNode: documentMode | documentNodeImportFragments`, you can set this to `true` to apply document optimizations for your GraphQL document.\nThis will remove all \"loc\" and \"description\" fields from the compiled document, and will remove all empty arrays (such as `directives`, `arguments` and `variableDefinitions`).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "importOperationTypesFrom": {
          "description": "This config is used internally by presets, but you can use it manually to tell codegen to prefix all base types that it's using.\nThis is useful if you wish to generate base types from `typescript-operations` plugin into a different file, and import it from there.\nDefault value: \"\"",
          "type": "string"
        },
        "importDocumentNodeExternallyFrom": {
          "description": "This config should be used if `documentMode` is `external`. This has 2 usage:\n\n- any string: This would be the path to import document nodes from. This can be used if we want to manually create the document nodes e.g. Use `graphql-tag` in a separate file and export the generated document\n- 'near-operation-file': This is a special mode that is intended to be used with `near-operation-file` preset to import document nodes from those files. If these files are `.graphql` files, we make use of webpack loader.\nDefault value: \"\"",
          "type": "string"
        },
        "pureMagicComment": {
          "description": "This config adds PURE magic comment to the static variables to enforce treeshaking for your bundler.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "experimentalFragmentVariables": {
          "description": "If set to true, it will enable support for parsing variables on fragments.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "strictScalars": {
          "description": "Makes scalars strict.\n\nIf scalars are found in the schema that are not defined in `scalars`\nan error will be thrown during codegen.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "defaultScalarType": {
          "description": "Allows you to override the type that unknown scalars will have.\nDefault value: \"any\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally, you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserve underscores.\n\nAvailable case functions in `change-case-all` are `camelCase`, `capitalCase`, `constantCase`, `dotCase`, `headerCase`, `noCase`, `paramCase`, `pascalCase`, `pathCase`, `sentenceCase`, `snakeCase`, `lowerCase`, `localeLowerCase`, `lowerCaseFirst`, `spongeCase`, `titleCase`, `upperCase`, `localeUpperCase` and `upperCaseFirst`\n[See more](https://github.com/btxtiger/change-case-all)\nDefault value: \"change-case-all#pascalCase\""
        },
        "typesPrefix": { "description": "Prefixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "typesSuffix": { "description": "Suffixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "skipTypename": {
          "description": "Does not add `__typename` to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "dedupeFragments": {
          "description": "Removes fragment duplicates for reducing data transfer.\nIt is done by removing sub-fragments imports from fragment definition\nInstead - all of them are imported to the Operation node.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "inlineFragmentTypes": {
          "description": "Whether fragment types should be inlined into other operations.\n\"inline\" is the default behavior and will perform deep inlining fragment types within operation type definitions.\n\"combine\" is the previous behavior that uses fragment type references without inlining the types (and might cause issues with deeply nested fragment that uses list types).\nDefault value: \"inline\"",
          "type": "string"
        },
        "emitLegacyCommonJSImports": {
          "description": "Emit legacy common js imports.\nDefault it will be `true` this way it ensure that generated code works with [non-compliant bundlers](https://github.com/dotansimha/graphql-code-generator/issues/8065).\nDefault value: \"true\"",
          "type": "boolean"
        }
      }
    },
    "VueUrqlRawPluginConfig": {
      "description": "This plugin generates `urql` (https://github.com/FormidableLabs/urql) composition functions with TypeScript typings.",
      "type": "object",
      "properties": {
        "withComposition": {
          "description": "Customized the output by enabling/disabling the generated Vue Composition functions.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "urqlImportFrom": {
          "description": "You can specify module that exports components `Query`, `Mutation`, `Subscription`\nThis is useful for further abstraction of some common tasks (e.g. error handling).\nFilepath relative to generated file can be also specified.\nDefault value: \"urql\"",
          "type": "string"
        },
        "noGraphQLTag": {
          "description": "Deprecated. Changes the documentMode to `documentNode`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "gqlImport": {
          "description": "Customize from which module will `gql` be imported from.\nThis is useful if you want to use modules other than `graphql-tag`, e.g. `graphql.macro`.\nDefault value: \"graphql-tag#gql\"",
          "type": "string"
        },
        "documentNodeImport": {
          "description": "Customize from which module will `DocumentNode` be imported from.\nThis is useful if you want to use modules other than `graphql`, e.g. `@graphql-typed-document-node`.\nDefault value: \"graphql#DocumentNode\"",
          "type": "string"
        },
        "noExport": {
          "description": "Set this configuration to `true` if you wish to tell codegen to generate code with no `export` identifier.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariablePrefix": {
          "description": "Changes the GraphQL operations variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariableSuffix": {
          "description": "Changes the GraphQL operations variables suffix.\nDefault value: \"Document\"",
          "type": "string"
        },
        "fragmentVariablePrefix": {
          "description": "Changes the GraphQL fragments variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "fragmentVariableSuffix": {
          "description": "Changes the GraphQL fragments variables suffix.\nDefault value: \"FragmentDoc\"",
          "type": "string"
        },
        "documentMode": {
          "$ref": "#/definitions/DocumentMode",
          "description": "Declares how DocumentNode are created:\n\n- `graphQLTag`: `graphql-tag` or other modules (check `gqlImport`) will be used to generate document nodes. If this is used, document nodes are generated on client side i.e. the module used to generate this will be shipped to the client\n- `documentNode`: document nodes will be generated as objects when we generate the templates.\n- `documentNodeImportFragments`: Similar to documentNode except it imports external fragments instead of embedding them.\n- `external`: document nodes are imported from an external file. To be used with `importDocumentNodeExternallyFrom`\n\nNote that some plugins (like `typescript-graphql-request`) also supports `string` for this parameter.\nDefault value: \"graphQLTag\""
        },
        "optimizeDocumentNode": {
          "description": "If you are using `documentNode: documentMode | documentNodeImportFragments`, you can set this to `true` to apply document optimizations for your GraphQL document.\nThis will remove all \"loc\" and \"description\" fields from the compiled document, and will remove all empty arrays (such as `directives`, `arguments` and `variableDefinitions`).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "importOperationTypesFrom": {
          "description": "This config is used internally by presets, but you can use it manually to tell codegen to prefix all base types that it's using.\nThis is useful if you wish to generate base types from `typescript-operations` plugin into a different file, and import it from there.\nDefault value: \"\"",
          "type": "string"
        },
        "importDocumentNodeExternallyFrom": {
          "description": "This config should be used if `documentMode` is `external`. This has 2 usage:\n\n- any string: This would be the path to import document nodes from. This can be used if we want to manually create the document nodes e.g. Use `graphql-tag` in a separate file and export the generated document\n- 'near-operation-file': This is a special mode that is intended to be used with `near-operation-file` preset to import document nodes from those files. If these files are `.graphql` files, we make use of webpack loader.\nDefault value: \"\"",
          "type": "string"
        },
        "pureMagicComment": {
          "description": "This config adds PURE magic comment to the static variables to enforce treeshaking for your bundler.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "experimentalFragmentVariables": {
          "description": "If set to true, it will enable support for parsing variables on fragments.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "strictScalars": {
          "description": "Makes scalars strict.\n\nIf scalars are found in the schema that are not defined in `scalars`\nan error will be thrown during codegen.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "defaultScalarType": {
          "description": "Allows you to override the type that unknown scalars will have.\nDefault value: \"any\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally, you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserve underscores.\n\nAvailable case functions in `change-case-all` are `camelCase`, `capitalCase`, `constantCase`, `dotCase`, `headerCase`, `noCase`, `paramCase`, `pascalCase`, `pathCase`, `sentenceCase`, `snakeCase`, `lowerCase`, `localeLowerCase`, `lowerCaseFirst`, `spongeCase`, `titleCase`, `upperCase`, `localeUpperCase` and `upperCaseFirst`\n[See more](https://github.com/btxtiger/change-case-all)\nDefault value: \"change-case-all#pascalCase\""
        },
        "typesPrefix": { "description": "Prefixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "typesSuffix": { "description": "Suffixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "skipTypename": {
          "description": "Does not add `__typename` to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "dedupeFragments": {
          "description": "Removes fragment duplicates for reducing data transfer.\nIt is done by removing sub-fragments imports from fragment definition\nInstead - all of them are imported to the Operation node.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "inlineFragmentTypes": {
          "description": "Whether fragment types should be inlined into other operations.\n\"inline\" is the default behavior and will perform deep inlining fragment types within operation type definitions.\n\"combine\" is the previous behavior that uses fragment type references without inlining the types (and might cause issues with deeply nested fragment that uses list types).\nDefault value: \"inline\"",
          "type": "string"
        },
        "emitLegacyCommonJSImports": {
          "description": "Emit legacy common js imports.\nDefault it will be `true` this way it ensure that generated code works with [non-compliant bundlers](https://github.com/dotansimha/graphql-code-generator/issues/8065).\nDefault value: \"true\"",
          "type": "boolean"
        }
      }
    },
    "StencilApolloRawPluginConfig": {
      "description": "This plugin generates Stencil Apollo functional components typings\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` - and thus shares a similar configuration.",
      "type": "object",
      "properties": {
        "componentType": {
          "$ref": "#/definitions/StencilComponentType",
          "description": "Customize the output of the plugin - you can choose to generate a Component class or a function component.\nDefault value: \"functional\""
        },
        "noGraphQLTag": {
          "description": "Deprecated. Changes the documentMode to `documentNode`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "gqlImport": {
          "description": "Customize from which module will `gql` be imported from.\nThis is useful if you want to use modules other than `graphql-tag`, e.g. `graphql.macro`.\nDefault value: \"graphql-tag#gql\"",
          "type": "string"
        },
        "documentNodeImport": {
          "description": "Customize from which module will `DocumentNode` be imported from.\nThis is useful if you want to use modules other than `graphql`, e.g. `@graphql-typed-document-node`.\nDefault value: \"graphql#DocumentNode\"",
          "type": "string"
        },
        "noExport": {
          "description": "Set this configuration to `true` if you wish to tell codegen to generate code with no `export` identifier.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariablePrefix": {
          "description": "Changes the GraphQL operations variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariableSuffix": {
          "description": "Changes the GraphQL operations variables suffix.\nDefault value: \"Document\"",
          "type": "string"
        },
        "fragmentVariablePrefix": {
          "description": "Changes the GraphQL fragments variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "fragmentVariableSuffix": {
          "description": "Changes the GraphQL fragments variables suffix.\nDefault value: \"FragmentDoc\"",
          "type": "string"
        },
        "documentMode": {
          "$ref": "#/definitions/DocumentMode",
          "description": "Declares how DocumentNode are created:\n\n- `graphQLTag`: `graphql-tag` or other modules (check `gqlImport`) will be used to generate document nodes. If this is used, document nodes are generated on client side i.e. the module used to generate this will be shipped to the client\n- `documentNode`: document nodes will be generated as objects when we generate the templates.\n- `documentNodeImportFragments`: Similar to documentNode except it imports external fragments instead of embedding them.\n- `external`: document nodes are imported from an external file. To be used with `importDocumentNodeExternallyFrom`\n\nNote that some plugins (like `typescript-graphql-request`) also supports `string` for this parameter.\nDefault value: \"graphQLTag\""
        },
        "optimizeDocumentNode": {
          "description": "If you are using `documentNode: documentMode | documentNodeImportFragments`, you can set this to `true` to apply document optimizations for your GraphQL document.\nThis will remove all \"loc\" and \"description\" fields from the compiled document, and will remove all empty arrays (such as `directives`, `arguments` and `variableDefinitions`).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "importOperationTypesFrom": {
          "description": "This config is used internally by presets, but you can use it manually to tell codegen to prefix all base types that it's using.\nThis is useful if you wish to generate base types from `typescript-operations` plugin into a different file, and import it from there.\nDefault value: \"\"",
          "type": "string"
        },
        "importDocumentNodeExternallyFrom": {
          "description": "This config should be used if `documentMode` is `external`. This has 2 usage:\n\n- any string: This would be the path to import document nodes from. This can be used if we want to manually create the document nodes e.g. Use `graphql-tag` in a separate file and export the generated document\n- 'near-operation-file': This is a special mode that is intended to be used with `near-operation-file` preset to import document nodes from those files. If these files are `.graphql` files, we make use of webpack loader.\nDefault value: \"\"",
          "type": "string"
        },
        "pureMagicComment": {
          "description": "This config adds PURE magic comment to the static variables to enforce treeshaking for your bundler.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "experimentalFragmentVariables": {
          "description": "If set to true, it will enable support for parsing variables on fragments.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "strictScalars": {
          "description": "Makes scalars strict.\n\nIf scalars are found in the schema that are not defined in `scalars`\nan error will be thrown during codegen.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "defaultScalarType": {
          "description": "Allows you to override the type that unknown scalars will have.\nDefault value: \"any\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally, you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserve underscores.\n\nAvailable case functions in `change-case-all` are `camelCase`, `capitalCase`, `constantCase`, `dotCase`, `headerCase`, `noCase`, `paramCase`, `pascalCase`, `pathCase`, `sentenceCase`, `snakeCase`, `lowerCase`, `localeLowerCase`, `lowerCaseFirst`, `spongeCase`, `titleCase`, `upperCase`, `localeUpperCase` and `upperCaseFirst`\n[See more](https://github.com/btxtiger/change-case-all)\nDefault value: \"change-case-all#pascalCase\""
        },
        "typesPrefix": { "description": "Prefixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "typesSuffix": { "description": "Suffixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "skipTypename": {
          "description": "Does not add `__typename` to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "dedupeFragments": {
          "description": "Removes fragment duplicates for reducing data transfer.\nIt is done by removing sub-fragments imports from fragment definition\nInstead - all of them are imported to the Operation node.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "inlineFragmentTypes": {
          "description": "Whether fragment types should be inlined into other operations.\n\"inline\" is the default behavior and will perform deep inlining fragment types within operation type definitions.\n\"combine\" is the previous behavior that uses fragment type references without inlining the types (and might cause issues with deeply nested fragment that uses list types).\nDefault value: \"inline\"",
          "type": "string"
        },
        "emitLegacyCommonJSImports": {
          "description": "Emit legacy common js imports.\nDefault it will be `true` this way it ensure that generated code works with [non-compliant bundlers](https://github.com/dotansimha/graphql-code-generator/issues/8065).\nDefault value: \"true\"",
          "type": "boolean"
        }
      }
    },
    "TypeScriptDocumentNodesRawPluginConfig": {
      "description": "This plugin generates TypeScript source `.ts` file from GraphQL files `.graphql`.",
      "type": "object",
      "properties": {
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention_1",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally, you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserve underscores.\n\nAvailable case functions in `change-case-all` are `camelCase`, `capitalCase`, `constantCase`, `dotCase`, `headerCase`, `noCase`, `paramCase`, `pascalCase`, `pathCase`, `sentenceCase`, `snakeCase`, `lowerCase`, `localeLowerCase`, `lowerCaseFirst`, `spongeCase`, `titleCase`, `upperCase`, `localeUpperCase` and `upperCaseFirst`\n[See more](https://github.com/btxtiger/change-case-all)\nDefault value: \"change-case-all#pascalCase\""
        },
        "namePrefix": { "description": "Adds prefix to the name\nDefault value: \"\"", "type": "string" },
        "nameSuffix": { "description": "Adds suffix to the name\nDefault value: \"\"", "type": "string" },
        "fragmentPrefix": {
          "description": "Adds prefix to the fragment variable\nDefault value: \"\"",
          "type": "string"
        },
        "fragmentSuffix": {
          "description": "Adds suffix to the fragment variable\nDefault value: \"\"",
          "type": "string"
        },
        "gqlImport": {
          "description": "Customize from which module will `gql` be imported from.\nThis is useful if you want to use modules other than `graphql-tag`, e.g. `graphql.macro`.\nDefault value: \"graphql-tag#gql\"",
          "type": "string"
        },
        "documentNodeImport": {
          "description": "Customize from which module will `DocumentNode` be imported from.\nThis is useful if you want to use modules other than `graphql`, e.g. `@graphql-typed-document-node`.\nDefault value: \"graphql#DocumentNode\"",
          "type": "string"
        },
        "noExport": {
          "description": "Set this configuration to `true` if you wish to tell codegen to generate code with no `export` identifier.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariablePrefix": {
          "description": "Changes the GraphQL operations variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "documentVariableSuffix": {
          "description": "Changes the GraphQL operations variables suffix.\nDefault value: \"Document\"",
          "type": "string"
        },
        "fragmentVariablePrefix": {
          "description": "Changes the GraphQL fragments variables prefix.\nDefault value: \"\"",
          "type": "string"
        },
        "fragmentVariableSuffix": {
          "description": "Changes the GraphQL fragments variables suffix.\nDefault value: \"FragmentDoc\"",
          "type": "string"
        },
        "documentMode": {
          "$ref": "#/definitions/DocumentMode_2",
          "description": "Declares how DocumentNode are created:\n\n- `graphQLTag`: `graphql-tag` or other modules (check `gqlImport`) will be used to generate document nodes. If this is used, document nodes are generated on client side i.e. the module used to generate this will be shipped to the client\n- `documentNode`: document nodes will be generated as objects when we generate the templates.\n- `documentNodeImportFragments`: Similar to documentNode except it imports external fragments instead of embedding them.\n- `external`: document nodes are imported from an external file. To be used with `importDocumentNodeExternallyFrom`\n\nNote that some plugins (like `typescript-graphql-request`) also supports `string` for this parameter.\nDefault value: \"graphQLTag\""
        },
        "optimizeDocumentNode": {
          "description": "If you are using `documentMode: documentNode | documentNodeImportFragments`, you can set this to `true` to apply document optimizations for your GraphQL document.\nThis will remove all \"loc\" and \"description\" fields from the compiled document, and will remove all empty arrays (such as `directives`, `arguments` and `variableDefinitions`).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "importOperationTypesFrom": {
          "description": "This config is used internally by presets, but you can use it manually to tell codegen to prefix all base types that it's using.\nThis is useful if you wish to generate base types from `typescript-operations` plugin into a different file, and import it from there.\nDefault value: \"\"",
          "type": "string"
        },
        "importDocumentNodeExternallyFrom": {
          "description": "This config should be used if `documentMode` is `external`. This has 2 usage:\n\n- any string: This would be the path to import document nodes from. This can be used if we want to manually create the document nodes e.g. Use `graphql-tag` in a separate file and export the generated document\n- 'near-operation-file': This is a special mode that is intended to be used with `near-operation-file` preset to import document nodes from those files. If these files are `.graphql` files, we make use of webpack loader.\nDefault value: \"\"",
          "type": "string"
        },
        "pureMagicComment": {
          "description": "This config adds PURE magic comment to the static variables to enforce treeshaking for your bundler.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "experimentalFragmentVariables": {
          "description": "If set to true, it will enable support for parsing variables on fragments.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "strictScalars": {
          "description": "Makes scalars strict.\n\nIf scalars are found in the schema that are not defined in `scalars`\nan error will be thrown during codegen.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "defaultScalarType": {
          "description": "Allows you to override the type that unknown scalars will have.\nDefault value: \"any\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap_1",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "typesPrefix": { "description": "Prefixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "typesSuffix": { "description": "Suffixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "skipTypename": {
          "description": "Does not add `__typename` to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "inlineFragmentTypes": {
          "description": "Whether fragment types should be inlined into other operations.\n\"inline\" is the default behavior and will perform deep inlining fragment types within operation type definitions.\n\"combine\" is the previous behavior that uses fragment type references without inlining the types (and might cause issues with deeply nested fragment that uses list types).\n\"mask\" transforms the types for use with fragment masking. Useful when masked types are needed when not using the \"client\" preset e.g. such as combining it with Apollo Client's data masking feature.\nDefault value: \"inline\"",
          "type": "string"
        },
        "emitLegacyCommonJSImports": {
          "description": "Emit legacy common js imports.\nDefault it will be `true` this way it ensure that generated code works with [non-compliant bundlers](https://github.com/dotansimha/graphql-code-generator/issues/8065).\nDefault value: \"true\"",
          "type": "boolean"
        },
        "importExtension": {
          "description": "Append this extension to all imports.\nUseful for ESM environments that require file extensions in import statements.",
          "type": "string"
        },
        "extractAllFieldsToTypes": {
          "description": "Extract all field types to their own types, instead of inlining them.\nThis helps to reduce type duplication, and makes type errors more readable.\nIt can also significantly reduce the size of the generated code, the generation time,\nand the typechecking time.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "printFieldsOnNewLines": {
          "description": "If you prefer to have each field in generated types printed on a new line, set this to true.\nThis can be useful for improving readability of the resulting types,\nwithout resorting to running tools like Prettier on the output.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "includeExternalFragments": {
          "description": "Whether to include external fragments in the generated code. External fragments are not defined\nin the same location as the operation definition.\nDefault value: \"false\"",
          "type": "boolean"
        }
      }
    },
    "MSWConfig": {
      "description": "This plugin generates `msw` (https://github.com/mswjs/msw) mock handlers with TypeScript typings.",
      "type": "object",
      "properties": {
        "link": {
          "description": "GraphQL endpoint to use when working with multiple backends.",
          "type": "object",
          "properties": {
            "endpoint": { "type": "string" },
            "name": { "type": "string" },
            "withSuffix": { "type": "boolean" }
          }
        }
      }
    },
    "JavaApolloAndroidPluginConfig": {
      "description": "This plugin and presets creates generated mappers and parsers for a complete type-safe GraphQL requests, for developers that uses Apollo Android runtime.",
      "type": "object",
      "properties": {
        "package": {
          "description": "Customize the Java package name for the generated operations. The default package name will be generated according to the output file path.",
          "type": "string"
        },
        "typePackage": {
          "description": "Customize the Java package name for the types generated based on input types.",
          "type": "string"
        },
        "fragmentPackage": {
          "description": "Customize the Java package name for the fragments generated classes.",
          "type": "string"
        },
        "fileType": { "$ref": "#/definitions/FileType" },
        "strictScalars": {
          "description": "Makes scalars strict.\n\nIf scalars are found in the schema that are not defined in `scalars`\nan error will be thrown during codegen.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "defaultScalarType": {
          "description": "Allows you to override the type that unknown scalars will have.\nDefault value: \"any\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally, you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserve underscores.\n\nAvailable case functions in `change-case-all` are `camelCase`, `capitalCase`, `constantCase`, `dotCase`, `headerCase`, `noCase`, `paramCase`, `pascalCase`, `pathCase`, `sentenceCase`, `snakeCase`, `lowerCase`, `localeLowerCase`, `lowerCaseFirst`, `spongeCase`, `titleCase`, `upperCase`, `localeUpperCase` and `upperCaseFirst`\n[See more](https://github.com/btxtiger/change-case-all)\nDefault value: \"change-case-all#pascalCase\""
        },
        "typesPrefix": { "description": "Prefixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "typesSuffix": { "description": "Suffixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "skipTypename": {
          "description": "Does not add `__typename` to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "dedupeFragments": {
          "description": "Removes fragment duplicates for reducing data transfer.\nIt is done by removing sub-fragments imports from fragment definition\nInstead - all of them are imported to the Operation node.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "inlineFragmentTypes": {
          "description": "Whether fragment types should be inlined into other operations.\n\"inline\" is the default behavior and will perform deep inlining fragment types within operation type definitions.\n\"combine\" is the previous behavior that uses fragment type references without inlining the types (and might cause issues with deeply nested fragment that uses list types).\nDefault value: \"inline\"",
          "type": "string"
        },
        "emitLegacyCommonJSImports": {
          "description": "Emit legacy common js imports.\nDefault it will be `true` this way it ensure that generated code works with [non-compliant bundlers](https://github.com/dotansimha/graphql-code-generator/issues/8065).\nDefault value: \"true\"",
          "type": "boolean"
        }
      }
    },
    "JavaResolversPluginRawConfig": {
      "type": "object",
      "properties": {
        "package": {
          "description": "Customize the Java package name. The default package name will be generated according to the output file path.",
          "type": "string"
        },
        "mappers": {
          "description": "Allow you to replace specific GraphQL types with your custom model classes. This is useful when you want to make sure your resolvers returns the correct class.\nThe default value is the values set by `defaultMapper` configuration.\nYou can use a direct path to the package, or use `package#class` syntax to have it imported.",
          "type": "object",
          "additionalProperties": { "type": "string" }
        },
        "defaultMapper": {
          "description": "Sets the default mapper value in case it's not specified by `mappers`.\nYou can use a direct path to the package, or use `package#class` syntax to have it imported.\nThe default mapper is Java's `Object`.\nDefault value: \"Object\"",
          "type": "string"
        },
        "className": {
          "description": "Allow you to customize the parent class name.\nDefault value: \"Resolvers\"",
          "type": "string"
        },
        "listType": {
          "description": "Allow you to customize the list type.\nDefault value: \"Iterable\"",
          "type": "string"
        },
        "strictScalars": {
          "description": "Makes scalars strict.\n\nIf scalars are found in the schema that are not defined in `scalars`\nan error will be thrown during codegen.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "defaultScalarType": {
          "description": "Allows you to override the type that unknown scalars will have.\nDefault value: \"any\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally, you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserve underscores.\n\nAvailable case functions in `change-case-all` are `camelCase`, `capitalCase`, `constantCase`, `dotCase`, `headerCase`, `noCase`, `paramCase`, `pascalCase`, `pathCase`, `sentenceCase`, `snakeCase`, `lowerCase`, `localeLowerCase`, `lowerCaseFirst`, `spongeCase`, `titleCase`, `upperCase`, `localeUpperCase` and `upperCaseFirst`\n[See more](https://github.com/btxtiger/change-case-all)\nDefault value: \"change-case-all#pascalCase\""
        },
        "typesPrefix": { "description": "Prefixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "typesSuffix": { "description": "Suffixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "skipTypename": {
          "description": "Does not add `__typename` to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "dedupeFragments": {
          "description": "Removes fragment duplicates for reducing data transfer.\nIt is done by removing sub-fragments imports from fragment definition\nInstead - all of them are imported to the Operation node.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "inlineFragmentTypes": {
          "description": "Whether fragment types should be inlined into other operations.\n\"inline\" is the default behavior and will perform deep inlining fragment types within operation type definitions.\n\"combine\" is the previous behavior that uses fragment type references without inlining the types (and might cause issues with deeply nested fragment that uses list types).\nDefault value: \"inline\"",
          "type": "string"
        },
        "emitLegacyCommonJSImports": {
          "description": "Emit legacy common js imports.\nDefault it will be `true` this way it ensure that generated code works with [non-compliant bundlers](https://github.com/dotansimha/graphql-code-generator/issues/8065).\nDefault value: \"true\"",
          "type": "boolean"
        }
      }
    },
    "KotlinResolversPluginRawConfig": {
      "type": "object",
      "properties": {
        "package": {
          "description": "Customize the Java package name. The default package name will be generated according to the output file path.",
          "type": "string"
        },
        "enumValues": {
          "$ref": "#/definitions/EnumValuesMap_2",
          "description": "Overrides the default value of enum values declared in your GraphQL schema."
        },
        "listType": {
          "description": "Allow you to customize the list type\nDefault value: \"Iterable\"",
          "type": "string"
        },
        "withTypes": {
          "description": "Allow you to enable generation for the types\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitJvmStatic": {
          "description": "Allow you to omit JvmStatic annotation\nDefault value: \"false\"",
          "type": "boolean"
        },
        "strictScalars": {
          "description": "Makes scalars strict.\n\nIf scalars are found in the schema that are not defined in `scalars`\nan error will be thrown during codegen.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "defaultScalarType": {
          "description": "Allows you to override the type that unknown scalars will have.\nDefault value: \"any\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally, you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserve underscores.\n\nAvailable case functions in `change-case-all` are `camelCase`, `capitalCase`, `constantCase`, `dotCase`, `headerCase`, `noCase`, `paramCase`, `pascalCase`, `pathCase`, `sentenceCase`, `snakeCase`, `lowerCase`, `localeLowerCase`, `lowerCaseFirst`, `spongeCase`, `titleCase`, `upperCase`, `localeUpperCase` and `upperCaseFirst`\n[See more](https://github.com/btxtiger/change-case-all)\nDefault value: \"change-case-all#pascalCase\""
        },
        "typesPrefix": { "description": "Prefixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "typesSuffix": { "description": "Suffixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "skipTypename": {
          "description": "Does not add `__typename` to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "dedupeFragments": {
          "description": "Removes fragment duplicates for reducing data transfer.\nIt is done by removing sub-fragments imports from fragment definition\nInstead - all of them are imported to the Operation node.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "inlineFragmentTypes": {
          "description": "Whether fragment types should be inlined into other operations.\n\"inline\" is the default behavior and will perform deep inlining fragment types within operation type definitions.\n\"combine\" is the previous behavior that uses fragment type references without inlining the types (and might cause issues with deeply nested fragment that uses list types).\nDefault value: \"inline\"",
          "type": "string"
        },
        "emitLegacyCommonJSImports": {
          "description": "Emit legacy common js imports.\nDefault it will be `true` this way it ensure that generated code works with [non-compliant bundlers](https://github.com/dotansimha/graphql-code-generator/issues/8065).\nDefault value: \"true\"",
          "type": "boolean"
        }
      }
    },
    "FlowPluginConfig": {
      "description": "This plugin generates Flow types based on your `GraphQLSchema`.\n\nIt generates types for your entire schema: types, input types, enum, interface, scalar and union.",
      "type": "object",
      "properties": {
        "useFlowExactObjects": {
          "description": "Generates Flow types as Exact types.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "useFlowReadOnlyTypes": {
          "description": "Generates read-only Flow types\nDefault value: \"false\"",
          "type": "boolean"
        },
        "addUnderscoreToArgsType": {
          "description": "Adds `_` to generated `Args` types in order to avoid duplicate identifiers.",
          "type": "boolean"
        },
        "enumValues": {
          "$ref": "#/definitions/EnumValuesMap_2",
          "description": "Overrides the default value of enum values declared in your GraphQL schema.\nYou can also map the entire enum to an external type by providing a string that of `module#type`."
        },
        "declarationKind": {
          "description": "Overrides the default output for various GraphQL elements.",
          "anyOf": [
            { "$ref": "#/definitions/DeclarationKindConfig_2" },
            { "enum": ["abstract class", "class", "interface", "type"], "type": "string" }
          ]
        },
        "enumPrefix": {
          "description": "Allow you to disable prefixing for generated enums, works in combination with `typesPrefix`.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "fieldWrapperValue": {
          "description": "Allow you to add wrapper for field type, use T as the generic value. Make sure to set `wrapFieldDefinitions` to `true` in order to make this flag work.\nDefault value: \"T\"",
          "type": "string"
        },
        "wrapFieldDefinitions": {
          "description": "Set to `true` in order to wrap field definitions with `FieldWrapper`.\nThis is useful to allow return types such as Promises and functions.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "onlyEnums": {
          "description": "This will cause the generator to emit types for enums only\nDefault value: \"false\"",
          "type": "boolean"
        },
        "onlyOperationTypes": {
          "description": "This will cause the generator to emit types for operations only (basically only enums and scalars)\nDefault value: \"false\"",
          "type": "boolean"
        },
        "ignoreEnumValuesFromSchema": {
          "description": "This will cause the generator to ignore enum values defined in GraphQLSchema\nDefault value: \"false\"",
          "type": "boolean"
        },
        "wrapEntireFieldDefinitions": {
          "type": "boolean",
          "description": "Set to `true` in order to wrap field definitions with `EntireFieldWrapper`.\nThis is useful to allow return types such as Promises and functions for fields.\nDiffers from `wrapFieldDefinitions` in that this wraps the entire field definition if i.e. the field is an Array, while\n`wrapFieldDefinitions` will wrap every single value inside the array.\nDefault value: \"true\""
        },
        "entireFieldWrapperValue": {
          "type": "string",
          "description": "Allow to override the type value of `EntireFieldWrapper`. This wrapper applies outside of Array and Maybe\nunlike `fieldWrapperValue`, that will wrap the inner type.\nDefault value: \"T | Promise<T> | (() => T | Promise<T>)\""
        },
        "directiveArgumentAndInputFieldMappings": {
          "$ref": "#/definitions/DirectiveArgumentAndInputFieldMappings_2",
          "description": "Replaces a GraphQL scalar with a custom type based on the applied directive on an argument or input field.\n\nYou can use both `module#type` and `module#namespace#type` syntax.\nWill NOT work with introspected schemas since directives are not exported.\nOnly works with directives on ARGUMENT_DEFINITION or INPUT_FIELD_DEFINITION.\n\n**WARNING:** Using this option does only change the type definitions.\n\nFor actually ensuring that a type is correct at runtime you will have to use schema transforms (e.g. with [@graphql-tools/utils mapSchema](https://graphql-tools.com/docs/schema-directives)) that apply those rules!\nOtherwise, you might end up with a runtime type mismatch which could cause unnoticed bugs or runtime errors.\n\nPlease use this configuration option with care!"
        },
        "directiveArgumentAndInputFieldMappingTypeSuffix": {
          "description": "Adds a suffix to the imported names to prevent name clashes.",
          "type": "string"
        },
        "strictScalars": {
          "description": "Makes scalars strict.\n\nIf scalars are found in the schema that are not defined in `scalars`\nan error will be thrown during codegen.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "defaultScalarType": {
          "description": "Allows you to override the type that unknown scalars will have.\nDefault value: \"any\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally, you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserve underscores.\n\nAvailable case functions in `change-case-all` are `camelCase`, `capitalCase`, `constantCase`, `dotCase`, `headerCase`, `noCase`, `paramCase`, `pascalCase`, `pathCase`, `sentenceCase`, `snakeCase`, `lowerCase`, `localeLowerCase`, `lowerCaseFirst`, `spongeCase`, `titleCase`, `upperCase`, `localeUpperCase` and `upperCaseFirst`\n[See more](https://github.com/btxtiger/change-case-all)\nDefault value: \"change-case-all#pascalCase\""
        },
        "typesPrefix": { "description": "Prefixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "typesSuffix": { "description": "Suffixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "skipTypename": {
          "description": "Does not add `__typename` to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "dedupeFragments": {
          "description": "Removes fragment duplicates for reducing data transfer.\nIt is done by removing sub-fragments imports from fragment definition\nInstead - all of them are imported to the Operation node.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "inlineFragmentTypes": {
          "description": "Whether fragment types should be inlined into other operations.\n\"inline\" is the default behavior and will perform deep inlining fragment types within operation type definitions.\n\"combine\" is the previous behavior that uses fragment type references without inlining the types (and might cause issues with deeply nested fragment that uses list types).\nDefault value: \"inline\"",
          "type": "string"
        },
        "emitLegacyCommonJSImports": {
          "description": "Emit legacy common js imports.\nDefault it will be `true` this way it ensure that generated code works with [non-compliant bundlers](https://github.com/dotansimha/graphql-code-generator/issues/8065).\nDefault value: \"true\"",
          "type": "boolean"
        }
      }
    },
    "FlowResolversPluginConfig": {
      "description": "This plugin generates resolvers signature based on your `GraphQLSchema`.\n\nIt generates types for your entire schema: types, input types, enum, interface, scalar and union.\n\nThis plugin requires you to use `@graphql-codegen/flow` as well, because it depends on it's types.",
      "type": "object",
      "properties": {
        "addUnderscoreToArgsType": {
          "description": "Adds `_` to generated `Args` types in order to avoid duplicate identifiers.",
          "type": "boolean"
        },
        "contextType": {
          "description": "Use this configuration to set a custom type for your `context`, and it will\naffect all the resolvers, without the need to override it using generics each time.\nIf you wish to use an external type and import it from another file, you can use `add` plugin\nand add the required `import` statement, or you can use a `module#type` syntax.",
          "type": "string"
        },
        "fieldContextTypes": {
          "$ref": "#/definitions/Array_1",
          "description": "Use this to set a custom type for a specific field `context`.\nIt will only affect the targeted resolvers.\nYou can either use `Field.Path#ContextTypeName` or `Field.Path#ExternalFileName#ContextTypeName`"
        },
        "rootValueType": {
          "description": "Use this configuration to set a custom type for the `rootValue`, and it will\naffect resolvers of all root types (Query, Mutation and Subscription), without the need to override it using generics each time.\nIf you wish to use an external type and import it from another file, you can use `add` plugin\nand add the required `import` statement, or you can use both `module#type` or `module#namespace#type` syntax.",
          "type": "string"
        },
        "directiveContextTypes": {
          "$ref": "#/definitions/Array_1",
          "description": "Use this to set a custom type for a specific field `context` decorated by a directive.\nIt will only affect the targeted resolvers.\nYou can either use `Field.Path#ContextTypeName` or `Field.Path#ExternalFileName#ContextTypeName`\n\nContextTypeName should by a generic Type that take the context or field context type as only type parameter."
        },
        "mapperTypeSuffix": {
          "description": "Adds a suffix to the imported names to prevent name clashes.",
          "type": "string"
        },
        "mappers": {
          "description": "Replaces a GraphQL type usage with a custom type, allowing you to return custom object from\nyour resolvers.\nYou can use both `module#type` and `module#namespace#type` syntax.",
          "type": "object",
          "additionalProperties": { "type": "string" }
        },
        "defaultMapper": {
          "description": "Allow you to set the default mapper when it's not being override by `mappers` or generics.\nYou can specify a type name, or specify a string in `module#type` or `module#namespace#type` format.\nThe default value of mappers is the TypeScript type generated by `typescript` package.",
          "type": "string"
        },
        "avoidOptionals": {
          "description": "This will cause the generator to avoid using optionals (`?`),\nso all field resolvers must be implemented in order to avoid compilation errors.\nDefault value: \"false\"",
          "anyOf": [{ "$ref": "#/definitions/AvoidOptionalsConfig_2" }, { "type": "boolean" }]
        },
        "showUnusedMappers": {
          "description": "Warns about unused mappers.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "enumValues": {
          "$ref": "#/definitions/EnumValuesMap_2",
          "description": "Overrides the default value of enum values declared in your GraphQL schema, supported\nin this plugin because of the need for integration with `typescript` package.\nSee documentation under `typescript` plugin for more information and examples."
        },
        "resolverTypeWrapperSignature": {
          "description": "Allow you to override `resolverTypeWrapper` definition.\nDefault value: \"Promise<T> | T\"",
          "type": "string"
        },
        "federation": { "description": "Supports Apollo Federation\nDefault value: \"false\"", "type": "boolean" },
        "enumPrefix": {
          "description": "Allow you to disable prefixing for generated enums, works in combination with `typesPrefix`.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "optionalResolveType": {
          "description": "Sets the `__resolveType` field as optional field.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "immutableTypes": {
          "description": "Generates immutable types by adding `readonly` to properties and uses `ReadonlyArray`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "namespacedImportName": {
          "description": "Prefixes all GraphQL related generated types with that value, as namespaces import.\nYou can use this feature to allow separation of plugins to different files.\nDefault value: \"''\"",
          "type": "string"
        },
        "resolverTypeSuffix": {
          "description": "Suffix we add to each generated type resolver.\nDefault value: \"Resolvers\"",
          "type": "string"
        },
        "allResolversTypeName": {
          "description": "The type name to use when exporting all resolvers signature as unified type.\nDefault value: \"Resolvers\"",
          "type": "string"
        },
        "internalResolversPrefix": {
          "type": "string",
          "description": "Defines the prefix value used for `__resolveType` and `__isTypeOf` resolvers.\nIf you are using `mercurius-js`, please set this field to empty string for better compatibility.\nDefault value: \"'__'\""
        },
        "onlyResolveTypeForInterfaces": {
          "type": "boolean",
          "description": "Turning this flag to `true` will generate resolver signature that has only `resolveType` for interfaces, forcing developers to write inherited type resolvers in the type itself.\nDefault value: \"false\""
        },
        "strictScalars": {
          "description": "Makes scalars strict.\n\nIf scalars are found in the schema that are not defined in `scalars`\nan error will be thrown during codegen.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "defaultScalarType": {
          "description": "Allows you to override the type that unknown scalars will have.\nDefault value: \"any\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally, you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserve underscores.\n\nAvailable case functions in `change-case-all` are `camelCase`, `capitalCase`, `constantCase`, `dotCase`, `headerCase`, `noCase`, `paramCase`, `pascalCase`, `pathCase`, `sentenceCase`, `snakeCase`, `lowerCase`, `localeLowerCase`, `lowerCaseFirst`, `spongeCase`, `titleCase`, `upperCase`, `localeUpperCase` and `upperCaseFirst`\n[See more](https://github.com/btxtiger/change-case-all)\nDefault value: \"change-case-all#pascalCase\""
        },
        "typesPrefix": { "description": "Prefixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "typesSuffix": { "description": "Suffixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "skipTypename": {
          "description": "Does not add `__typename` to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "dedupeFragments": {
          "description": "Removes fragment duplicates for reducing data transfer.\nIt is done by removing sub-fragments imports from fragment definition\nInstead - all of them are imported to the Operation node.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "inlineFragmentTypes": {
          "description": "Whether fragment types should be inlined into other operations.\n\"inline\" is the default behavior and will perform deep inlining fragment types within operation type definitions.\n\"combine\" is the previous behavior that uses fragment type references without inlining the types (and might cause issues with deeply nested fragment that uses list types).\nDefault value: \"inline\"",
          "type": "string"
        },
        "emitLegacyCommonJSImports": {
          "description": "Emit legacy common js imports.\nDefault it will be `true` this way it ensure that generated code works with [non-compliant bundlers](https://github.com/dotansimha/graphql-code-generator/issues/8065).\nDefault value: \"true\"",
          "type": "boolean"
        }
      }
    },
    "FlowDocumentsPluginConfig": {
      "description": "This plugin generates Flow types based on your `GraphQLSchema` and your GraphQL operations and fragments.\n\nIt generates types for your GraphQL documents: Query, Mutation, Subscription and Fragment.\n\nThis plugin requires you to use `@graphql-codegen/flow` as well, because it depends on its types.",
      "type": "object",
      "properties": {
        "useFlowExactObjects": {
          "description": "Generates Flow types as Exact types.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "useFlowReadOnlyTypes": {
          "description": "Generates read-only Flow types\nDefault value: \"false\"",
          "type": "boolean"
        },
        "flattenGeneratedTypes": {
          "description": "Flatten fragment spread and inline fragments into a simple selection set before generating.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "preResolveTypes": {
          "description": "Uses primitive types where possible.\nSet to `false` in order to use `Pick` and take use the types generated by `typescript` plugin.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "skipTypeNameForRoot": {
          "description": "Avoid adding `__typename` for root types. This is ignored when a selection explicitly specifies `__typename`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "globalNamespace": {
          "description": "Puts all generated code under `global` namespace. Useful for Stencil integration.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "operationResultSuffix": {
          "description": "Adds a suffix to generated operation result type names\nDefault value: \"\"",
          "type": "string"
        },
        "dedupeOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to make sure to remove duplicate operation name suffix.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "omitOperationSuffix": {
          "description": "Set this configuration to `true` if you wish to disable auto add suffix of operation name, like `Query`, `Mutation`, `Subscription`, `Fragment`.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "exportFragmentSpreadSubTypes": {
          "description": "If set to true, it will export the sub-types created in order to make it easier to access fields declared under fragment spread.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "experimentalFragmentVariables": {
          "description": "If set to true, it will enable support for parsing variables on fragments.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "mergeFragmentTypes": {
          "description": "If set to true, merge equal fragment interfaces.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "addUnderscoreToArgsType": {
          "description": "Adds `_` to generated `Args` types in order to avoid duplicate identifiers.",
          "type": "boolean"
        },
        "enumValues": {
          "$ref": "#/definitions/EnumValuesMap_2",
          "description": "Overrides the default value of enum values declared in your GraphQL schema.\nYou can also map the entire enum to an external type by providing a string that of `module#type`."
        },
        "declarationKind": {
          "description": "Overrides the default output for various GraphQL elements.",
          "anyOf": [
            { "$ref": "#/definitions/DeclarationKindConfig_2" },
            { "enum": ["abstract class", "class", "interface", "type"], "type": "string" }
          ]
        },
        "enumPrefix": {
          "description": "Allow you to disable prefixing for generated enums, works in combination with `typesPrefix`.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "fieldWrapperValue": {
          "description": "Allow you to add wrapper for field type, use T as the generic value. Make sure to set `wrapFieldDefinitions` to `true` in order to make this flag work.\nDefault value: \"T\"",
          "type": "string"
        },
        "wrapFieldDefinitions": {
          "description": "Set to `true` in order to wrap field definitions with `FieldWrapper`.\nThis is useful to allow return types such as Promises and functions.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "onlyEnums": {
          "description": "This will cause the generator to emit types for enums only\nDefault value: \"false\"",
          "type": "boolean"
        },
        "onlyOperationTypes": {
          "description": "This will cause the generator to emit types for operations only (basically only enums and scalars)\nDefault value: \"false\"",
          "type": "boolean"
        },
        "ignoreEnumValuesFromSchema": {
          "description": "This will cause the generator to ignore enum values defined in GraphQLSchema\nDefault value: \"false\"",
          "type": "boolean"
        },
        "wrapEntireFieldDefinitions": {
          "type": "boolean",
          "description": "Set to `true` in order to wrap field definitions with `EntireFieldWrapper`.\nThis is useful to allow return types such as Promises and functions for fields.\nDiffers from `wrapFieldDefinitions` in that this wraps the entire field definition if i.e. the field is an Array, while\n`wrapFieldDefinitions` will wrap every single value inside the array.\nDefault value: \"true\""
        },
        "entireFieldWrapperValue": {
          "type": "string",
          "description": "Allow to override the type value of `EntireFieldWrapper`. This wrapper applies outside of Array and Maybe\nunlike `fieldWrapperValue`, that will wrap the inner type.\nDefault value: \"T | Promise<T> | (() => T | Promise<T>)\""
        },
        "directiveArgumentAndInputFieldMappings": {
          "$ref": "#/definitions/DirectiveArgumentAndInputFieldMappings_2",
          "description": "Replaces a GraphQL scalar with a custom type based on the applied directive on an argument or input field.\n\nYou can use both `module#type` and `module#namespace#type` syntax.\nWill NOT work with introspected schemas since directives are not exported.\nOnly works with directives on ARGUMENT_DEFINITION or INPUT_FIELD_DEFINITION.\n\n**WARNING:** Using this option does only change the type definitions.\n\nFor actually ensuring that a type is correct at runtime you will have to use schema transforms (e.g. with [@graphql-tools/utils mapSchema](https://graphql-tools.com/docs/schema-directives)) that apply those rules!\nOtherwise, you might end up with a runtime type mismatch which could cause unnoticed bugs or runtime errors.\n\nPlease use this configuration option with care!"
        },
        "directiveArgumentAndInputFieldMappingTypeSuffix": {
          "description": "Adds a suffix to the imported names to prevent name clashes.",
          "type": "string"
        },
        "strictScalars": {
          "description": "Makes scalars strict.\n\nIf scalars are found in the schema that are not defined in `scalars`\nan error will be thrown during codegen.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "defaultScalarType": {
          "description": "Allows you to override the type that unknown scalars will have.\nDefault value: \"any\"",
          "type": "string"
        },
        "scalars": {
          "$ref": "#/definitions/ScalarsMap",
          "description": "Extends or overrides the built-in scalars and custom GraphQL scalars to a custom type."
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConvention",
          "description": "Allow you to override the naming convention of the output.\nYou can either override all namings, or specify an object with specific custom naming convention per output.\nThe format of the converter must be a valid `module#method`.\nAllowed values for specific output are: `typeNames`, `enumValues`.\nYou can also use \"keep\" to keep all GraphQL names as-is.\nAdditionally, you can set `transformUnderscore` to `true` if you want to override the default behavior,\nwhich is to preserve underscores.\n\nAvailable case functions in `change-case-all` are `camelCase`, `capitalCase`, `constantCase`, `dotCase`, `headerCase`, `noCase`, `paramCase`, `pascalCase`, `pathCase`, `sentenceCase`, `snakeCase`, `lowerCase`, `localeLowerCase`, `lowerCaseFirst`, `spongeCase`, `titleCase`, `upperCase`, `localeUpperCase` and `upperCaseFirst`\n[See more](https://github.com/btxtiger/change-case-all)\nDefault value: \"change-case-all#pascalCase\""
        },
        "typesPrefix": { "description": "Prefixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "typesSuffix": { "description": "Suffixes all the generated types.\nDefault value: \"\"", "type": "string" },
        "skipTypename": {
          "description": "Does not add `__typename` to the generated types, unless it was specified in the selection set.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "nonOptionalTypename": {
          "description": "Automatically adds `__typename` field to the generated types, even when they are not specified\nin the selection set, and makes it non-optional\nDefault value: \"false\"",
          "type": "boolean"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "dedupeFragments": {
          "description": "Removes fragment duplicates for reducing data transfer.\nIt is done by removing sub-fragments imports from fragment definition\nInstead - all of them are imported to the Operation node.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "inlineFragmentTypes": {
          "description": "Whether fragment types should be inlined into other operations.\n\"inline\" is the default behavior and will perform deep inlining fragment types within operation type definitions.\n\"combine\" is the previous behavior that uses fragment type references without inlining the types (and might cause issues with deeply nested fragment that uses list types).\nDefault value: \"inline\"",
          "type": "string"
        },
        "emitLegacyCommonJSImports": {
          "description": "Emit legacy common js imports.\nDefault it will be `true` this way it ensure that generated code works with [non-compliant bundlers](https://github.com/dotansimha/graphql-code-generator/issues/8065).\nDefault value: \"true\"",
          "type": "boolean"
        }
      }
    },
    "IntrospectionPluginConfig": {
      "description": "This plugin generates a GraphQL introspection file based on your GraphQL schema.",
      "type": "object",
      "properties": {
        "minify": {
          "description": "Set to `true` in order to minify the JSON output.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "descriptions": {
          "description": "Whether to include descriptions in the introspection result.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "specifiedByUrl": {
          "description": "Whether to include `specifiedByUrl` in the introspection result.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "directiveIsRepeatable": {
          "description": "Whether to include `isRepeatable` flag on directives.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "schemaDescription": {
          "description": "Whether to include `description` field on schema.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "federation": { "type": "boolean" }
      }
    },
    "FragmentMatcherConfig": {
      "description": "This plugin generates an introspection file but only with Interfaces and Unions, based on your GraphQLSchema.\n\nIf you are using `apollo-client` and your schema contains `interface` or `union` declaration, it's recommended to use Apollo's Fragment Matcher and the result generated by the plugin.\n\nYou can read more about it in [`apollo-client` documentation](https://apollographql.com/docs/react/data/fragments/#fragments-on-unions-and-interfaces).\n\nFragment Matcher plugin accepts a TypeScript / JavaScript or a JSON file as an output _(`.ts, .tsx, .js, .jsx, .json`)_.\n\nBoth in TypeScript and JavaScript a default export is being used.\n\n> The output is based on the output you choose for the output file name.",
      "type": "object",
      "properties": {
        "module": {
          "description": "Compatible only with JSON extension, allow you to choose the export type, either `module.exports` or `export default`. Allowed values are: `commonjs`, `es2015`.\nDefault value: \"es2015\"",
          "enum": ["commonjs", "es2015"],
          "type": "string"
        },
        "apolloClientVersion": {
          "description": "Compatible only with TS/TSX/JS/JSX extensions, allow you to generate output based on your Apollo-Client version. Valid values are: `2`, `3`.\nDefault value: \"3\"",
          "enum": [2, 3],
          "type": "number"
        },
        "useExplicitTyping": {
          "description": "Create an explicit type based on your schema. This can help IDEs autofill your fragment matcher. This is mostly useful if you do more with your fragment matcher than just pass it to an Apollo-Client.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "federation": { "type": "boolean" },
        "deterministic": {
          "description": "When enabled sorts the fragment types lexicographically. This is useful for deterministic output.\nDefault value: \"false\"",
          "type": "boolean"
        }
      }
    },
    "UrqlIntrospectionConfig": {
      "description": "This plugin generates an introspection file for Schema Awareness feature of Urql Cache Exchange\n\nYou can read more about it in `urql` documentation: https://formidable.com/open-source/urql/docs/graphcache/schema-awareness.\n\nUrql Introspection plugin accepts a TypeScript / JavaScript or a JSON file as an output _(`.ts, .tsx, .js, .jsx, .json`)_.\n\nBoth in TypeScript and JavaScript a default export is being used.\n\n> The output is based on the output you choose for the output file name.",
      "type": "object",
      "properties": {
        "module": {
          "description": "Compatible only with JSON extension, allow you to choose the export type, either `module.exports` or `export default`. Allowed values are: `commonjs`, `es2015`.\nDefault value: \"es2015\"",
          "enum": ["commonjs", "es2015"],
          "type": "string"
        },
        "useTypeImports": {
          "type": "boolean",
          "description": "Will use `import type {}` rather than `import {}` when importing only types. This gives\ncompatibility with TypeScript's \"importsNotUsedAsValues\": \"error\" option\nDefault value: \"false\""
        },
        "includeScalars": {
          "type": "boolean",
          "description": "Includes scalar names (instead of an `Any` replacement) in the output when enabled.\nDefault value: \"false\""
        },
        "includeEnums": {
          "type": "boolean",
          "description": "Includes enums (instead of an `Any` replacement) in the output when enabled.\nDefault value: \"false\""
        },
        "includeInputs": {
          "type": "boolean",
          "description": "Includes all input objects (instead of an `Any` replacement) in the output when enabled.\nDefault value: \"false\""
        },
        "includeDirectives": {
          "type": "boolean",
          "description": "Includes all directives in the output when enabled.\nDefault value: \"false\""
        }
      }
    },
    "HasuraAllowListPluginConfig": {
      "type": "object",
      "properties": {
        "collectionName": {
          "description": "Choose the collection name to be generated. Defaults to allowed-queries\nDefault value: \"allowed-queries\"",
          "type": "string"
        },
        "configVersion": {
          "description": "Target metadata config version. Supported versions are 2 and 3.\nThis is mostly for future proofing, currently has no impact as both versions use the same format.\nThe default value _will change_ in the future if/when newer config versions are released.\nDefault value: \"3\"",
          "enum": [2, 3],
          "type": "number"
        },
        "globalFragments": {
          "description": "Whether to source fragments per-document, or globally. If set, will enforce fragment name uniqueness\nDefault value: \"false\"",
          "type": "boolean"
        }
      }
    },
    "ModulesConfig": {
      "type": "object",
      "properties": {
        "baseTypesPath": {
          "type": "string",
          "description": "Required, should point to the base schema types file.\nThe key of the output is used a base path for this file."
        },
        "importBaseTypesFrom": {
          "type": "string",
          "description": "Overrides the package import for the base types. Use this if you are within a monorepo, and you wish\nto import the base types directly from a different package, and not from a relative path."
        },
        "cwd": {
          "type": "string",
          "description": "Optional, override the `cwd` of the execution. We are using `cwd` to figure out the imports between files. Use this if your execution path is not your project root directory.\nDefault value: \"process.cwd()\""
        },
        "importTypesNamespace": {
          "type": "string",
          "description": "Optional, override the name of the import namespace used to import from the `baseTypesPath` file.\nDefault value: \"Types\""
        },
        "filename": { "type": "string", "description": "Required, sets the file name for the generated files." },
        "encapsulateModuleTypes": {
          "type": "string",
          "description": "Configure how to encapsulate the module types, to avoid confusion.\n\n`namespace` (default): will wrap all types in a TypeScript namespace, using the module name.\n`prefix`: will prefix all types from a specific module with the module name.\n`none`: will skip encapsulation, and generate type as-is.\nDefault value: \"namespace\""
        },
        "requireRootResolvers": {
          "type": "boolean",
          "description": "Generate resolvers of root types (Query, Mutation and Subscription) as non-optional.\nDefault value: \"false\""
        },
        "useGraphQLModules": {
          "type": "boolean",
          "description": "By default, the generated types will generate some code specific to `graphql-modules` library.\n\nIf you are not using GraphQL-Modules, you can disable this feature by setting this to `false`.\nDefault value: \"true\""
        }
      }
    },
    "NearOperationFileConfig": {
      "type": "object",
      "properties": {
        "baseTypesPath": {
          "description": "Required, should point to the base schema types file.\nThe key of the output is used a the base path for this file.\n\nIf you wish to use an NPM package or a local workspace package, make sure to prefix the package name with `~`.",
          "type": "string"
        },
        "importAllFragmentsFrom": {
          "description": "Overrides all external fragments import types by using a specific file path or a package name.\n\nIf you wish to use an NPM package or a local workspace package, make sure to prefix the package name with `~`.",
          "anyOf": [{ "$ref": "#/definitions/FragmentImportFromFn" }, { "type": "string" }]
        },
        "fileName": {
          "description": "Optional, sets a specific file name for the generated files. Use this to override the generated file name when generating files for example based on multiple .graphql files in separate directories.",
          "type": "string"
        },
        "extension": {
          "description": "Optional, sets the extension for the generated files. Use this to override the extension if you are using plugins that requires a different type of extensions (such as `typescript-react-apollo`)\nDefault value: \".generated.ts\"",
          "type": "string"
        },
        "cwd": {
          "description": "Optional, override the `cwd` of the execution. We are using `cwd` to figure out the imports between files. Use this if your execution path is not your project root directory.\nDefault value: \"process.cwd()\"",
          "type": "string"
        },
        "folder": {
          "description": "Optional, defines a folder, (Relative to the source files) where the generated files will be created.\nDefault value: \"''\"",
          "type": "string"
        },
        "importTypesNamespace": {
          "description": "Optional, override the name of the import namespace used to import from the `baseTypesPath` file.\nDefault value: \"Types\"",
          "type": "string"
        }
      }
    },
    "ImportTypesConfig": {
      "type": "object",
      "properties": {
        "typesPath": {
          "description": "Required, should point to the base schema types file.\nThe key of the output is used a the base path for this file.",
          "type": "string"
        },
        "importTypesNamespace": {
          "description": "Optional, override the name of the import namespace used to import from the `baseTypesPath` file.\nDefault value: \"Types\"",
          "type": "string"
        }
      }
    },
    "Types.InstanceOrArray": {
      "anyOf": [
        { "$ref": "#/definitions/Types.SchemaWithLoader" },
        { "$ref": "#/definitions/Types.SchemaFromCodeFile" },
        { "$ref": "#/definitions/Types.UrlSchemaWithOptions" },
        { "$ref": "#/definitions/Types.LocalSchemaPathWithOptions" },
        { "$ref": "#/definitions/Types.ApolloEngineSchemaOptions" },
        { "$ref": "#/definitions/Types.GitHubSchemaOptions" },
        { "type": "array", "items": { "$ref": "#/definitions/Types.Schema" } },
        { "type": "string" }
      ]
    },
    "Types.SchemaWithLoader": {
      "type": "object",
      "additionalProperties": { "$ref": "#/definitions/Types.SchemaWithLoaderOptions" }
    },
    "Types.SchemaWithLoaderOptions": {
      "additionalProperties": false,
      "description": "Loads schema using a pointer, with a custom loader (code file).",
      "type": "object",
      "properties": {
        "loader": {
          "description": "Specify a path to a custom code file (local or module) that will handle the schema loading.",
          "type": "string"
        }
      }
    },
    "Types.SchemaFromCodeFile": {
      "type": "object",
      "additionalProperties": { "$ref": "#/definitions/Types.SchemaFromCodeFileOptions" }
    },
    "Types.SchemaFromCodeFileOptions": {
      "additionalProperties": false,
      "description": "Loads schema using a pointer, without using `require` while looking for schemas in code files.",
      "type": "object",
      "properties": {
        "noRequire": {
          "description": "Set this to `true` in order to tell codegen not to try to `require` files in order to find schema/docs",
          "type": "boolean"
        },
        "noPluck": {
          "description": "Set this to `true` in order to tell codegen not to try to extract GraphQL AST strings schema/docs",
          "type": "boolean"
        },
        "assumeValid": {
          "description": "Set this to `true` in order to tell codegen to skip documents validation.",
          "type": "boolean"
        }
      }
    },
    "Types.UrlSchemaWithOptions": {
      "type": "object",
      "additionalProperties": { "$ref": "#/definitions/Types.UrlSchemaOptions" }
    },
    "Types.UrlSchemaOptions": {
      "additionalProperties": false,
      "description": "Loads a schema from remote endpoint, with custom http options.",
      "type": "object",
      "properties": {
        "headers": {
          "description": "HTTP headers you wish to add to the HTTP request sent by codegen to fetch your GraphQL remote schema.",
          "type": "object",
          "additionalProperties": { "type": "string" }
        },
        "customFetch": {
          "description": "Specify a Node module name, a custom file, or a function, to be used instead of a standard `fetch`.",
          "anyOf": [
            {
              "$ref": "#/definitions/Types.CustomSchemaFetcher",
              "description": "A function to use for fetching the schema."
            },
            { "type": "string" }
          ]
        },
        "method": { "description": "HTTP Method to use, either POST (default) or GET.", "type": "string" },
        "handleAsSDL": {
          "description": "Handling the response as SDL will allow you to load schema from remote server that doesn't return a JSON introspection.",
          "type": "boolean"
        }
      }
    },
    "__type": { "description": "A function to use for fetching the schema.", "type": "object" },
    "Types.CustomSchemaFetcher": { "$ref": "#/definitions/__type" },
    "Types.LocalSchemaPathWithOptions": {
      "type": "object",
      "additionalProperties": { "$ref": "#/definitions/Types.LocalSchemaPathOptions" }
    },
    "Types.LocalSchemaPathOptions": {
      "additionalProperties": false,
      "description": "Loads a schema a local file or files, with customized options for parsing/loading.",
      "type": "object",
      "properties": {
        "skipGraphQLImport": {
          "description": "Skips checks for graphql-import syntax and loads the file as-is, without imports support.\nDefault value: \"true\"",
          "type": "boolean"
        },
        "commentDescriptions": {
          "description": "Converts all GraphQL comments (`#` sign) to descriptions during the parse phase, to make it available\nfor plugins later.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "assumeValidSDL": {
          "description": "Set to true to assume the SDL is valid.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "noLocation": {
          "description": "By default, the parser creates AST nodes that know the location\nin the source that they correspond to. This configuration flag\ndisables that behavior for performance or testing.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "allowLegacySDLEmptyFields": {
          "description": "If enabled, the parser will parse empty fields sets in the Schema\nDefinition Language. Otherwise, the parser will follow the current\nspecification.\n\nThis option is provided to ease adoption of the final SDL specification\nand will be removed in v16.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "allowLegacySDLImplementsInterfaces": {
          "description": "If enabled, the parser will parse implemented interfaces with no `&`\ncharacter between each interface. Otherwise, the parser will follow the\ncurrent specification.\n\nThis option is provided to ease adoption of the final SDL specification\nand will be removed in v16.\nDefault value: \"false\"",
          "type": "boolean"
        },
        "experimentalFragmentVariables": {
          "description": "EXPERIMENTAL:\n\nIf enabled, the parser will understand and parse variable definitions\ncontained in a fragment definition. They'll be represented in the\n`variableDefinitions` field of the FragmentDefinitionNode.\n\nThe syntax is identical to normal, query-defined variables. For example:\n\n  fragment A($var: Boolean = false) on T  {\n    ...\n  }\n\nNote: this feature is experimental and may change or be removed in the\nfuture.\nDefault value: \"false\"",
          "type": "boolean"
        }
      }
    },
    "Types.ApolloEngineSchemaOptions": {
      "type": "object",
      "properties": { "apollo-engine": { "$ref": "#/definitions/ApolloEngineOptions" } }
    },
    "ApolloEngineOptions": {
      "description": "Additional options for loading from Apollo Engine",
      "type": "object",
      "properties": {
        "engine": {
          "type": "object",
          "properties": { "endpoint": { "type": "string" }, "apiKey": { "type": "string" } }
        },
        "graph": { "type": "string" },
        "variant": { "type": "string" },
        "headers": { "$ref": "#/definitions/Record" },
        "noLocation": { "type": "boolean" },
        "allowLegacySDLEmptyFields": { "type": "boolean" },
        "allowLegacySDLImplementsInterfaces": { "type": "boolean" },
        "experimentalFragmentVariables": { "type": "boolean" },
        "commentDescriptions": {
          "description": "Set to `true` in order to convert all GraphQL comments (marked with # sign) to descriptions (\"\"\")\nGraphQL has built-in support for transforming descriptions to comments (with `print`), but not while\nparsing. Turning the flag on will support the other way as well (`parse`)",
          "type": "boolean"
        },
        "assumeValidSDL": {
          "description": "Set to true to assume the SDL is valid.\n\nDefault: false",
          "type": "boolean"
        },
        "assumeValid": {
          "description": "When building a schema from a GraphQL service's introspection result, it\nmight be safe to assume the schema is valid. Set to true to assume the\nproduced schema is valid.\n\nDefault: false",
          "type": "boolean"
        },
        "cwd": { "type": "string" },
        "ignore": { "anyOf": [{ "type": "array", "items": { "type": "string" } }, { "type": "string" }] },
        "includeSources": { "type": "boolean" }
      }
    },
    "__type_1": { "type": "object" },
    "Record": { "$ref": "#/definitions/__type_1" },
    "Types.GitHubSchemaOptions": {
      "type": "object",
      "additionalProperties": { "type": "object", "properties": { "token": { "type": "string" } } }
    },
    "Types.Schema": {
      "description": "A URL to your GraphQL endpoint, a local path to `.graphql` file, a glob pattern to your GraphQL schema files, or a JavaScript file that exports the schema to generate code from. This can also be an array which specifies multiple schemas to generate code from. You can read more about the supported formats [here](schema-field#available-formats).",
      "anyOf": [
        { "$ref": "#/definitions/Types.SchemaWithLoader" },
        { "$ref": "#/definitions/Types.SchemaFromCodeFile" },
        { "$ref": "#/definitions/Types.UrlSchemaWithOptions" },
        { "$ref": "#/definitions/Types.LocalSchemaPathWithOptions" },
        { "$ref": "#/definitions/Types.ApolloEngineSchemaOptions" },
        { "$ref": "#/definitions/Types.GitHubSchemaOptions" },
        { "type": "string" }
      ]
    },
    "Types.RequireExtension": { "anyOf": [{ "type": "array", "items": { "type": "string" } }, { "type": "string" }] },
    "Types.InstanceOrArray_1": {
      "anyOf": [
        { "$ref": "#/definitions/Types.CustomDocumentLoader" },
        { "type": "array", "items": { "$ref": "#/definitions/Types.OperationDocument" } },
        { "type": "string" }
      ]
    },
    "Types.CustomDocumentLoader": {
      "type": "object",
      "additionalProperties": { "$ref": "#/definitions/Types.CustomDocumentLoaderOptions" }
    },
    "Types.CustomDocumentLoaderOptions": {
      "additionalProperties": false,
      "description": "Specify a path to a custom loader for your GraphQL documents.",
      "type": "object",
      "properties": {
        "loader": {
          "description": "Specify a path to a custom code file (local or module) that will handle the documents loading.",
          "type": "string"
        }
      }
    },
    "Types.OperationDocument": {
      "anyOf": [{ "$ref": "#/definitions/Types.CustomDocumentLoader" }, { "type": "string" }]
    },
    "Types.ConfiguredPlugin": {
      "type": "object",
      "additionalProperties": { "type": "object", "additionalProperties": { "$ref": "#/definitions/T" } },
      "properties": {
        "flutter-freezed": { "$ref": "#/definitions/FlutterFreezedPluginConfig" },
        "typescript-react-query": { "$ref": "#/definitions/ReactQueryRawPluginConfig" },
        "typescript-rtk-query": { "$ref": "#/definitions/RTKConfig" },
        "typescript-generic-sdk": { "$ref": "#/definitions/RawGenericSdkPluginConfig" },
        "typescript-apollo-client-helpers": { "$ref": "#/definitions/ApolloClientHelpersConfig" },
        "add": { "$ref": "#/definitions/AddPluginConfig" },
        "time": { "$ref": "#/definitions/TimePluginConfig" },
        "typescript": { "$ref": "#/definitions/TypeScriptPluginConfig" },
        "typescript-operations": { "$ref": "#/definitions/TypeScriptDocumentsPluginConfig" },
        "c-sharp": { "$ref": "#/definitions/CSharpResolversPluginRawConfig" },
        "c-sharp-operations": { "$ref": "#/definitions/CSharpOperationsRawPluginConfig" },
        "schema-ast": { "$ref": "#/definitions/SchemaASTConfig" },
        "typescript-type-graphql": { "$ref": "#/definitions/TypeGraphQLPluginConfig" },
        "typescript-graphql-files-modules": { "$ref": "#/definitions/TypeScriptFilesModulesPluginConfig" },
        "named-operations-object": { "$ref": "#/definitions/NamedOperationsObjectPluginConfig" },
        "typescript-graphql-request": { "$ref": "#/definitions/RawGraphQLRequestPluginConfig" },
        "typescript-mongodb": { "$ref": "#/definitions/TypeScriptMongoPluginConfig" },
        "typescript-resolvers": { "$ref": "#/definitions/TypeScriptResolversPluginConfig" },
        "typescript-apollo-angular": { "$ref": "#/definitions/ApolloAngularRawPluginConfig" },
        "typescript-nhost": { "$ref": "#/definitions/NhostPluginConfig" },
        "typescript-urql": { "$ref": "#/definitions/UrqlRawPluginConfig" },
        "typescript-react-apollo": { "$ref": "#/definitions/ReactApolloRawPluginConfig" },
        "typescript-vue-apollo": { "$ref": "#/definitions/VueApolloRawPluginConfig" },
        "typescript-vue-apollo-smart-ops": { "$ref": "#/definitions/VueApolloSmartOpsRawPluginConfig" },
        "typescript-vue-urql": { "$ref": "#/definitions/VueUrqlRawPluginConfig" },
        "typescript-stencil-apollo": { "$ref": "#/definitions/StencilApolloRawPluginConfig" },
        "typescript-document-nodes": { "$ref": "#/definitions/TypeScriptDocumentNodesRawPluginConfig" },
        "typescript-msw": { "$ref": "#/definitions/MSWConfig" },
        "java-apollo-android": { "$ref": "#/definitions/JavaApolloAndroidPluginConfig" },
        "java-resolvers": { "$ref": "#/definitions/JavaResolversPluginRawConfig" },
        "java": { "$ref": "#/definitions/JavaResolversPluginRawConfig" },
        "kotlin": { "$ref": "#/definitions/KotlinResolversPluginRawConfig" },
        "flow": { "$ref": "#/definitions/FlowPluginConfig" },
        "flow-resolvers": { "$ref": "#/definitions/FlowResolversPluginConfig" },
        "flow-operations": { "$ref": "#/definitions/FlowDocumentsPluginConfig" },
        "introspection": { "$ref": "#/definitions/IntrospectionPluginConfig" },
        "fragment-matcher": { "$ref": "#/definitions/FragmentMatcherConfig" },
        "urql-introspection": { "$ref": "#/definitions/UrqlIntrospectionConfig" },
        "hasura-allow-list": { "$ref": "#/definitions/HasuraAllowListPluginConfig" }
      }
    },
    "T": { "type": "object" },
    "Types.ConfiguredOutput": {
      "additionalProperties": false,
      "type": "object",
      "properties": {
        "plugins": {
          "type": "array",
          "items": { "$ref": "#/definitions/GeneratedPluginsMap" },
          "description": "List of plugins to apply to this current output file.\n\nYou can either specify plugins from the community using the NPM package name (after you installed it in your project), or you can use a path to a local file for custom plugins.\n\nYou can find a list of available plugins here: https://the-guild.dev/graphql/codegen/docs/plugins/index\nNeed a custom plugin? read this: https://the-guild.dev/graphql/codegen/docs/custom-codegen/index"
        },
        "preset": {
          "description": "If your setup uses Preset to have a more dynamic setup and output, set the name of your preset here.\n\nPresets are a way to have more than one file output, for example: https://the-guild.dev/graphql/codegen/docs/presets/near-operation-file\n\nYou can either specify a preset from the community using the NPM package name (after you installed it in your project), or you can use a path to a local file for a custom preset.\n\nList of available presets: https://graphql-code-generator.com/docs/presets/presets-index",
          "anyOf": [
            { "$ref": "#/definitions/Types.OutputPreset" },
            {
              "enum": [
                "client",
                "client-preset",
                "gql-tag-operations",
                "gql-tag-operations-preset",
                "graphql-modules",
                "graphql-modules-preset",
                "import-types",
                "import-types-preset",
                "near-operation-file",
                "near-operation-file-preset"
              ],
              "type": "string"
            }
          ]
        },
        "presetConfig": {
          "description": "If your setup uses Preset to have a more dynamic setup and output, set the configuration object of your preset here.\n\nList of available presets: https://graphql-code-generator.com/docs/presets/presets-index",
          "type": "object",
          "additionalProperties": {}
        },
        "overwrite": {
          "description": "A flag to overwrite files if they already exist when generating code (`true` by default).\n\nFor more details: https://graphql-code-generator.com/docs/config-reference/codegen-config",
          "type": "boolean"
        },
        "documents": {
          "$ref": "#/definitions/Types.InstanceOrArray_1",
          "description": "A pointer(s) to your GraphQL documents: query, mutation, subscription and fragment. These documents will be loaded into for all your output files.\nYou can use one of the following:\n\n- Path to a local `.graphql` file\n- Path to a code file (for example: `.js` or `.tsx`) containing GraphQL operation strings.\n- Glob expression pointing to multiple `.graphql` files\n- Glob expression pointing to multiple code files\n- Inline string containing GraphQL SDL operation definition\n\nYou can specify either a single file, or multiple.\n\nFor more details: https://graphql-code-generator.com/docs/config-reference/documents-field"
        },
        "schema": {
          "$ref": "#/definitions/Types.InstanceOrArray",
          "description": "A pointer(s) to your GraphQL schema. This schema will be available only for this specific `generates` record.\nYou can use one of the following:\n\n- URL pointing to a GraphQL endpoint\n- Path to a local `.json` file\n- Path to a local `.graphql` file\n- Glob expression pointing to multiple `.graphql` files\n- Path to a local code file (for example: `.js`) that exports `GraphQLSchema` object\n- Inline string containing GraphQL SDL schema definition\n\nYou can specify either a single schema, or multiple, and GraphQL Code Generator will merge the schemas into a single schema.\n\nFor more details: https://graphql-code-generator.com/docs/config-reference/schema-field"
        },
        "config": { "additionalProperties": true },
        "hooks": {
          "$ref": "#/definitions/Partial",
          "description": "Specifies scripts to run when events are happening in the codegen core.\nHooks defined on that level will effect only the current output files.\n\nFor more details: https://graphql-code-generator.com/docs/config-reference/lifecycle-hooks"
        },
        "documentTransforms": {
          "description": "DocumentTransform changes documents before executing plugins.",
          "type": "array",
          "items": { "$ref": "#/definitions/Types.OutputDocumentTransform<object>" }
        },
        "watchPattern": {
          "description": ": Additional file pattern to watch when using watch mode",
          "anyOf": [{ "type": "array", "items": { "type": "string" } }, { "type": "string" }]
        }
      },
      "allOf": [
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "flutter-freezed" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/FlutterFreezedPluginConfig" } } }
        },
        {
          "if": {
            "properties": { "plugins": { "contains": { "type": "string", "const": "typescript-react-query" } } }
          },
          "then": { "properties": { "config": { "$ref": "#/definitions/ReactQueryRawPluginConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "typescript-rtk-query" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/RTKConfig" } } }
        },
        {
          "if": {
            "properties": { "plugins": { "contains": { "type": "string", "const": "typescript-generic-sdk" } } }
          },
          "then": { "properties": { "config": { "$ref": "#/definitions/RawGenericSdkPluginConfig" } } }
        },
        {
          "if": {
            "properties": {
              "plugins": { "contains": { "type": "string", "const": "typescript-apollo-client-helpers" } }
            }
          },
          "then": { "properties": { "config": { "$ref": "#/definitions/ApolloClientHelpersConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "add" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/AddPluginConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "time" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/TimePluginConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "typescript" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/TypeScriptPluginConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "typescript-operations" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/TypeScriptDocumentsPluginConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "c-sharp" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/CSharpResolversPluginRawConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "c-sharp-operations" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/CSharpOperationsRawPluginConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "schema-ast" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/SchemaASTConfig" } } }
        },
        {
          "if": {
            "properties": { "plugins": { "contains": { "type": "string", "const": "typescript-type-graphql" } } }
          },
          "then": { "properties": { "config": { "$ref": "#/definitions/TypeGraphQLPluginConfig" } } }
        },
        {
          "if": {
            "properties": {
              "plugins": { "contains": { "type": "string", "const": "typescript-graphql-files-modules" } }
            }
          },
          "then": { "properties": { "config": { "$ref": "#/definitions/TypeScriptFilesModulesPluginConfig" } } }
        },
        {
          "if": {
            "properties": { "plugins": { "contains": { "type": "string", "const": "named-operations-object" } } }
          },
          "then": { "properties": { "config": { "$ref": "#/definitions/NamedOperationsObjectPluginConfig" } } }
        },
        {
          "if": {
            "properties": { "plugins": { "contains": { "type": "string", "const": "typescript-graphql-request" } } }
          },
          "then": { "properties": { "config": { "$ref": "#/definitions/RawGraphQLRequestPluginConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "typescript-mongodb" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/TypeScriptMongoPluginConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "typescript-resolvers" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/TypeScriptResolversPluginConfig" } } }
        },
        {
          "if": {
            "properties": { "plugins": { "contains": { "type": "string", "const": "typescript-apollo-angular" } } }
          },
          "then": { "properties": { "config": { "$ref": "#/definitions/ApolloAngularRawPluginConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "typescript-nhost" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/NhostPluginConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "typescript-urql" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/UrqlRawPluginConfig" } } }
        },
        {
          "if": {
            "properties": { "plugins": { "contains": { "type": "string", "const": "typescript-react-apollo" } } }
          },
          "then": { "properties": { "config": { "$ref": "#/definitions/ReactApolloRawPluginConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "typescript-vue-apollo" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/VueApolloRawPluginConfig" } } }
        },
        {
          "if": {
            "properties": {
              "plugins": { "contains": { "type": "string", "const": "typescript-vue-apollo-smart-ops" } }
            }
          },
          "then": { "properties": { "config": { "$ref": "#/definitions/VueApolloSmartOpsRawPluginConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "typescript-vue-urql" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/VueUrqlRawPluginConfig" } } }
        },
        {
          "if": {
            "properties": { "plugins": { "contains": { "type": "string", "const": "typescript-stencil-apollo" } } }
          },
          "then": { "properties": { "config": { "$ref": "#/definitions/StencilApolloRawPluginConfig" } } }
        },
        {
          "if": {
            "properties": { "plugins": { "contains": { "type": "string", "const": "typescript-document-nodes" } } }
          },
          "then": { "properties": { "config": { "$ref": "#/definitions/TypeScriptDocumentNodesRawPluginConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "typescript-msw" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/MSWConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "java-apollo-android" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/JavaApolloAndroidPluginConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "java-resolvers" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/JavaResolversPluginRawConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "java" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/JavaResolversPluginRawConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "kotlin" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/KotlinResolversPluginRawConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "flow" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/FlowPluginConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "flow-resolvers" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/FlowResolversPluginConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "flow-operations" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/FlowDocumentsPluginConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "introspection" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/IntrospectionPluginConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "fragment-matcher" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/FragmentMatcherConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "urql-introspection" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/UrqlIntrospectionConfig" } } }
        },
        {
          "if": { "properties": { "plugins": { "contains": { "type": "string", "const": "hasura-allow-list" } } } },
          "then": { "properties": { "config": { "$ref": "#/definitions/HasuraAllowListPluginConfig" } } }
        }
      ]
    },
    "__type_2": {
      "type": "object",
      "properties": { "buildGeneratesSection": { "type": "object" }, "prepareDocuments": { "type": "object" } }
    },
    "Types.OutputPreset": { "$ref": "#/definitions/__type_2" },
    "__type_3": { "type": "object", "additionalProperties": { "$ref": "#/definitions/T" } },
    "Types.PluginConfig": { "$ref": "#/definitions/__type_3" },
    "__type_4": {
      "type": "object",
      "properties": {
        "afterStart": {
          "$ref": "#/definitions/Types.LifeCycleHookValue",
          "description": "Triggered with no arguments when the codegen starts (after the `codegen.yml` has beed parsed).\n\nSpecify a shell command to run."
        },
        "beforeDone": {
          "$ref": "#/definitions/Types.LifeCycleHookValue",
          "description": "Triggered with no arguments, right before the codegen closes, or when watch mode is stopped.\n\nSpecify a shell command to run."
        },
        "onWatchTriggered": {
          "$ref": "#/definitions/Types.LifeCycleHookValue",
          "description": "Triggered every time a file changes when using watch mode.\nTriggered with two arguments: the type of the event (for example, `changed`) and the path of the file."
        },
        "onError": {
          "$ref": "#/definitions/Types.LifeCycleHookValue",
          "description": "Triggered in case of a general error in the codegen. The argument is a string containing the error."
        },
        "afterOneFileWrite": {
          "$ref": "#/definitions/Types.LifeCycleHookValue",
          "description": "Triggered after a file is written to the file-system. Executed with the path for the file.\nIf the content of the file hasn't changed since last execution - this hooks won't be triggered.\n\n> This is a very useful hook, you can use it for integration with Prettier or other linters."
        },
        "afterAllFileWrite": {
          "$ref": "#/definitions/Types.LifeCycleHookValue",
          "description": "Executed after writing all the files to the file-system.\nTriggered with multiple arguments - paths for all files."
        },
        "beforeOneFileWrite": {
          "$ref": "#/definitions/Types.LifeCycleAlterHookValue",
          "description": "Triggered before a file is written to the file-system.\nExecuted with the path and content for the file.\n\nReturning a string will override the content of the file.\n\nIf the content of the file hasn't changed since last execution - this hooks won't be triggered."
        },
        "beforeAllFileWrite": {
          "$ref": "#/definitions/Types.LifeCycleHookValue",
          "description": "Executed after the codegen has done creating the output and before writing the files to the file-system.\n\nTriggered with multiple arguments - paths for all relevant files.\n\n> Not all the files will be actually written to the file-system, because this is triggered before checking if the file has changed since last execution."
        }
      }
    },
    "Types.LifeCycleHookValue": {
      "anyOf": [
        { "$ref": "#/definitions/Types.HookFunction" },
        {
          "type": "array",
          "items": { "anyOf": [{ "$ref": "#/definitions/Types.HookFunction" }, { "type": "string" }] }
        },
        { "type": "string" }
      ]
    },
    "__type_5": { "type": "object" },
    "Types.HookFunction": { "$ref": "#/definitions/__type_5" },
    "Types.LifeCycleAlterHookValue": {
      "anyOf": [
        { "$ref": "#/definitions/Types.HookFunction" },
        { "$ref": "#/definitions/Types.HookAlterFunction" },
        {
          "type": "array",
          "items": {
            "anyOf": [
              { "$ref": "#/definitions/Types.HookFunction" },
              { "$ref": "#/definitions/Types.HookAlterFunction" },
              { "type": "string" }
            ]
          }
        },
        { "type": "string" }
      ]
    },
    "__type_6": { "type": "object" },
    "Types.HookAlterFunction": { "$ref": "#/definitions/__type_6" },
    "Partial": { "$ref": "#/definitions/__type_4" },
    "Types.OutputDocumentTransform<object>": {
      "anyOf": [
        { "$ref": "#/definitions/Types.DocumentTransformObject" },
        { "$ref": "#/definitions/Types.DocumentTransformFileConfig" },
        { "type": "string" }
      ]
    },
    "__type_7": {
      "type": "object",
      "properties": { "transform": { "$ref": "#/definitions/Types.DocumentTransformFunction" } }
    },
    "__type_8": { "type": "object" },
    "Types.DocumentTransformFunction": { "$ref": "#/definitions/__type_8" },
    "Types.DocumentTransformObject": { "$ref": "#/definitions/__type_7" },
    "__type_9": { "type": "object", "additionalProperties": { "$ref": "#/definitions/T_1" } },
    "T_1": { "type": "object" },
    "Types.DocumentTransformFileConfig": { "$ref": "#/definitions/__type_9" },
    "__type_10": { "type": "object" },
    "Types.PackageLoaderFn": { "$ref": "#/definitions/__type_10" },
    "Array": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "name": { "description": "the name of the NPM package name you wish to look for", "type": "string" },
          "identifier": { "description": "the tag identifier name you wish to look for", "type": "string" }
        }
      }
    },
    "TypeNamePattern": {
      "description": "A compact string of patterns used in the config for granular configuration of Graphql Types.\n\nThe string can contain one or more patterns, each pattern ends with a semi-colon (`;`).\n\nTo apply an option to all Graphql Types or all fields, use the allTypeNames (`@*TypeNames`) tokens.\n\nWherever you use the allTypeNames token, know very well that you can make some exceptions. After all, to every rule, there is an exception.\n\nA **square bracket** (`[]`) is used to specify what should be included and a **negated square bracket** (`-[]`) is used to specify what should be excluded.\n\nManually typing out a pattern may be prone to typos resulting in invalid patterns therefore the [`TypeNamePattern`]() class exposes some builder methods to be used in the plugin config file.\n\n## Available Builder Methods and the patterns they make\n```ts\nconst Droid = TypeName.fromString('Droid');\nconst Starship = TypeName.fromString('Starship');\nconst Human = TypeName.fromString('Human');\nconst Movie = TypeName.fromString('Movie');\n\n\n// Configuring specific Graphql Types\nconst pattern = TypeNamePattern.forTypeNames([Droid, Starship]);\nconsole.log(pattern); // \"Droid;Starship;\"\n\n// Configuring all Graphql Types\nconst pattern = TypeNamePattern.forAllTypeNames();\nconsole.log(pattern); // \"@*TypeNames;\"\n\n// Configuring all Graphql Types except those specified in the exclusion list of TypeNames\nconst pattern = TypeNamePattern.forAllTypeNamesExcludeTypeNames([Droid, Starship]);\nconsole.log(pattern); // \"@*TypeNames-[Droid,Starship];\"",
      "type": "object",
      "properties": { "_value": {}, "value": { "type": "string" } }
    },
    "UnionValueCase": { "enum": ["FreezedUnionCase.camel", "FreezedUnionCase.pascal"], "type": "string" },
    "TypeName": {
      "description": "represents a single valid GraphQL Type Name used in the GraphQL Schema provided",
      "type": "object",
      "properties": { "_value": {}, "value": { "type": "string" } }
    },
    "__type_11": {
      "type": "object",
      "properties": {
        "endpoint": { "type": "string" },
        "fetchParams": { "anyOf": [{ "$ref": "#/definitions/Record_1" }, { "type": "string" }] }
      }
    },
    "__type_12": { "type": "object" },
    "Record_1": { "$ref": "#/definitions/__type_12" },
    "HardcodedFetch": { "$ref": "#/definitions/__type_11" },
    "NamingConvention": {
      "anyOf": [
        { "$ref": "#/definitions/NamingConventionFn" },
        { "$ref": "#/definitions/NamingConventionMap" },
        { "type": "string" }
      ]
    },
    "__type_13": { "type": "object" },
    "NamingConventionFn": { "$ref": "#/definitions/__type_13" },
    "NamingConventionMap": {
      "additionalProperties": false,
      "type": "object",
      "properties": {
        "enumValues": { "anyOf": [{ "$ref": "#/definitions/NamingConventionFn" }, { "type": "string" }] },
        "typeNames": { "anyOf": [{ "$ref": "#/definitions/NamingConventionFn" }, { "type": "string" }] },
        "transformUnderscore": { "type": "boolean" }
      }
    },
    "ScalarsMap": {
      "description": "Scalars map or a string, a map between the GraphQL scalar name and the identifier that should be used",
      "anyOf": [{ "type": "object", "additionalProperties": { "type": "string" } }, { "type": "string" }]
    },
    "DocumentMode": {
      "enum": ["documentNode", "documentNodeImportFragments", "external", "graphQLTag", "string"],
      "type": "string"
    },
    "AvoidOptionalsConfig": {
      "type": "object",
      "properties": {
        "field": { "type": "boolean" },
        "object": { "type": "boolean" },
        "inputValue": { "type": "boolean" },
        "defaultValue": { "type": "boolean" },
        "resolvers": { "type": "boolean" },
        "query": { "type": "boolean" },
        "mutation": { "type": "boolean" },
        "subscription": { "type": "boolean" }
      }
    },
    "EnumValuesMap": {
      "description": "A raw configuration for enumValues map - can be represented with a single string value for a file path,\na map between enum name and a file path, or a map between enum name and an object with explicit enum values.",
      "anyOf": [
        {
          "type": "object",
          "additionalProperties": {
            "anyOf": [
              {
                "allOf": [
                  { "type": "object", "additionalProperties": { "type": ["string", "number"] } },
                  { "$ref": "#/definitions/AdditionalProps" }
                ]
              },
              { "type": "string" }
            ]
          }
        },
        { "type": "string" }
      ]
    },
    "AdditionalProps": { "type": "object" },
    "DeclarationKindConfig": {
      "type": "object",
      "properties": {
        "directive": { "$ref": "#/definitions/DeclarationKind" },
        "scalar": { "$ref": "#/definitions/DeclarationKind" },
        "input": { "$ref": "#/definitions/DeclarationKind" },
        "type": { "$ref": "#/definitions/DeclarationKind" },
        "interface": { "$ref": "#/definitions/DeclarationKind" },
        "arguments": { "$ref": "#/definitions/DeclarationKind" }
      }
    },
    "DeclarationKind": { "enum": ["abstract class", "class", "interface", "type"], "type": "string" },
    "__type_14": {
      "description": "A map between the GraphQL directive name and the identifier that should be used",
      "type": "object",
      "additionalProperties": { "type": "string" }
    },
    "DirectiveArgumentAndInputFieldMappings": { "$ref": "#/definitions/__type_14" },
    "ScalarsMap_1": {
      "description": "Scalars map or a string, a map between the GraphQL scalar name and the identifier that should be used",
      "anyOf": [
        {
          "type": "object",
          "additionalProperties": {
            "anyOf": [
              { "type": "object", "properties": { "input": { "type": "string" }, "output": { "type": "string" } } },
              { "type": "string" }
            ]
          }
        },
        { "type": "string" }
      ]
    },
    "NamingConvention_1": {
      "anyOf": [
        { "$ref": "#/definitions/NamingConventionFn_1" },
        { "$ref": "#/definitions/NamingConventionMap_1" },
        { "type": "string" }
      ]
    },
    "__type_15": { "type": "object" },
    "NamingConventionFn_1": { "$ref": "#/definitions/__type_15" },
    "NamingConventionMap_1": {
      "additionalProperties": false,
      "type": "object",
      "properties": {
        "enumValues": { "anyOf": [{ "$ref": "#/definitions/NamingConventionFn_1" }, { "type": "string" }] },
        "typeNames": { "anyOf": [{ "$ref": "#/definitions/NamingConventionFn_1" }, { "type": "string" }] },
        "transformUnderscore": { "type": "boolean" }
      }
    },
    "CustomDirectivesConfig": {
      "type": "object",
      "properties": {
        "apolloUnmask": {
          "description": "Adds integration with Apollo Client's `@unmask` directive\nwhen using Apollo Client's data masking feature. `@unmask` ensures fields\nmarked by `@unmask` are available in the type definition.\nDefault value: \"false\"",
          "type": "boolean"
        }
      }
    },
    "EnumValuesMap_1": {
      "description": "A raw configuration for enumValues map - can be represented with a single string value for a file path,\na map between enum name and a file path, or a map between enum name and an object with explicit enum values.",
      "anyOf": [
        {
          "type": "object",
          "additionalProperties": {
            "anyOf": [
              {
                "allOf": [
                  { "type": "object", "additionalProperties": { "type": ["string", "number"] } },
                  { "$ref": "#/definitions/AdditionalProps_1" }
                ]
              },
              { "type": "string" }
            ]
          }
        },
        { "type": "string" }
      ]
    },
    "AdditionalProps_1": { "type": "object" },
    "JsonAttributesSource": { "enum": ["Newtonsoft.Json", "System.Text.Json"], "type": "string" },
    "ScalarsMap_2": {
      "description": "Scalars map or a string, a map between the GraphQL scalar name and the identifier that should be used",
      "anyOf": [{ "type": "object", "additionalProperties": { "type": "string" } }, { "type": "string" }]
    },
    "NamingConvention_2": {
      "anyOf": [
        { "$ref": "#/definitions/NamingConventionFn_2" },
        { "$ref": "#/definitions/NamingConventionMap_2" },
        { "type": "string" }
      ]
    },
    "__type_16": { "type": "object" },
    "NamingConventionFn_2": { "$ref": "#/definitions/__type_16" },
    "NamingConventionMap_2": {
      "additionalProperties": false,
      "type": "object",
      "properties": {
        "enumValues": { "anyOf": [{ "$ref": "#/definitions/NamingConventionFn_2" }, { "type": "string" }] },
        "typeNames": { "anyOf": [{ "$ref": "#/definitions/NamingConventionFn_2" }, { "type": "string" }] },
        "transformUnderscore": { "type": "boolean" }
      }
    },
    "DocumentMode_1": {
      "enum": ["documentNode", "documentNodeImportFragments", "external", "graphQLTag", "string"],
      "type": "string"
    },
    "__type_17": {
      "type": "object",
      "properties": {
        "type": { "type": "string" },
        "interface": { "type": "string" },
        "field": { "type": "string" },
        "input": { "type": "string" },
        "arguments": { "type": "string" }
      }
    },
    "Partial_1": { "$ref": "#/definitions/__type_17" },
    "AvoidOptionalsConfig_1": {
      "type": "object",
      "properties": {
        "field": { "type": "boolean" },
        "object": { "type": "boolean" },
        "inputValue": { "type": "boolean" },
        "defaultValue": { "type": "boolean" },
        "resolvers": { "type": "boolean" }
      }
    },
    "DeclarationKindConfig_1": {
      "type": "object",
      "properties": {
        "directive": { "$ref": "#/definitions/DeclarationKind_1" },
        "scalar": { "$ref": "#/definitions/DeclarationKind_1" },
        "input": { "$ref": "#/definitions/DeclarationKind_1" },
        "type": { "$ref": "#/definitions/DeclarationKind_1" },
        "interface": { "$ref": "#/definitions/DeclarationKind_1" },
        "arguments": { "$ref": "#/definitions/DeclarationKind_1" }
      }
    },
    "DeclarationKind_1": { "enum": ["abstract class", "class", "interface", "type"], "type": "string" },
    "__type_18": {
      "description": "A map between the GraphQL directive name and the identifier that should be used",
      "type": "object",
      "additionalProperties": { "type": "string" }
    },
    "DirectiveArgumentAndInputFieldMappings_1": { "$ref": "#/definitions/__type_18" },
    "Array_1": { "type": "array", "items": { "type": "string" } },
    "ResolversNonOptionalTypenameConfig": {
      "type": "object",
      "properties": {
        "unionMember": { "type": "boolean" },
        "interfaceImplementingType": { "type": "boolean" },
        "excludeTypes": { "type": "array", "items": { "type": "string" } }
      }
    },
    "ScalarsMap_3": {
      "description": "Scalars map or a string, a map between the GraphQL scalar name and the identifier that should be used",
      "anyOf": [{ "type": "object", "additionalProperties": { "type": "string" } }, { "type": "string" }]
    },
    "StencilComponentType": { "enum": ["class", "functional"], "type": "string" },
    "DocumentMode_2": {
      "enum": ["documentNode", "documentNodeImportFragments", "external", "graphQLTag", "string"],
      "type": "string"
    },
    "FileType": { "enum": [0, 1, 2, 3], "type": "number" },
    "EnumValuesMap_2": {
      "description": "A raw configuration for enumValues map - can be represented with a single string value for a file path,\na map between enum name and a file path, or a map between enum name and an object with explicit enum values.",
      "anyOf": [
        {
          "type": "object",
          "additionalProperties": {
            "anyOf": [
              {
                "allOf": [
                  { "type": "object", "additionalProperties": { "type": ["string", "number"] } },
                  { "$ref": "#/definitions/AdditionalProps_2" }
                ]
              },
              { "type": "string" }
            ]
          }
        },
        { "type": "string" }
      ]
    },
    "AdditionalProps_2": { "type": "object" },
    "DeclarationKindConfig_2": {
      "type": "object",
      "properties": {
        "directive": { "$ref": "#/definitions/DeclarationKind_2" },
        "scalar": { "$ref": "#/definitions/DeclarationKind_2" },
        "input": { "$ref": "#/definitions/DeclarationKind_2" },
        "type": { "$ref": "#/definitions/DeclarationKind_2" },
        "interface": { "$ref": "#/definitions/DeclarationKind_2" },
        "arguments": { "$ref": "#/definitions/DeclarationKind_2" }
      }
    },
    "DeclarationKind_2": { "enum": ["abstract class", "class", "interface", "type"], "type": "string" },
    "__type_19": {
      "description": "A map between the GraphQL directive name and the identifier that should be used",
      "type": "object",
      "additionalProperties": { "type": "string" }
    },
    "DirectiveArgumentAndInputFieldMappings_2": { "$ref": "#/definitions/__type_19" },
    "AvoidOptionalsConfig_2": {
      "type": "object",
      "properties": {
        "field": { "type": "boolean" },
        "object": { "type": "boolean" },
        "inputValue": { "type": "boolean" },
        "defaultValue": { "type": "boolean" },
        "resolvers": { "type": "boolean" }
      }
    },
    "__type_20": { "type": "object" },
    "FragmentImportFromFn": { "$ref": "#/definitions/__type_20" },
    "GeneratedPluginsMap": {
      "anyOf": [
        {
          "type": "object",
          "additionalProperties": true,
          "properties": {
            "flutter-freezed": { "additionalProperties": false, "$ref": "#/definitions/FlutterFreezedPluginConfig" },
            "@graphql-codegen/flutter-freezed": {
              "additionalProperties": false,
              "$ref": "#/definitions/FlutterFreezedPluginConfig"
            },
            "typescript-react-query": {
              "additionalProperties": false,
              "$ref": "#/definitions/ReactQueryRawPluginConfig"
            },
            "@graphql-codegen/typescript-react-query": {
              "additionalProperties": false,
              "$ref": "#/definitions/ReactQueryRawPluginConfig"
            },
            "typescript-rtk-query": { "additionalProperties": false, "$ref": "#/definitions/RTKConfig" },
            "@graphql-codegen/typescript-rtk-query": {
              "additionalProperties": false,
              "$ref": "#/definitions/RTKConfig"
            },
            "typescript-generic-sdk": {
              "additionalProperties": false,
              "$ref": "#/definitions/RawGenericSdkPluginConfig"
            },
            "@graphql-codegen/typescript-generic-sdk": {
              "additionalProperties": false,
              "$ref": "#/definitions/RawGenericSdkPluginConfig"
            },
            "typescript-apollo-client-helpers": {
              "additionalProperties": false,
              "$ref": "#/definitions/ApolloClientHelpersConfig"
            },
            "@graphql-codegen/typescript-apollo-client-helpers": {
              "additionalProperties": false,
              "$ref": "#/definitions/ApolloClientHelpersConfig"
            },
            "add": { "additionalProperties": false, "$ref": "#/definitions/AddPluginConfig" },
            "@graphql-codegen/add": { "additionalProperties": false, "$ref": "#/definitions/AddPluginConfig" },
            "time": { "additionalProperties": false, "$ref": "#/definitions/TimePluginConfig" },
            "@graphql-codegen/time": { "additionalProperties": false, "$ref": "#/definitions/TimePluginConfig" },
            "typescript": { "additionalProperties": false, "$ref": "#/definitions/TypeScriptPluginConfig" },
            "@graphql-codegen/typescript": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeScriptPluginConfig"
            },
            "typescript-operations": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeScriptDocumentsPluginConfig"
            },
            "@graphql-codegen/typescript-operations": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeScriptDocumentsPluginConfig"
            },
            "c-sharp": { "additionalProperties": false, "$ref": "#/definitions/CSharpResolversPluginRawConfig" },
            "@graphql-codegen/c-sharp": {
              "additionalProperties": false,
              "$ref": "#/definitions/CSharpResolversPluginRawConfig"
            },
            "c-sharp-operations": {
              "additionalProperties": false,
              "$ref": "#/definitions/CSharpOperationsRawPluginConfig"
            },
            "@graphql-codegen/c-sharp-operations": {
              "additionalProperties": false,
              "$ref": "#/definitions/CSharpOperationsRawPluginConfig"
            },
            "schema-ast": { "additionalProperties": false, "$ref": "#/definitions/SchemaASTConfig" },
            "@graphql-codegen/schema-ast": { "additionalProperties": false, "$ref": "#/definitions/SchemaASTConfig" },
            "typescript-type-graphql": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeGraphQLPluginConfig"
            },
            "@graphql-codegen/typescript-type-graphql": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeGraphQLPluginConfig"
            },
            "typescript-graphql-files-modules": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeScriptFilesModulesPluginConfig"
            },
            "@graphql-codegen/typescript-graphql-files-modules": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeScriptFilesModulesPluginConfig"
            },
            "named-operations-object": {
              "additionalProperties": false,
              "$ref": "#/definitions/NamedOperationsObjectPluginConfig"
            },
            "@graphql-codegen/named-operations-object": {
              "additionalProperties": false,
              "$ref": "#/definitions/NamedOperationsObjectPluginConfig"
            },
            "typescript-graphql-request": {
              "additionalProperties": false,
              "$ref": "#/definitions/RawGraphQLRequestPluginConfig"
            },
            "@graphql-codegen/typescript-graphql-request": {
              "additionalProperties": false,
              "$ref": "#/definitions/RawGraphQLRequestPluginConfig"
            },
            "typescript-mongodb": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeScriptMongoPluginConfig"
            },
            "@graphql-codegen/typescript-mongodb": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeScriptMongoPluginConfig"
            },
            "typescript-resolvers": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeScriptResolversPluginConfig"
            },
            "@graphql-codegen/typescript-resolvers": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeScriptResolversPluginConfig"
            },
            "typescript-apollo-angular": {
              "additionalProperties": false,
              "$ref": "#/definitions/ApolloAngularRawPluginConfig"
            },
            "@graphql-codegen/typescript-apollo-angular": {
              "additionalProperties": false,
              "$ref": "#/definitions/ApolloAngularRawPluginConfig"
            },
            "typescript-nhost": { "additionalProperties": false, "$ref": "#/definitions/NhostPluginConfig" },
            "@graphql-codegen/typescript-nhost": {
              "additionalProperties": false,
              "$ref": "#/definitions/NhostPluginConfig"
            },
            "typescript-urql": { "additionalProperties": false, "$ref": "#/definitions/UrqlRawPluginConfig" },
            "@graphql-codegen/typescript-urql": {
              "additionalProperties": false,
              "$ref": "#/definitions/UrqlRawPluginConfig"
            },
            "typescript-react-apollo": {
              "additionalProperties": false,
              "$ref": "#/definitions/ReactApolloRawPluginConfig"
            },
            "@graphql-codegen/typescript-react-apollo": {
              "additionalProperties": false,
              "$ref": "#/definitions/ReactApolloRawPluginConfig"
            },
            "typescript-vue-apollo": {
              "additionalProperties": false,
              "$ref": "#/definitions/VueApolloRawPluginConfig"
            },
            "@graphql-codegen/typescript-vue-apollo": {
              "additionalProperties": false,
              "$ref": "#/definitions/VueApolloRawPluginConfig"
            },
            "typescript-vue-apollo-smart-ops": {
              "additionalProperties": false,
              "$ref": "#/definitions/VueApolloSmartOpsRawPluginConfig"
            },
            "@graphql-codegen/typescript-vue-apollo-smart-ops": {
              "additionalProperties": false,
              "$ref": "#/definitions/VueApolloSmartOpsRawPluginConfig"
            },
            "typescript-vue-urql": { "additionalProperties": false, "$ref": "#/definitions/VueUrqlRawPluginConfig" },
            "@graphql-codegen/typescript-vue-urql": {
              "additionalProperties": false,
              "$ref": "#/definitions/VueUrqlRawPluginConfig"
            },
            "typescript-stencil-apollo": {
              "additionalProperties": false,
              "$ref": "#/definitions/StencilApolloRawPluginConfig"
            },
            "@graphql-codegen/typescript-stencil-apollo": {
              "additionalProperties": false,
              "$ref": "#/definitions/StencilApolloRawPluginConfig"
            },
            "typescript-document-nodes": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeScriptDocumentNodesRawPluginConfig"
            },
            "@graphql-codegen/typescript-document-nodes": {
              "additionalProperties": false,
              "$ref": "#/definitions/TypeScriptDocumentNodesRawPluginConfig"
            },
            "typescript-msw": { "additionalProperties": false, "$ref": "#/definitions/MSWConfig" },
            "@graphql-codegen/typescript-msw": { "additionalProperties": false, "$ref": "#/definitions/MSWConfig" },
            "java-apollo-android": {
              "additionalProperties": false,
              "$ref": "#/definitions/JavaApolloAndroidPluginConfig"
            },
            "@graphql-codegen/java-apollo-android": {
              "additionalProperties": false,
              "$ref": "#/definitions/JavaApolloAndroidPluginConfig"
            },
            "java-resolvers": { "additionalProperties": false, "$ref": "#/definitions/JavaResolversPluginRawConfig" },
            "@graphql-codegen/java-resolvers": {
              "additionalProperties": false,
              "$ref": "#/definitions/JavaResolversPluginRawConfig"
            },
            "java": { "additionalProperties": false, "$ref": "#/definitions/JavaResolversPluginRawConfig" },
            "@graphql-codegen/java": {
              "additionalProperties": false,
              "$ref": "#/definitions/JavaResolversPluginRawConfig"
            },
            "kotlin": { "additionalProperties": false, "$ref": "#/definitions/KotlinResolversPluginRawConfig" },
            "@graphql-codegen/kotlin": {
              "additionalProperties": false,
              "$ref": "#/definitions/KotlinResolversPluginRawConfig"
            },
            "flow": { "additionalProperties": false, "$ref": "#/definitions/FlowPluginConfig" },
            "@graphql-codegen/flow": { "additionalProperties": false, "$ref": "#/definitions/FlowPluginConfig" },
            "flow-resolvers": { "additionalProperties": false, "$ref": "#/definitions/FlowResolversPluginConfig" },
            "@graphql-codegen/flow-resolvers": {
              "additionalProperties": false,
              "$ref": "#/definitions/FlowResolversPluginConfig"
            },
            "flow-operations": { "additionalProperties": false, "$ref": "#/definitions/FlowDocumentsPluginConfig" },
            "@graphql-codegen/flow-operations": {
              "additionalProperties": false,
              "$ref": "#/definitions/FlowDocumentsPluginConfig"
            },
            "introspection": { "additionalProperties": false, "$ref": "#/definitions/IntrospectionPluginConfig" },
            "@graphql-codegen/introspection": {
              "additionalProperties": false,
              "$ref": "#/definitions/IntrospectionPluginConfig"
            },
            "fragment-matcher": { "additionalProperties": false, "$ref": "#/definitions/FragmentMatcherConfig" },
            "@graphql-codegen/fragment-matcher": {
              "additionalProperties": false,
              "$ref": "#/definitions/FragmentMatcherConfig"
            },
            "urql-introspection": { "additionalProperties": false, "$ref": "#/definitions/UrqlIntrospectionConfig" },
            "@graphql-codegen/urql-introspection": {
              "additionalProperties": false,
              "$ref": "#/definitions/UrqlIntrospectionConfig"
            },
            "hasura-allow-list": { "additionalProperties": false, "$ref": "#/definitions/HasuraAllowListPluginConfig" },
            "@graphql-codegen/hasura-allow-list": {
              "additionalProperties": false,
              "$ref": "#/definitions/HasuraAllowListPluginConfig"
            }
          }
        },
        {
          "type": "string",
          "oneOf": [
            {
              "const": "flutter-freezed",
              "description": "configure the `flutter-freezed` plugin\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/flutter-freezed\n\n=> Make sure to include \"@graphql-codegen/flutter-freezed\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/flutter-freezed",
              "description": "configure the `flutter-freezed` plugin\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/flutter-freezed\n\n=> Make sure to include \"@graphql-codegen/flutter-freezed\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-react-query",
              "description": "This plugin generates `React-Query` Hooks with TypeScript typings.\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` - and thus shares a similar configuration.\n\n> **If you are using the `react-query` package instead of the `@tanstack/react-query` package in your project, please set the `legacyMode` option to `true`.**\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-react-query\n\n=> Make sure to include \"@graphql-codegen/typescript-react-query\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-react-query",
              "description": "This plugin generates `React-Query` Hooks with TypeScript typings.\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` - and thus shares a similar configuration.\n\n> **If you are using the `react-query` package instead of the `@tanstack/react-query` package in your project, please set the `legacyMode` option to `true`.**\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-react-query\n\n=> Make sure to include \"@graphql-codegen/typescript-react-query\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-rtk-query",
              "description": "\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-rtk-query\n\n=> Make sure to include \"@graphql-codegen/typescript-rtk-query\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-rtk-query",
              "description": "\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-rtk-query\n\n=> Make sure to include \"@graphql-codegen/typescript-rtk-query\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-generic-sdk",
              "description": "This plugin generate a generic SDK (without any Requester implemented), allow you to easily customize the way you fetch your data, without loosing the strongly-typed integration.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-generic-sdk\n\n=> Make sure to include \"@graphql-codegen/typescript-generic-sdk\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-generic-sdk",
              "description": "This plugin generate a generic SDK (without any Requester implemented), allow you to easily customize the way you fetch your data, without loosing the strongly-typed integration.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-generic-sdk\n\n=> Make sure to include \"@graphql-codegen/typescript-generic-sdk\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-apollo-client-helpers",
              "description": "\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-apollo-client-helpers\n\n=> Make sure to include \"@graphql-codegen/typescript-apollo-client-helpers\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-apollo-client-helpers",
              "description": "\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-apollo-client-helpers\n\n=> Make sure to include \"@graphql-codegen/typescript-apollo-client-helpers\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "add",
              "description": "\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/add\n\n=> Make sure to include \"@graphql-codegen/add\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/add",
              "description": "\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/add\n\n=> Make sure to include \"@graphql-codegen/add\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "time",
              "description": "\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/time\n\n=> Make sure to include \"@graphql-codegen/time\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/time",
              "description": "\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/time\n\n=> Make sure to include \"@graphql-codegen/time\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript",
              "description": "This plugin generates the base TypeScript types, based on your GraphQL schema.\n\nThe types generated by this plugin are simple, and refers to the exact structure of your schema, and it's used as the base types for other plugins (such as `typescript-operations` / `typescript-resolvers`)\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript\n\n=> Make sure to include \"@graphql-codegen/typescript\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript",
              "description": "This plugin generates the base TypeScript types, based on your GraphQL schema.\n\nThe types generated by this plugin are simple, and refers to the exact structure of your schema, and it's used as the base types for other plugins (such as `typescript-operations` / `typescript-resolvers`)\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript\n\n=> Make sure to include \"@graphql-codegen/typescript\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-operations",
              "description": "This plugin generates TypeScript types based on your GraphQLSchema _and_ your GraphQL operations and fragments.\nIt generates types for your GraphQL documents: Query, Mutation, Subscription and Fragment.\n\nNote: In most configurations, this plugin requires you to use `typescript as well, because it depends on its base types.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-operations\n\n=> Make sure to include \"@graphql-codegen/typescript-operations\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-operations",
              "description": "This plugin generates TypeScript types based on your GraphQLSchema _and_ your GraphQL operations and fragments.\nIt generates types for your GraphQL documents: Query, Mutation, Subscription and Fragment.\n\nNote: In most configurations, this plugin requires you to use `typescript as well, because it depends on its base types.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-operations\n\n=> Make sure to include \"@graphql-codegen/typescript-operations\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "c-sharp",
              "description": "This plugin generates C# `class` identifier for your schema types.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/c-sharp\n\n=> Make sure to include \"@graphql-codegen/c-sharp\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/c-sharp",
              "description": "This plugin generates C# `class` identifier for your schema types.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/c-sharp\n\n=> Make sure to include \"@graphql-codegen/c-sharp\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "c-sharp-operations",
              "description": "This plugin generates C# `class` based on your GraphQL operations.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/c-sharp-operations\n\n=> Make sure to include \"@graphql-codegen/c-sharp-operations\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/c-sharp-operations",
              "description": "This plugin generates C# `class` based on your GraphQL operations.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/c-sharp-operations\n\n=> Make sure to include \"@graphql-codegen/c-sharp-operations\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "schema-ast",
              "description": "This plugin prints the merged schema as string. If multiple schemas are provided, they will be merged and printed as one schema.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/schema-ast\n\n=> Make sure to include \"@graphql-codegen/schema-ast\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/schema-ast",
              "description": "This plugin prints the merged schema as string. If multiple schemas are provided, they will be merged and printed as one schema.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/schema-ast\n\n=> Make sure to include \"@graphql-codegen/schema-ast\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-type-graphql",
              "description": "\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-type-graphql\n\n=> Make sure to include \"@graphql-codegen/typescript-type-graphql\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-type-graphql",
              "description": "\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-type-graphql\n\n=> Make sure to include \"@graphql-codegen/typescript-type-graphql\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-graphql-files-modules",
              "description": "This plugin generates TypeScript typings for `.graphql` files containing GraphQL documents, which later on can be consumed using [`graphql-tag/loader`](https://github.com/apollographql/graphql-tag#webpack-preprocessing-with-graphql-tagloader) or use `string` types if you will use the operations as raw strings, and get type-check and type-safety for your imports. This means that any time you import objects from `.graphql` files, your IDE will provide auto-complete.\n\nThis plugin also handles `.graphql` files containing multiple GraphQL documents, and name the imports according to the operation name.\n\n> âš  Fragments are not generated with named imports, only as default imports, due to `graphql-tag/loader` behavior.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-graphql-files-modules\n\n=> Make sure to include \"@graphql-codegen/typescript-graphql-files-modules\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-graphql-files-modules",
              "description": "This plugin generates TypeScript typings for `.graphql` files containing GraphQL documents, which later on can be consumed using [`graphql-tag/loader`](https://github.com/apollographql/graphql-tag#webpack-preprocessing-with-graphql-tagloader) or use `string` types if you will use the operations as raw strings, and get type-check and type-safety for your imports. This means that any time you import objects from `.graphql` files, your IDE will provide auto-complete.\n\nThis plugin also handles `.graphql` files containing multiple GraphQL documents, and name the imports according to the operation name.\n\n> âš  Fragments are not generated with named imports, only as default imports, due to `graphql-tag/loader` behavior.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-graphql-files-modules\n\n=> Make sure to include \"@graphql-codegen/typescript-graphql-files-modules\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "named-operations-object",
              "description": "\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/named-operations-object\n\n=> Make sure to include \"@graphql-codegen/named-operations-object\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/named-operations-object",
              "description": "\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/named-operations-object\n\n=> Make sure to include \"@graphql-codegen/named-operations-object\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-graphql-request",
              "description": "This plugin generates [`graphql-request`](https://npmjs.com/package/graphql-request) ready-to-use SDK, which is fully-typed.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-graphql-request\n\n=> Make sure to include \"@graphql-codegen/typescript-graphql-request\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-graphql-request",
              "description": "This plugin generates [`graphql-request`](https://npmjs.com/package/graphql-request) ready-to-use SDK, which is fully-typed.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-graphql-request\n\n=> Make sure to include \"@graphql-codegen/typescript-graphql-request\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-mongodb",
              "description": "\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-mongodb\n\n=> Make sure to include \"@graphql-codegen/typescript-mongodb\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-mongodb",
              "description": "\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-mongodb\n\n=> Make sure to include \"@graphql-codegen/typescript-mongodb\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-resolvers",
              "description": "This plugin generates TypeScript signature for `resolve` functions of your GraphQL API.\nYou can use this plugin to generate simple resolvers signature based on your GraphQL types, or you can change its behavior be providing custom model types (mappers).\n\nYou can find a blog post explaining the usage of this plugin here: https://the-guild.dev/blog/better-type-safety-for-resolvers-with-graphql-codegen\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-resolvers\n\n=> Make sure to include \"@graphql-codegen/typescript-resolvers\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-resolvers",
              "description": "This plugin generates TypeScript signature for `resolve` functions of your GraphQL API.\nYou can use this plugin to generate simple resolvers signature based on your GraphQL types, or you can change its behavior be providing custom model types (mappers).\n\nYou can find a blog post explaining the usage of this plugin here: https://the-guild.dev/blog/better-type-safety-for-resolvers-with-graphql-codegen\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-resolvers\n\n=> Make sure to include \"@graphql-codegen/typescript-resolvers\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-apollo-angular",
              "description": "This plugin generates Apollo services (`Query`, `Mutation` and `Subscription`) with TypeScript typings.\n\nIt will generate a strongly typed Angular service for every defined query, mutation or subscription. The generated Angular services are ready to inject and use within your Angular component.\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` - and thus shares a similar configuration.\n\nTo shed some more light regards this template, it's recommended to go through this article: https://apollo-angular.com/docs/get-started, and to read the Code Generation with Apollo Angular: https://the-guild.dev/blog/apollo-angular-12\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-apollo-angular\n\n=> Make sure to include \"@graphql-codegen/typescript-apollo-angular\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-apollo-angular",
              "description": "This plugin generates Apollo services (`Query`, `Mutation` and `Subscription`) with TypeScript typings.\n\nIt will generate a strongly typed Angular service for every defined query, mutation or subscription. The generated Angular services are ready to inject and use within your Angular component.\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` - and thus shares a similar configuration.\n\nTo shed some more light regards this template, it's recommended to go through this article: https://apollo-angular.com/docs/get-started, and to read the Code Generation with Apollo Angular: https://the-guild.dev/blog/apollo-angular-12\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-apollo-angular\n\n=> Make sure to include \"@graphql-codegen/typescript-apollo-angular\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-nhost",
              "description": "This plugin generates the Typescript schema that enables queries and mutations to be typed in the Nhost SDK.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-nhost\n\n=> Make sure to include \"@graphql-codegen/typescript-nhost\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-nhost",
              "description": "This plugin generates the Typescript schema that enables queries and mutations to be typed in the Nhost SDK.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-nhost\n\n=> Make sure to include \"@graphql-codegen/typescript-nhost\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-urql",
              "description": "This plugin generates `urql` (https://github.com/FormidableLabs/urql) components and HOC with TypeScript typings.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-urql\n\n=> Make sure to include \"@graphql-codegen/typescript-urql\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-urql",
              "description": "This plugin generates `urql` (https://github.com/FormidableLabs/urql) components and HOC with TypeScript typings.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-urql\n\n=> Make sure to include \"@graphql-codegen/typescript-urql\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-react-apollo",
              "description": "This plugin generates React Apollo components and HOC with TypeScript typings.\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` - and thus shares a similar configuration.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-react-apollo\n\n=> Make sure to include \"@graphql-codegen/typescript-react-apollo\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-react-apollo",
              "description": "This plugin generates React Apollo components and HOC with TypeScript typings.\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` - and thus shares a similar configuration.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-react-apollo\n\n=> Make sure to include \"@graphql-codegen/typescript-react-apollo\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-vue-apollo",
              "description": "This plugin generates\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-vue-apollo\n\n=> Make sure to include \"@graphql-codegen/typescript-vue-apollo\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-vue-apollo",
              "description": "This plugin generates\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-vue-apollo\n\n=> Make sure to include \"@graphql-codegen/typescript-vue-apollo\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-vue-apollo-smart-ops",
              "description": "This plugin generates Vue Apollo Smart Query, Smart Subscription and mutation operation functions with\nTypeScript typings.\n\nThis plugin relies on some helper functions and types from the `vue-apollo-smart-ops` package. That package also adds\nsome optional functionality for improved error handling in Vue Apollo operations which can be configured in the\ngenerated code from this plugin.\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` -\nand thus shares a similar configuration.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-vue-apollo-smart-ops\n\n=> Make sure to include \"@graphql-codegen/typescript-vue-apollo-smart-ops\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-vue-apollo-smart-ops",
              "description": "This plugin generates Vue Apollo Smart Query, Smart Subscription and mutation operation functions with\nTypeScript typings.\n\nThis plugin relies on some helper functions and types from the `vue-apollo-smart-ops` package. That package also adds\nsome optional functionality for improved error handling in Vue Apollo operations which can be configured in the\ngenerated code from this plugin.\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` -\nand thus shares a similar configuration.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-vue-apollo-smart-ops\n\n=> Make sure to include \"@graphql-codegen/typescript-vue-apollo-smart-ops\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-vue-urql",
              "description": "This plugin generates `urql` (https://github.com/FormidableLabs/urql) composition functions with TypeScript typings.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-vue-urql\n\n=> Make sure to include \"@graphql-codegen/typescript-vue-urql\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-vue-urql",
              "description": "This plugin generates `urql` (https://github.com/FormidableLabs/urql) composition functions with TypeScript typings.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-vue-urql\n\n=> Make sure to include \"@graphql-codegen/typescript-vue-urql\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-stencil-apollo",
              "description": "This plugin generates Stencil Apollo functional components typings\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` - and thus shares a similar configuration.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-stencil-apollo\n\n=> Make sure to include \"@graphql-codegen/typescript-stencil-apollo\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-stencil-apollo",
              "description": "This plugin generates Stencil Apollo functional components typings\n\nIt extends the basic TypeScript plugins: `@graphql-codegen/typescript`, `@graphql-codegen/typescript-operations` - and thus shares a similar configuration.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-stencil-apollo\n\n=> Make sure to include \"@graphql-codegen/typescript-stencil-apollo\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-document-nodes",
              "description": "This plugin generates TypeScript source `.ts` file from GraphQL files `.graphql`.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-document-nodes\n\n=> Make sure to include \"@graphql-codegen/typescript-document-nodes\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-document-nodes",
              "description": "This plugin generates TypeScript source `.ts` file from GraphQL files `.graphql`.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-document-nodes\n\n=> Make sure to include \"@graphql-codegen/typescript-document-nodes\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "typescript-msw",
              "description": "This plugin generates `msw` (https://github.com/mswjs/msw) mock handlers with TypeScript typings.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-msw\n\n=> Make sure to include \"@graphql-codegen/typescript-msw\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/typescript-msw",
              "description": "This plugin generates `msw` (https://github.com/mswjs/msw) mock handlers with TypeScript typings.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/typescript-msw\n\n=> Make sure to include \"@graphql-codegen/typescript-msw\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "java-apollo-android",
              "description": "This plugin and presets creates generated mappers and parsers for a complete type-safe GraphQL requests, for developers that uses Apollo Android runtime.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/java-apollo-android\n\n=> Make sure to include \"@graphql-codegen/java-apollo-android\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/java-apollo-android",
              "description": "This plugin and presets creates generated mappers and parsers for a complete type-safe GraphQL requests, for developers that uses Apollo Android runtime.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/java-apollo-android\n\n=> Make sure to include \"@graphql-codegen/java-apollo-android\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "java-resolvers",
              "description": "\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/java-resolvers\n\n=> Make sure to include \"@graphql-codegen/java-resolvers\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/java-resolvers",
              "description": "\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/java-resolvers\n\n=> Make sure to include \"@graphql-codegen/java-resolvers\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "java",
              "description": "\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/java\n\n=> Make sure to include \"@graphql-codegen/java\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/java",
              "description": "\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/java\n\n=> Make sure to include \"@graphql-codegen/java\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "kotlin",
              "description": "\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/kotlin\n\n=> Make sure to include \"@graphql-codegen/kotlin\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/kotlin",
              "description": "\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/kotlin\n\n=> Make sure to include \"@graphql-codegen/kotlin\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "flow",
              "description": "This plugin generates Flow types based on your `GraphQLSchema`.\n\nIt generates types for your entire schema: types, input types, enum, interface, scalar and union.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/flow\n\n=> Make sure to include \"@graphql-codegen/flow\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/flow",
              "description": "This plugin generates Flow types based on your `GraphQLSchema`.\n\nIt generates types for your entire schema: types, input types, enum, interface, scalar and union.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/flow\n\n=> Make sure to include \"@graphql-codegen/flow\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "flow-resolvers",
              "description": "This plugin generates resolvers signature based on your `GraphQLSchema`.\n\nIt generates types for your entire schema: types, input types, enum, interface, scalar and union.\n\nThis plugin requires you to use `@graphql-codegen/flow` as well, because it depends on it's types.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/flow-resolvers\n\n=> Make sure to include \"@graphql-codegen/flow-resolvers\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/flow-resolvers",
              "description": "This plugin generates resolvers signature based on your `GraphQLSchema`.\n\nIt generates types for your entire schema: types, input types, enum, interface, scalar and union.\n\nThis plugin requires you to use `@graphql-codegen/flow` as well, because it depends on it's types.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/flow-resolvers\n\n=> Make sure to include \"@graphql-codegen/flow-resolvers\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "flow-operations",
              "description": "This plugin generates Flow types based on your `GraphQLSchema` and your GraphQL operations and fragments.\n\nIt generates types for your GraphQL documents: Query, Mutation, Subscription and Fragment.\n\nThis plugin requires you to use `@graphql-codegen/flow` as well, because it depends on its types.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/flow-operations\n\n=> Make sure to include \"@graphql-codegen/flow-operations\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/flow-operations",
              "description": "This plugin generates Flow types based on your `GraphQLSchema` and your GraphQL operations and fragments.\n\nIt generates types for your GraphQL documents: Query, Mutation, Subscription and Fragment.\n\nThis plugin requires you to use `@graphql-codegen/flow` as well, because it depends on its types.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/flow-operations\n\n=> Make sure to include \"@graphql-codegen/flow-operations\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "introspection",
              "description": "This plugin generates a GraphQL introspection file based on your GraphQL schema.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/introspection\n\n=> Make sure to include \"@graphql-codegen/introspection\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/introspection",
              "description": "This plugin generates a GraphQL introspection file based on your GraphQL schema.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/introspection\n\n=> Make sure to include \"@graphql-codegen/introspection\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "fragment-matcher",
              "description": "This plugin generates an introspection file but only with Interfaces and Unions, based on your GraphQLSchema.\n\nIf you are using `apollo-client` and your schema contains `interface` or `union` declaration, it's recommended to use Apollo's Fragment Matcher and the result generated by the plugin.\n\nYou can read more about it in [`apollo-client` documentation](https://apollographql.com/docs/react/data/fragments/#fragments-on-unions-and-interfaces).\n\nFragment Matcher plugin accepts a TypeScript / JavaScript or a JSON file as an output _(`.ts, .tsx, .js, .jsx, .json`)_.\n\nBoth in TypeScript and JavaScript a default export is being used.\n\n> The output is based on the output you choose for the output file name.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/fragment-matcher\n\n=> Make sure to include \"@graphql-codegen/fragment-matcher\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/fragment-matcher",
              "description": "This plugin generates an introspection file but only with Interfaces and Unions, based on your GraphQLSchema.\n\nIf you are using `apollo-client` and your schema contains `interface` or `union` declaration, it's recommended to use Apollo's Fragment Matcher and the result generated by the plugin.\n\nYou can read more about it in [`apollo-client` documentation](https://apollographql.com/docs/react/data/fragments/#fragments-on-unions-and-interfaces).\n\nFragment Matcher plugin accepts a TypeScript / JavaScript or a JSON file as an output _(`.ts, .tsx, .js, .jsx, .json`)_.\n\nBoth in TypeScript and JavaScript a default export is being used.\n\n> The output is based on the output you choose for the output file name.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/fragment-matcher\n\n=> Make sure to include \"@graphql-codegen/fragment-matcher\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "urql-introspection",
              "description": "This plugin generates an introspection file for Schema Awareness feature of Urql Cache Exchange\n\nYou can read more about it in `urql` documentation: https://formidable.com/open-source/urql/docs/graphcache/schema-awareness.\n\nUrql Introspection plugin accepts a TypeScript / JavaScript or a JSON file as an output _(`.ts, .tsx, .js, .jsx, .json`)_.\n\nBoth in TypeScript and JavaScript a default export is being used.\n\n> The output is based on the output you choose for the output file name.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/urql-introspection\n\n=> Make sure to include \"@graphql-codegen/urql-introspection\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/urql-introspection",
              "description": "This plugin generates an introspection file for Schema Awareness feature of Urql Cache Exchange\n\nYou can read more about it in `urql` documentation: https://formidable.com/open-source/urql/docs/graphcache/schema-awareness.\n\nUrql Introspection plugin accepts a TypeScript / JavaScript or a JSON file as an output _(`.ts, .tsx, .js, .jsx, .json`)_.\n\nBoth in TypeScript and JavaScript a default export is being used.\n\n> The output is based on the output you choose for the output file name.\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/urql-introspection\n\n=> Make sure to include \"@graphql-codegen/urql-introspection\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "hasura-allow-list",
              "description": "\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/hasura-allow-list\n\n=> Make sure to include \"@graphql-codegen/hasura-allow-list\" in your package.json file and install your dependencies.\n\n"
            },
            {
              "const": "@graphql-codegen/hasura-allow-list",
              "description": "\n\nFor more details and documentation: https://the-guild.dev/graphql/codegen/docs/plugins/hasura-allow-list\n\n=> Make sure to include \"@graphql-codegen/hasura-allow-list\" in your package.json file and install your dependencies.\n\n"
            }
          ]
        },
        {
          "type": "string",
          "description": "Point to a custom plugin loaded from your file-system.",
          "pattern": "(\\\\?([^\\/]*[\\/])*)([^\\/]+)$"
        },
        {
          "type": "string",
          "description": "You can point to any third-party module from node_modules that matches the requirements of a GraphQL Codegen plugin."
        }
      ]
    }
  },
  "$ref": "#/definitions/Types.Config"
}
