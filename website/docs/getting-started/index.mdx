---
id: index
title: Introduction to GraphQL Code Generator
---

GraphQL Code Generator is a tool that provides a set of plugins that will help you get the best of your GraphQL stack.

From back-end to front-end, GraphQL Code Generator will automate the generation of:

- **Typed Queries, Mutations and Subscriptions** for React, Vue, Angular, Next.js, Svelte, whether you are using Apollo Client, URQL or React Query.
- **Typed GraphQL resolvers**, for any Node.js (GraphQL Yoga, GraphQL Modules, TypeGraphQL or Apollo) or Java GraphQL server.
- **Full-typed Node.js SDKs, Apollo Android** support, and more!

<p>&nbsp;</p>
<p>&nbsp;</p>

## The perfect GraphQL Developer Experience

To illustrate how GraphQL Code Generator improves your Developer Experience, let's take a look the following schema and its usage in a front-end application:

```graphql
# schema.graphql

type Author {
  id: Int!
  firstName: String!
  lastName: String!
  posts(findTitle: String): [Post]
}

type Post {
  id: Int!
  title: String!
  author: Author
}

type Query {
  posts: [Post]
}
```

### From the front-end


Most implementation on client-side without GraphQL Code Generator would query the API as follows:

<CodeTabs namespace={`getting-started-front-end-codetabs`}>

<CodeTab label="URQL React">

```tsx
import { useQuery } from "urql";

interface PostQuery {
  posts: {
    id: string
    title: string
    author?: {
      id: string
      firstName: string
      lastName: string
    }
  }[]
}

const postsQueryDocument = `
  query Posts {
    posts {
        id
        title
        author {
          id
          firstName
          lastName
        }
    }
  }
`

const Posts = () => {
  const [result] = useQuery<PostQuery>({ query: postsQueryDocument});

  // ...
}
```

</CodeTab>

<CodeTab label="React Query">

```tsx
import { request, gql } from "graphql-request";
import { useQuery } from "react-query";

interface PostQuery {
  posts: {
    id: string
    title: string
    author?: {
      id: string
      firstName: string
      lastName: string
    }
  }[]
}

const postsQueryDocument = gql`
  query Posts {
    posts {
        id
        title
        author {
          id
          firstName
          lastName
        }
    }
  }
`

const Posts = () => {
  const { data } = useQuery<PostQuery>("posts", async () => {
    const {
      posts,
    } = await request(
      endpoint,
      postsQueryDocument
    );
    return posts;
  });

  // ...
}
```

</CodeTab>

<CodeTab label="Vue Apollo">

```vue
<template>
  <div class="apollo">
    <!-- UI... -->
  </div>
</template>

<script>
interface PostQueryVariables {
  id: string
}

export default {
  apollo: {
    post: {
      query: gql`query ($id: ID!) {
        post(id: $id) {
          id
          title
          author {
            id
            firstName
            lastName
          }
        }
      }`,
      variables: {
        id: 1
      } as PostQueryVariables,
    },
  },
  data () {
    return {
      post: undefined,
    }
  },
};
</script>
```

</CodeTab>

<CodeTab label="Angular Apollo">

```tsx
const GET_POSTS = gql`
  query Posts {
    posts {
        id
        title
        author {
          id
          firstName
          lastName
        }
    }
  }
`;

interface Post {
  id: string
  title: string
  author?: {
    id: string
    firstName: string
    lastName: string
  }
}

@Component({ /* ... */ })
class PostsComponent implements OnInit, OnDestroy {
  posts: Post[];

  private querySubscription: Subscription;

  ngOnInit() {
    this.querySubscription = this.apollo
      .watchQuery({
        query: GET_POSTS,
      })
      .valueChanges.subscribe(({ data }) => {
        this.posts = data.posts as Post[];
      });
  }
  ngOnDestroy() {
    this.querySubscription.unsubscribe();
  }
}
```

</CodeTab>

<CodeTab label="Svelte Apollo">

```svelte
<script lang="ts">
  import { query } from "svelte-apollo";

  const postsQueryDocument = gql`
    query Posts {
      posts {
          id
          title
          author {
            id
            firstName
            lastName
          }
      }
    }
  `

  const posts = query(postsQueryDocument);
</script>

<ul>
    { /* UI */ }
</ul>
```

</CodeTab>

</CodeTabs>

However, not typing or manually maintaining the data-types can lead to many issues:


  - **outdated typing** (regarding the current Schema)

  - **typos**

  - **partial typing** of data (not all Schema&apos;s fields has a corresponding type)


The strength of your front-end application types is based on your data types, therefore, any mistake on your
manually maintained data types will ripple in many of your components.


For this reason, automating and generating the typing of your GraphQL operations will both improve the developer
experience and stability of your stack.

After a few steps to [install](/docs/getting-started/installation) and [configure](/docs/config-reference/codegen-config) GraphQL Code Generator, our front-end code will be fully-typed and
up-to-date as follows:


<CodeTabs namespace={`getting-started-front-end-codetabs`}>


<CodeTab label="URQL React">

```tsx
import { useQuery } from "urql";
import { postsQueryDocument } from './graphql/generated';

const Posts = () => {
  const [result] = useQuery({ query: postsQueryDocument});

  // `result` is fully typed!
  // ...
}
```

</CodeTab>


<CodeTab label="React Query">

```tsx
import { usePosts } from "../graphql/generated";


const Posts = () => {
  const { data } = usePosts()

  // `data` is typed!

  // ...
}
```

</CodeTab>

<CodeTab label="Vue Apollo">

```vue
<template>
  <div class="apollo">
    <!-- UI... -->
  </div>
</template>

<script>
import { usePostQuery } from '../generated/graphql';

export default {
  apollo: usePostQuery({
    // `variables` is properly typed!
    variables: {
      id: 1
    }
  }),
  data () {
    return {
      post: undefined,
    }
  },
};
</script>
```

</CodeTab>

<CodeTab label="Angular Apollo">

```tsx
import { PostsGQL, PostsQuery } from './graphql'
//BE SURE TO USE Observable from `rxjs` and not from `@apollo/client/core` when using map
import { Observable } from 'rxjs'
import { map } from 'rxjs/operators'

@Component({ /* ... */ })
export class PostsComponent {
  posts: Observable<PostsQuery['posts']>

  constructor(postsGQL: PostsGQL) {
    this.posts = postsGQL.watch().valueChanges.pipe(map(result => result.data.posts))
  }
}
```

</CodeTab>

<CodeTab label="Svelte Apollo">

```svelte
<script lang="ts">
  import { Posts } from "../graphql/generated";

  // `posts` is fully typed, also are `Posts()` options!
  const posts = Posts();
</script>

<ul>
    { /* UI */ }
</ul>
```

</CodeTab>

</CodeTabs>

Now, with a simple configuration and a npm/yarn script, the front-end developers will benefit from:


  - **up-to-date typings**


  - **autocompletion on all queries, mutations and subscription variables and results**


  - **less boilerplate** (thanks to full code generation such as React hooks generation)



<br />

:::tip How does GraphQL Code Generator work?
More details on the inner working of GraphQL Code Generator are available on [this page](/docs/getting-started/how-does-it-work).
:::

### To the back-end

_// TODO_


<p>&nbsp;</p>


## What's next?

Start by [installing GraphQL Code Generator](/docs/getting-started/installation) in your project, and use the basic plugins to generate some code.

You can go over [the list of available plugins](/plugins) and find more plugins that matches your needs.

If you are having issues, you can reach us this the following:

- Found a bug? [report it in our GitHub repo](https://github.com/dotansimha/graphql-code-generator)
- Need help or have a question? You can use the live chat box in the corner of the screen, [ask it in our GitHub Discussions page](https://github.com/dotansimha/graphql-code-generator/discussions) or [reach us directly in our Discord](http://bit.ly/guild-chat).
- We have more awesome [open source tools](https://github.com/the-guild-org/Stack)!
- You can [visit our website](http://the-guild.dev) for more information about us and what we do
