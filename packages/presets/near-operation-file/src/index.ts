import { Types, CodegenPlugin } from '@graphql-codegen/plugin-helpers';
import { BaseVisitor, LoadedFragment } from '@graphql-codegen/visitor-plugin-common';
import * as addPlugin from '@graphql-codegen/add';
import { join, resolve, relative, dirname } from 'path';
import { Kind, FragmentDefinitionNode } from 'graphql';
import { appendExtensionToFilePath, clearExtension, extractExternalFragmentsInUse, fixLocalFile, resolveRelativeImport } from './utils';

export type NearOperationFileConfig = {
  baseTypesPath: string;
  extension?: string;
  cwd?: string;
  importTypesNamespace?: string;
};

export const preset: Types.OutputPreset<NearOperationFileConfig> = {
  buildGeneratesSection: options => {
    const baseVisitor = new BaseVisitor(options.config, {});

    if (!options.presetConfig.baseTypesPath) {
      throw new Error(`Preset "near-operation-file" requires you to specify "baseTypesPath" configuration and point it to your base types file (generated by "typescript" plugin)!`);
    }

    const baseDir = options.presetConfig.cwd || process.cwd();
    const extension = options.presetConfig.extension || '.generated.ts';
    const importTypesNamespace = options.presetConfig.importTypesNamespace || 'Types';
    const pluginMap: { [name: string]: CodegenPlugin } = {
      ...options.pluginMap,
      add: addPlugin,
    };

    const fragmentNameToFile: { [fragmentName: string]: { filePath: string; importName: string; onType: string } } = options.documents.reduce((prev, documentRecord) => {
      const fragments: FragmentDefinitionNode[] = documentRecord.content.definitions.filter(d => d.kind === Kind.FRAGMENT_DEFINITION) as FragmentDefinitionNode[];

      if (fragments.length > 0) {
        for (const fragment of fragments) {
          const filePath = appendExtensionToFilePath(documentRecord.filePath, extension);
          const importName = baseVisitor.convertName(fragment, { suffix: 'Fragment' });

          prev[fragment.name.value] = { filePath, importName, onType: fragment.name.value };
        }
      }

      return prev;
    }, {});

    return options.documents
      .map<Types.GenerateOptions | null>(documentFile => {
        const absTypesPath = resolve(baseDir, join(options.baseOutputDir, options.presetConfig.baseTypesPath));
        const absFilePath = appendExtensionToFilePath(documentFile.filePath, extension);
        const relativeImportPath = resolveRelativeImport(absFilePath, absTypesPath);
        const fragmentsInUse = extractExternalFragmentsInUse(documentFile.content);
        const plugins = [{ add: `import * as ${importTypesNamespace} from '${relativeImportPath}';\n` }, { add: `type Maybe<T> = T | null;\n` }, ...options.plugins];
        const config = {
          ...options.config,
          namespacedImportName: importTypesNamespace,
          externalFragments: [] as LoadedFragment[],
        };

        for (const fragmentName of fragmentsInUse) {
          const fragmentDetails = fragmentNameToFile[fragmentName];

          if (fragmentDetails) {
            const fragmentImportPath = resolveRelativeImport(absFilePath, fragmentDetails.filePath);

            plugins.unshift({
              add: `import { ${fragmentDetails.importName} } from '${fragmentImportPath}';`,
            });

            config.externalFragments.push({
              name: fragmentName,
              onType: fragmentDetails.onType,
            });
          }
        }

        return {
          filename: absFilePath,
          plugins,
          pluginMap,
          config,
          schema: options.schema,
          documents: [documentFile],
        };
      })
      .filter(f => f);
  },
};

export default preset;
