import { Types, CodegenPlugin } from '@graphql-codegen/plugin-helpers';
import { BaseVisitor, LoadedFragment } from '@graphql-codegen/visitor-plugin-common';
import * as addPlugin from '@graphql-codegen/add';
import { join, resolve } from 'path';
import { Kind, FragmentDefinitionNode } from 'graphql';
import { appendExtensionToFilePath, extractExternalFragmentsInUse, resolveRelativeImport } from './utils';

export type NearOperationFileConfig = {
  /**
   * @name baseTypesPath
   * @type string
   * @description Required, should point to the base schema types file.
   * The key of the output is used a the base path for this file.
   *
   * @example
   * ```yml
   * generates:
   * src/:
   *  preset: near-operation-file
   *  presetConfig:
   *    baseTypesPath: types.ts
   *  plugins:
   *    - typescript-operations
   * ```
   */
  baseTypesPath: string;
  /**
   * @name extension
   * @type string
   * @description Optional, sets the extension for the generated files. Use this to override the extension if you are using plugins that requires a different type of extensions (such as `typescript-react-apollo`)
   * @default .generates.ts
   *
   * @example
   * ```yml
   * generates:
   * src/:
   *  preset: near-operation-file
   *  presetConfig:
   *    baseTypesPath: types.ts
   *    extension: .generated.tsx
   *  plugins:
   *    - typescript-operations
   *    - typescript-react-apollo
   * ```
   */
  extension?: string;
  /**
   * @name cwd
   * @type string
   * @description Optional, override the `cwd` of the execution. We are using `cwd` to figure out the imports between files. Use this if your execuion path is not your project root directory.
   * @default process.cwd()
   *
   * @example
   * ```yml
   * generates:
   * src/:
   *  preset: near-operation-file
   *  presetConfig:
   *    baseTypesPath: types.ts
   *    cwd: /some/path
   *  plugins:
   *    - typescript-operations
   * ```
   */
  cwd?: string;
  /**
   * @name importTypesNamespace
   * @type string
   * @description Optional, override the name of the import namespace used to import from the `baseTypesPath` file.
   * @default Types
   *
   * @example
   * ```yml
   * generates:
   * src/:
   *  preset: near-operation-file
   *  presetConfig:
   *    baseTypesPath: types.ts
   *    importTypesNamespace: SchemaTypes
   *  plugins:
   *    - typescript-operations
   * ```
   */
  importTypesNamespace?: string;
};

export type FragmentNameToFile = { [fragmentName: string]: { filePath: string; importName: string; onType: string; node: FragmentDefinitionNode } };

export const preset: Types.OutputPreset<NearOperationFileConfig> = {
  buildGeneratesSection: options => {
    const baseVisitor = new BaseVisitor(options.config, {});

    if (!options.presetConfig.baseTypesPath) {
      throw new Error(`Preset "near-operation-file" requires you to specify "baseTypesPath" configuration and point it to your base types file (generated by "typescript" plugin)!`);
    }

    const baseDir = options.presetConfig.cwd || process.cwd();
    const extension = options.presetConfig.extension || '.generated.ts';
    const importTypesNamespace = options.presetConfig.importTypesNamespace || 'Types';
    const pluginMap: { [name: string]: CodegenPlugin } = {
      ...options.pluginMap,
      add: addPlugin,
    };

    const fragmentNameToFile: FragmentNameToFile = options.documents.reduce((prev, documentRecord) => {
      const fragments: FragmentDefinitionNode[] = documentRecord.content.definitions.filter(d => d.kind === Kind.FRAGMENT_DEFINITION) as FragmentDefinitionNode[];

      if (fragments.length > 0) {
        for (const fragment of fragments) {
          const filePath = appendExtensionToFilePath(documentRecord.filePath, extension);
          const importName = baseVisitor.convertName(fragment, { suffix: 'Fragment' });

          prev[fragment.name.value] = { filePath, importName, onType: fragment.typeCondition.name.value, node: fragment };
        }
      }

      return prev;
    }, {});

    const absTypesPath = resolve(baseDir, join(options.baseOutputDir, options.presetConfig.baseTypesPath));

    return options.documents
      .map<Types.GenerateOptions | null>(documentFile => {
        const generatedFilePath = appendExtensionToFilePath(documentFile.filePath, extension);
        const absGeneratedFilePath = resolve(baseDir, generatedFilePath);
        const relativeImportPath = resolveRelativeImport(absGeneratedFilePath, absTypesPath);
        const fragmentsInUse = extractExternalFragmentsInUse(documentFile.content, fragmentNameToFile);
        const plugins = [...options.plugins];

        const config = {
          ...options.config,
          namespacedImportName: importTypesNamespace,
          externalFragments: [] as LoadedFragment[],
        };

        for (const fragmentName of fragmentsInUse) {
          const fragmentDetails = fragmentNameToFile[fragmentName];

          if (fragmentDetails) {
            const absFragmentFilePath = resolve(baseDir, fragmentDetails.filePath);
            const fragmentImportPath = resolveRelativeImport(absGeneratedFilePath, absFragmentFilePath);

            plugins.unshift({
              add: `import { ${fragmentDetails.importName} } from '${fragmentImportPath}';`,
            });

            config.externalFragments.push({
              isExternal: true,
              importFrom: fragmentImportPath,
              name: fragmentName,
              onType: fragmentDetails.onType,
              node: fragmentDetails.node,
            });
          }
        }

        plugins.unshift({ add: `import * as ${importTypesNamespace} from '${relativeImportPath}';\n` });

        return {
          filename: generatedFilePath,
          plugins,
          pluginMap,
          config,
          schema: options.schema,
          schemaAst: options.schemaAst,
          documents: [documentFile],
        };
      })
      .filter(f => f);
  },
};

export default preset;
